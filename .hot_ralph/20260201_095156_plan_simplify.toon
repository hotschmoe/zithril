type: system
subtype: init
cwd: /home/hotschmoe/zithril
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
tools[18]: Task,TaskOutput,Bash,Glob,Grep,ExitPlanMode,Read,Edit,Write,NotebookEdit,WebFetch,TodoWrite,WebSearch,TaskStop,AskUserQuestion,Skill,EnterPlanMode,ToolSearch
mcp_servers[0]:
model: claude-opus-4-5-20251101
permissionMode: bypassPermissions
slash_commands[10]: keybindings-help,bd-to-br-migration,compact,context,cost,init,pr-comments,release-notes,review,security-review
apiKeySource: none
claude_code_version: "2.1.29"
output_style: default
agents[9]: Bash,general-purpose,statusline-setup,Explore,Plan,"code-simplifier:code-simplifier",build-verifier,gemini-analyzer,coder-sonnet
skills[2]: keybindings-help,bd-to-br-migration
plugins[2]{name,path}:
  code-simplifier,/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/code-simplifier/1.0.0
  rust-analyzer-lsp,/home/hotschmoe/.claude/plugins/cache/claude-plugins-official/rust-analyzer-lsp/1.0.0
uuid: a83e02ee-c8a2-460e-b9f8-247eab3def5b
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01J3w3eqgpsSyGqcCwvCyL7C
  type: message
  role: assistant
  content[1]{type,text}:
    text,I'll review the recent code changes and simplify where appropriate. Let me start by examining what was modified.
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 2
    cache_creation_input_tokens: 5716
    cache_read_input_tokens: 18004
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 5716
    output_tokens: 3
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: b91eb14c-43a9-4f67-b114-1131e4da9e78
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01J3w3eqgpsSyGqcCwvCyL7C
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01FJNPwprsrnaLUpAT1KgvtB
      name: Bash
      input:
        command: git status
        description: Check current git status
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 2
    cache_creation_input_tokens: 5716
    cache_read_input_tokens: 18004
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 5716
    output_tokens: 3
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: a1a9264a-e8e2-4278-bf99-dd5088ef2e26
type: user
message:
  role: user
  content[1]{tool_use_id,type,content,is_error}:
    toolu_01FJNPwprsrnaLUpAT1KgvtB,tool_result,"On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 29 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.hot_ralph/20260201_094513_introspection.md\n\t.hot_ralph/20260201_094636_plan_mode.toon\n\t.hot_ralph/20260201_095156_plan_simplify.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")",false
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: cd0bb9e2-b2a9-4345-ab58-ae2d9b81ae78
tool_use_result:
  stdout: "On branch dev-hotschmoe\nYour branch is ahead of 'origin/dev-hotschmoe' by 29 commits.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .beads/issues.jsonl\n\tmodified:   .hot_ralph/state.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.hot_ralph/20260201_094513_introspection.md\n\t.hot_ralph/20260201_094636_plan_mode.toon\n\t.hot_ralph/20260201_095156_plan_simplify.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
  stderr: ""
  interrupted: false
  isImage: false
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01J3w3eqgpsSyGqcCwvCyL7C
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01K2zBmXaia1ThtCvWNPcZsQ
      name: Bash
      input:
        command: git diff --name-only HEAD~3
        description: List files changed in recent commits
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 2
    cache_creation_input_tokens: 5716
    cache_read_input_tokens: 18004
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 5716
    output_tokens: 3
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "36f216d9-406e-4a38-9028-29800737f2f8"
type: user
message:
  role: user
  content[1]{tool_use_id,type,content,is_error}:
    toolu_01K2zBmXaia1ThtCvWNPcZsQ,tool_result,".beads/issues.jsonl\n.hot_ralph/20260201_093744_introspection.md\n.hot_ralph/20260201_093939_plan_mode.toon\n.hot_ralph/20260201_094421_plan_simplify.md\n.hot_ralph/state.json\nexamples/counter.zig\nexamples/list.zig\nsrc/backend.zig\nsrc/root.zig\nsrc/widgets.zig\nsrc/widgets/paragraph.zig",false
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "626add1d-34ec-437f-8675-3de79198a292"
tool_use_result:
  stdout: ".beads/issues.jsonl\n.hot_ralph/20260201_093744_introspection.md\n.hot_ralph/20260201_093939_plan_mode.toon\n.hot_ralph/20260201_094421_plan_simplify.md\n.hot_ralph/state.json\nexamples/counter.zig\nexamples/list.zig\nsrc/backend.zig\nsrc/root.zig\nsrc/widgets.zig\nsrc/widgets/paragraph.zig"
  stderr: ""
  interrupted: false
  isImage: false
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01CRJfLVpMrv3mvyCN1t479S
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01QmeUiQgnzxpU2uN9Swdb8c
      name: Bash
      input:
        command: git diff HEAD~3 -- examples/counter.zig examples/list.zig src/backend.zig src/root.zig src/widgets.zig src/widgets/paragraph.zig
        description: Show detailed diff of source code changes
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 561
    cache_read_input_tokens: 23720
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 561
    output_tokens: 25
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: b81d2aab-ab1d-4b1a-a7a2-07d2e9ebee71
type: user
message:
  role: user
  content[1]{tool_use_id,type,content,is_error}:
    toolu_01QmeUiQgnzxpU2uN9Swdb8c,tool_result,"<persisted-output>\nOutput too large (30.2KB). Full output saved to: /home/hotschmoe/.claude/projects/-home-hotschmoe-zithril/1bb8dd36-e928-4d38-bca6-6793125c3cb1/tool-results/toolu_01QmeUiQgnzxpU2uN9Swdb8c.txt\n\nPreview (first 2KB):\ndiff --git a/examples/counter.zig b/examples/counter.zig\nindex ed5b801..bdc7155 100644\n--- a/examples/counter.zig\n+++ b/examples/counter.zig\n@@ -1,20 +1,81 @@\n-// Minimal counter example - placeholder for full zithril implementation\n+// Minimal counter example for zithril TUI framework\n+//\n+// Demonstrates:\n+// - Single counter value state\n+// - Key handling (q=quit, up/down=increment/decrement)\n+// - Simple view with Block and counter display\n+\n const std = @import(\"std\");\n const zithril = @import(\"zithril\");\n-const rich_zig = @import(\"rich_zig\");\n+\n+// Application state: a single counter value\n+const State = struct {\n+    count: i32 = 0,\n+};\n+\n+// Handle events and return actions\n+fn update(state: *State, event: zithril.Event) zithril.Action {\n+    switch (event) {\n+        .key => |key| {\n+            // No modifiers for these keys\n+            if (!key.modifiers.any()) {\n+                switch (key.code) {\n+                    .char => |c| {\n+                        if (c == 'q') return .quit;\n+                    },\n+                    .up => state.count +|= 1,\n+                    .down => state.count -|= 1,\n+                    else => {},\n+                }\n+            }\n+        },\n+        else => {},\n+    }\n+    return .none;\n+}\n+\n+// Render the UI\n+fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n+    const area = frame.size();\n+\n+    // Draw a block with title\n+    const block = zithril.Block{\n+        .title = \"Counter\",\n+        .border = .rounded,\n+        .border_style = zithril.Style.init().fg(.cyan),\n+    };\n+    frame.render(block, area);\n+\n+    // Get interior area for content\n+    const inner = block.inner(area);\n+    if (inner.isEmpty()) return;\n+\n+    // Format the counter value\n+    var buf: [64]u8 = undefined;\n+    const count_str = std.fmt.bufPrint(&buf, \"Count: {d}\", .{state.count}) catch \"???\";\n+\n+    // Draw counter text centered in the block\n+    const text = zithril.Text{\n...\n</persisted-output>",false
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "0e82192c-e8fb-4b78-8f9d-cffa8eba9428"
tool_use_result:
  stdout: "diff --git a/examples/counter.zig b/examples/counter.zig\nindex ed5b801..bdc7155 100644\n--- a/examples/counter.zig\n+++ b/examples/counter.zig\n@@ -1,20 +1,81 @@\n-// Minimal counter example - placeholder for full zithril implementation\n+// Minimal counter example for zithril TUI framework\n+//\n+// Demonstrates:\n+// - Single counter value state\n+// - Key handling (q=quit, up/down=increment/decrement)\n+// - Simple view with Block and counter display\n+\n const std = @import(\"std\");\n const zithril = @import(\"zithril\");\n-const rich_zig = @import(\"rich_zig\");\n+\n+// Application state: a single counter value\n+const State = struct {\n+    count: i32 = 0,\n+};\n+\n+// Handle events and return actions\n+fn update(state: *State, event: zithril.Event) zithril.Action {\n+    switch (event) {\n+        .key => |key| {\n+            // No modifiers for these keys\n+            if (!key.modifiers.any()) {\n+                switch (key.code) {\n+                    .char => |c| {\n+                        if (c == 'q') return .quit;\n+                    },\n+                    .up => state.count +|= 1,\n+                    .down => state.count -|= 1,\n+                    else => {},\n+                }\n+            }\n+        },\n+        else => {},\n+    }\n+    return .none;\n+}\n+\n+// Render the UI\n+fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n+    const area = frame.size();\n+\n+    // Draw a block with title\n+    const block = zithril.Block{\n+        .title = \"Counter\",\n+        .border = .rounded,\n+        .border_style = zithril.Style.init().fg(.cyan),\n+    };\n+    frame.render(block, area);\n+\n+    // Get interior area for content\n+    const inner = block.inner(area);\n+    if (inner.isEmpty()) return;\n+\n+    // Format the counter value\n+    var buf: [64]u8 = undefined;\n+    const count_str = std.fmt.bufPrint(&buf, \"Count: {d}\", .{state.count}) catch \"???\";\n+\n+    // Draw counter text centered in the block\n+    const text = zithril.Text{\n+        .content = count_str,\n+        .style = zithril.Style.init().bold().fg(.green),\n+        .alignment = .center,\n+    };\n+    frame.render(text, inner);\n+}\n \n pub fn main() !void {\n     var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n     defer _ = gpa.deinit();\n     const allocator = gpa.allocator();\n \n-    var console = rich_zig.Console.init(allocator);\n-    defer console.deinit();\n+    var app = zithril.App(State).init(.{\n+        .state = .{},\n+        .update = update,\n+        .view = view,\n+    });\n \n-    const style = zithril.Style.init().bold().fg(.green);\n-    const segments = [_]rich_zig.Segment{\n-        rich_zig.Segment.styled(\"Counter Example\", style.toRichStyle()),\n-    };\n-    try console.printSegments(&segments);\n-    try console.print(\"(Full TUI implementation coming soon)\");\n+    try app.run(allocator);\n }\n+\n+// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\n+pub const panic = zithril.terminal_panic;\ndiff --git a/examples/list.zig b/examples/list.zig\nindex 8e94db0..39257b9 100644\n--- a/examples/list.zig\n+++ b/examples/list.zig\n@@ -1,20 +1,123 @@\n-// List example - demonstrates a navigable list widget\n+// List example for zithril TUI framework\n+//\n+// Demonstrates:\n+// - Navigable list with items and selected index state\n+// - Key handling (q=quit, j/down=next, k/up=previous)\n+// - Selection highlight with visual feedback\n+\n const std = @import(\"std\");\n const zithril = @import(\"zithril\");\n-const rich_zig = @import(\"rich_zig\");\n+\n+// Application state: list items and selection index\n+const State = struct {\n+    items: []const []const u8,\n+    selected: usize = 0,\n+\n+    fn selectNext(self: *State) void {\n+        if (self.items.len == 0) return;\n+        if (self.selected < self.items.len - 1) {\n+            self.selected += 1;\n+        }\n+    }\n+\n+    fn selectPrev(self: *State) void {\n+        if (self.selected > 0) {\n+            self.selected -= 1;\n+        }\n+    }\n+\n+    fn selectFirst(self: *State) void {\n+        self.selected = 0;\n+    }\n+\n+    fn selectLast(self: *State) void {\n+        if (self.items.len > 0) {\n+            self.selected = self.items.len - 1;\n+        }\n+    }\n+};\n+\n+// Handle events and return actions\n+fn update(state: *State, event: zithril.Event) zithril.Action {\n+    switch (event) {\n+        .key => |key| {\n+            if (!key.modifiers.any()) {\n+                switch (key.code) {\n+                    .char => |c| switch (c) {\n+                        'q' => return .quit,\n+                        'j' => state.selectNext(),\n+                        'k' => state.selectPrev(),\n+                        'g' => state.selectFirst(),\n+                        'G' => state.selectLast(),\n+                        else => {},\n+                    },\n+                    .up => state.selectPrev(),\n+                    .down => state.selectNext(),\n+                    .home => state.selectFirst(),\n+                    .end => state.selectLast(),\n+                    else => {},\n+                }\n+            }\n+        },\n+        else => {},\n+    }\n+    return .none;\n+}\n+\n+// Render the UI\n+fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n+    const area = frame.size();\n+\n+    // Outer block with title\n+    const block = zithril.Block{\n+        .title = \"List Navigation (j/k or arrows, q to quit)\",\n+        .border = .rounded,\n+        .border_style = zithril.Style.init().fg(.cyan),\n+    };\n+    frame.render(block, area);\n+\n+    // Get interior area for the list\n+    const inner = block.inner(area);\n+    if (inner.isEmpty()) return;\n+\n+    // Render the list widget\n+    const list = zithril.List{\n+        .items = state.items,\n+        .selected = state.selected,\n+        .style = zithril.Style.init().fg(.white),\n+        .highlight_style = zithril.Style.init().bg(.blue).fg(.white).bold(),\n+        .highlight_symbol = \"> \",\n+    };\n+    frame.render(list, inner);\n+}\n \n pub fn main() !void {\n     var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n     defer _ = gpa.deinit();\n     const allocator = gpa.allocator();\n \n-    var console = rich_zig.Console.init(allocator);\n-    defer console.deinit();\n-\n-    const style = zithril.Style.init().bold().fg(.cyan);\n-    const segments = [_]rich_zig.Segment{\n-        rich_zig.Segment.styled(\"List Example\", style.toRichStyle()),\n+    // Sample items for the list\n+    const items = [_][]const u8{\n+        \"Apple\",\n+        \"Banana\",\n+        \"Cherry\",\n+        \"Date\",\n+        \"Elderberry\",\n+        \"Fig\",\n+        \"Grape\",\n+        \"Honeydew\",\n+        \"Jackfruit\",\n+        \"Kiwi\",\n     };\n-    try console.printSegments(&segments);\n-    try console.print(\"(Full TUI list implementation coming soon)\");\n+\n+    var app = zithril.App(State).init(.{\n+        .state = .{ .items = &items, .selected = 0 },\n+        .update = update,\n+        .view = view,\n+    });\n+\n+    try app.run(allocator);\n }\n+\n+// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\n+pub const panic = zithril.terminal_panic;\ndiff --git a/src/backend.zig b/src/backend.zig\nindex 271f7d4..2178ba7 100644\n--- a/src/backend.zig\n+++ b/src/backend.zig\n@@ -61,125 +61,147 @@ fn emergencyCleanup() void {\n /// Applications can use this by adding to their root source file:\n ///   pub const panic = @import(\"zithril\").backend_mod.panic;\n /// This ensures terminal state is restored before panic output is displayed.\n+///\n+/// The panic namespace matches Zig 0.15's expected interface (std.debug.no_panic).\n pub const panic = struct {\n     /// Core panic function called by @panic and runtime safety checks.\n     pub fn call(msg: []const u8, ret_addr: ?usize) noreturn {\n         @branchHint(.cold);\n+        _ = ret_addr;\n+\n         // Perform cleanup first so panic message is visible\n         emergencyCleanup();\n \n-        // Use standard panic behavior\n-        _ = ret_addr;\n-        std.debug.lockStdErr();\n-        const stderr = std.io.getStdErr();\n+        // Write error message directly to stderr fd\n+        const stderr_fd = std.posix.STDERR_FILENO;\n+        const stderr = std.fs.File{ .handle = stderr_fd };\n         stderr.writeAll(msg) catch {};\n         stderr.writeAll(\"\\n\") catch {};\n         @trap();\n     }\n \n-    pub fn sentinelMismatch(expected: anytype, found: @TypeOf(expected)) noreturn {\n-        _ = found;\n+    pub fn sentinelMismatch(_: anytype, _: anytype) noreturn {\n+        @branchHint(.cold);\n         call(\"sentinel mismatch\", null);\n     }\n \n-    pub fn unwrapError(err: anyerror) noreturn {\n-        _ = &err;\n+    pub fn unwrapError(_: anyerror) noreturn {\n+        @branchHint(.cold);\n         call(\"attempt to unwrap error\", null);\n     }\n \n-    pub fn outOfBounds(index: usize, len: usize) noreturn {\n-        _ = index;\n-        _ = len;\n+    pub fn outOfBounds(_: usize, _: usize) noreturn {\n+        @branchHint(.cold);\n         call(\"index out of bounds\", null);\n     }\n \n-    pub fn startGreaterThanEnd(start: usize, end: usize) noreturn {\n-        _ = start;\n-        _ = end;\n+    pub fn startGreaterThanEnd(_: usize, _: usize) noreturn {\n+        @branchHint(.cold);\n         call(\"start index is larger than end index\", null);\n     }\n \n-    pub fn inactiveUnionField(active: anytype, accessed: @TypeOf(active)) noreturn {\n-        _ = accessed;\n+    pub fn inactiveUnionField(_: anytype, _: anytype) noreturn {\n+        @branchHint(.cold);\n         call(\"access of inactive union field\", null);\n     }\n \n-    pub fn sliceCastLenRemainder(src_len: usize) noreturn {\n-        _ = src_len;\n+    pub fn sliceCastLenRemainder(_: usize) noreturn {\n+        @branchHint(.cold);\n         call(\"slice cast has len remainder\", null);\n     }\n \n-    pub fn castToNull(value: anytype) noreturn {\n-        _ = value;\n-        call(\"cast to null\", null);\n-    }\n-\n     pub fn reachedUnreachable() noreturn {\n+        @branchHint(.cold);\n         call(\"reached unreachable code\", null);\n     }\n \n     pub fn unwrapNull() noreturn {\n+        @branchHint(.cold);\n         call(\"unwrap of null optional\", null);\n     }\n \n-    pub fn signedOverflow(a: anytype, b: anytype) noreturn {\n-        _ = a;\n-        _ = b;\n-        call(\"signed integer overflow\", null);\n+    pub fn castToNull() noreturn {\n+        @branchHint(.cold);\n+        call(\"cast to null\", null);\n     }\n \n-    pub fn unsignedOverflow(a: anytype, b: anytype) noreturn {\n-        _ = a;\n-        _ = b;\n-        call(\"unsigned integer overflow\", null);\n+    pub fn incorrectAlignment() noreturn {\n+        @branchHint(.cold);\n+        call(\"incorrect alignment\", null);\n     }\n \n-    pub fn exactDivisionRemainder(numerator: anytype, denominator: anytype) noreturn {\n-        _ = numerator;\n-        _ = denominator;\n-        call(\"exact division has remainder\", null);\n+    pub fn invalidErrorCode() noreturn {\n+        @branchHint(.cold);\n+        call(\"invalid error code\", null);\n+    }\n+\n+    pub fn integerOutOfBounds() noreturn {\n+        @branchHint(.cold);\n+        call(\"integer out of bounds\", null);\n     }\n \n-    pub fn divisionByZero(numerator: anytype) noreturn {\n-        _ = numerator;\n+    pub fn integerOverflow() noreturn {\n+        @branchHint(.cold);\n+        call(\"integer overflow\", null);\n+    }\n+\n+    pub fn shlOverflow() noreturn {\n+        @branchHint(.cold);\n+        call(\"shift left overflow\", null);\n+    }\n+\n+    pub fn shrOverflow() noreturn {\n+        @branchHint(.cold);\n+        call(\"shift right overflow\", null);\n+    }\n+\n+    pub fn divideByZero() noreturn {\n+        @branchHint(.cold);\n         call(\"division by zero\", null);\n     }\n \n-    pub fn negativeShiftCount(count: anytype) noreturn {\n-        _ = count;\n-        call(\"negative shift count\", null);\n+    pub fn exactDivisionRemainder() noreturn {\n+        @branchHint(.cold);\n+        call(\"exact division has remainder\", null);\n+    }\n+\n+    pub fn integerPartOutOfBounds() noreturn {\n+        @branchHint(.cold);\n+        call(\"integer part out of bounds\", null);\n     }\n \n-    pub fn shiftOverflow(a: anytype, b: anytype) noreturn {\n-        _ = a;\n-        _ = b;\n-        call(\"shift overflow\", null);\n+    pub fn corruptSwitch() noreturn {\n+        @branchHint(.cold);\n+        call(\"corrupt switch\", null);\n     }\n \n-    pub fn memcpyDestOverlap() noreturn {\n-        call(\"memcpy dest overlaps src\", null);\n+    pub fn shiftRhsTooBig() noreturn {\n+        @branchHint(.cold);\n+        call(\"shift rhs too big\", null);\n     }\n \n-    pub fn intToEnumOverflow() noreturn {\n-        call(\"int to enum overflow\", null);\n+    pub fn invalidEnumValue() noreturn {\n+        @branchHint(.cold);\n+        call(\"invalid enum value\", null);\n     }\n \n-    pub fn intToFloatOverflow(value: anytype) noreturn {\n-        _ = value;\n-        call(\"int to float overflow\", null);\n+    pub fn forLenMismatch() noreturn {\n+        @branchHint(.cold);\n+        call(\"for loop length mismatch\", null);\n     }\n \n-    pub fn floatToIntOverflow(value: anytype) noreturn {\n-        _ = value;\n-        call(\"float to int overflow\", null);\n+    pub fn copyLenMismatch() noreturn {\n+        @branchHint(.cold);\n+        call(\"copy length mismatch\", null);\n     }\n \n-    pub fn invalidEnumCast(value: anytype) noreturn {\n-        _ = value;\n-        call(\"invalid enum cast\", null);\n+    pub fn memcpyAlias() noreturn {\n+        @branchHint(.cold);\n+        call(\"memcpy with overlapping memory\", null);\n     }\n \n-    pub fn noReturn() noreturn {\n+    pub fn noreturnReturned() noreturn {\n+        @branchHint(.cold);\n         call(\"noreturn function returned\", null);\n     }\n };\ndiff --git a/src/root.zig b/src/root.zig\nindex 5823d8c..56788ef 100644\n--- a/src/root.zig\n+++ b/src/root.zig\n@@ -93,6 +93,8 @@ pub const BorderChars = widgets.BorderChars;\n pub const Text = widgets.Text;\n pub const List = widgets.List;\n pub const Gauge = widgets.Gauge;\n+pub const Paragraph = widgets.Paragraph;\n+pub const Wrap = widgets.Wrap;\n pub const Alignment = widgets.Alignment;\n \n test \"style wrapper\" {\ndiff --git a/src/widgets.zig b/src/widgets.zig\nindex 64bb16c..ea926e2 100644\n--- a/src/widgets.zig\n+++ b/src/widgets.zig\n@@ -16,9 +16,14 @@ pub const List = list.List;\n pub const gauge = @import(\"widgets/gauge.zig\");\n pub const Gauge = gauge.Gauge;\n \n+pub const paragraph = @import(\"widgets/paragraph.zig\");\n+pub const Paragraph = paragraph.Paragraph;\n+pub const Wrap = paragraph.Wrap;\n+\n test \"widgets module\" {\n     _ = block;\n     _ = text;\n     _ = list;\n     _ = gauge;\n+    _ = paragraph;\n }\ndiff --git a/src/widgets/paragraph.zig b/src/widgets/paragraph.zig\nnew file mode 100644\nindex 0000000..a147499\n--- /dev/null\n+++ b/src/widgets/paragraph.zig\n@@ -0,0 +1,452 @@\n+// Paragraph widget for zithril TUI framework\n+// Multi-line text with wrapping and alignment\n+\n+const std = @import(\"std\");\n+const buffer_mod = @import(\"../buffer.zig\");\n+const geometry = @import(\"../geometry.zig\");\n+const style_mod = @import(\"../style.zig\");\n+\n+pub const Buffer = buffer_mod.Buffer;\n+pub const Rect = geometry.Rect;\n+pub const Style = style_mod.Style;\n+\n+/// Text wrapping modes\n+pub const Wrap = enum {\n+    /// No wrapping, clip at boundary\n+    none,\n+    /// Wrap at any character position\n+    char,\n+    /// Wrap at word boundaries (spaces)\n+    word,\n+};\n+\n+/// Text alignment options\n+pub const Alignment = enum {\n+    left,\n+    center,\n+    right,\n+};\n+\n+/// Multi-line text widget with optional wrapping.\n+///\n+/// Renders text content across multiple lines with configurable wrapping\n+/// behavior and alignment. Lines beyond the area height are not rendered.\n+pub const Paragraph = struct {\n+    /// The text content to display\n+    text: []const u8,\n+\n+    /// Style applied to the text\n+    style: Style = Style.empty,\n+\n+    /// Text wrapping mode\n+    wrap: Wrap = .none,\n+\n+    /// Text alignment within each line\n+    alignment: Alignment = .left,\n+\n+    /// Render the paragraph into the buffer at the given area.\n+    /// Text is split into lines (either by newlines or wrapping) and rendered\n+    /// until the area height is filled.\n+    pub fn render(self: Paragraph, area: Rect, buf: *Buffer) void {\n+        if (area.isEmpty()) return;\n+        if (self.text.len == 0) return;\n+\n+        var y = area.y;\n+        const max_y = area.bottom();\n+\n+        // Process text line by line (split by newlines first)\n+        var line_iter = std.mem.splitScalar(u8, self.text, '\\n');\n+        while (line_iter.next()) |logical_line| {\n+            if (y >= max_y) break;\n+\n+            // Apply wrapping to this logical line\n+            switch (self.wrap) {\n+                .none => {\n+                    self.renderLine(logical_line, area.x, y, area.width, buf);\n+                    y += 1;\n+                },\n+                .char => {\n+                    var remaining = logical_line;\n+                    while (remaining.len > 0 and y < max_y) {\n+                        const chunk_len = @min(remaining.len, area.width);\n+                        const chunk = remaining[0..chunk_len];\n+                        self.renderLine(chunk, area.x, y, area.width, buf);\n+                        remaining = remaining[chunk_len..];\n+                        y += 1;\n+                    }\n+                    // Empty line should still take a row\n+                    if (logical_line.len == 0) {\n+                        y += 1;\n+                    }\n+                },\n+                .word => {\n+                    if (logical_line.len == 0) {\n+                        y += 1;\n+                        continue;\n+                    }\n+                    var line_start: usize = 0;\n+                    while (line_start < logical_line.len and y < max_y) {\n+                        const wrap_end = findWordWrapEnd(logical_line[line_start..], area.width);\n+                        const line = logical_line[line_start .. line_start + wrap_end];\n+                        self.renderLine(line, area.x, y, area.width, buf);\n+                        line_start += wrap_end;\n+                        // Skip leading spaces on next line\n+                        while (line_start < logical_line.len and logical_line[line_start] == ' ') {\n+                            line_start += 1;\n+                        }\n+                        y += 1;\n+                    }\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Render a single line of text with alignment\n+    fn renderLine(self: Paragraph, line: []const u8, x: u16, y: u16, width: u16, buf: *Buffer) void {\n+        if (line.len == 0) return;\n+\n+        const text_len = textDisplayWidth(line);\n+        const visible_len = @min(text_len, width);\n+\n+        if (visible_len == 0) return;\n+\n+        const x_offset: u16 = switch (self.alignment) {\n+            .left => 0,\n+            .center => (width -| visible_len) / 2,\n+            .right => width -| visible_len,\n+        };\n+\n+        buf.setString(x +| x_offset, y, line, self.style);\n+    }\n+};\n+\n+/// Find the end index for word wrapping within a max width.\n+/// Returns the number of characters to include on this line.\n+fn findWordWrapEnd(text: []const u8, max_width: u16) usize {\n+    if (text.len == 0) return 0;\n+\n+    const width: usize = @intCast(max_width);\n+    if (text.len <= width) return text.len;\n+\n+    // Find the last space within the width limit\n+    var last_space: ?usize = null;\n+    for (0..width) |i| {\n+        if (text[i] == ' ') {\n+            last_space = i;\n+        }\n+    }\n+\n+    // If we found a space, wrap there (include the space in this line)\n+    if (last_space) |space_pos| {\n+        // Return position including the space, so next line starts after it\n+        return space_pos + 1;\n+    }\n+\n+    // No space found - break at max width (hard wrap)\n+    return width;\n+}\n+\n+/// Calculate the display width of a string (counting grapheme columns).\n+/// Simple implementation: counts codepoints, treating wide chars as width 2.\n+fn textDisplayWidth(str: []const u8) u16 {\n+    var width: u16 = 0;\n+    var iter = std.unicode.Utf8View.initUnchecked(str).iterator();\n+    while (iter.nextCodepoint()) |cp| {\n+        width +|= if (isWideCodepoint(cp)) 2 else 1;\n+    }\n+    return width;\n+}\n+\n+/// Check if a codepoint is a wide character (CJK, etc.)\n+fn isWideCodepoint(cp: u21) bool {\n+    return (cp >= 0x4E00 and cp <= 0x9FFF) or // CJK Unified Ideographs\n+        (cp >= 0x3400 and cp <= 0x4DBF) or // CJK Extension A\n+        (cp >= 0x20000 and cp <= 0x2A6DF) or // CJK Extension B\n+        (cp >= 0xF900 and cp <= 0xFAFF) or // CJK Compatibility\n+        (cp >= 0xFF00 and cp <= 0xFF60) or // Fullwidth forms\n+        (cp >= 0xFFE0 and cp <= 0xFFE6) or // Fullwidth symbols\n+        (cp >= 0x3000 and cp <= 0x303F) or // CJK Punctuation\n+        (cp >= 0x1100 and cp <= 0x11FF); // Hangul Jamo\n+}\n+\n+// ============================================================\n+// SANITY TESTS - Basic Paragraph functionality\n+// ============================================================\n+\n+test \"sanity: Paragraph with default values\" {\n+    const para = Paragraph{ .text = \"Hello\\nWorld\" };\n+    try std.testing.expectEqualStrings(\"Hello\\nWorld\", para.text);\n+    try std.testing.expect(para.style.isEmpty());\n+    try std.testing.expect(para.wrap == .none);\n+    try std.testing.expect(para.alignment == .left);\n+}\n+\n+test \"sanity: Paragraph with custom style\" {\n+    const para = Paragraph{\n+        .text = \"Styled\",\n+        .style = Style.init().bold().fg(.red),\n+    };\n+    try std.testing.expect(para.style.hasAttribute(.bold));\n+}\n+\n+test \"sanity: Paragraph with wrap modes\" {\n+    const none_wrap = Paragraph{ .text = \"T\", .wrap = .none };\n+    const char_wrap = Paragraph{ .text = \"T\", .wrap = .char };\n+    const word_wrap = Paragraph{ .text = \"T\", .wrap = .word };\n+\n+    try std.testing.expect(none_wrap.wrap == .none);\n+    try std.testing.expect(char_wrap.wrap == .char);\n+    try std.testing.expect(word_wrap.wrap == .word);\n+}\n+\n+test \"sanity: Paragraph with alignment\" {\n+    const left = Paragraph{ .text = \"L\", .alignment = .left };\n+    const center = Paragraph{ .text = \"C\", .alignment = .center };\n+    const right = Paragraph{ .text = \"R\", .alignment = .right };\n+\n+    try std.testing.expect(left.alignment == .left);\n+    try std.testing.expect(center.alignment == .center);\n+    try std.testing.expect(right.alignment == .right);\n+}\n+\n+// ============================================================\n+// BEHAVIOR TESTS - Rendering\n+// ============================================================\n+\n+test \"behavior: Paragraph renders single line\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Hello\" };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'e'), buf.get(1, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'l'), buf.get(2, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'l'), buf.get(3, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n+}\n+\n+test \"behavior: Paragraph renders multiple lines with newlines\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\" };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n+    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 2).char);\n+    try std.testing.expectEqual(@as(u21, '3'), buf.get(4, 2).char);\n+}\n+\n+test \"behavior: Paragraph with char wrap\" {\n+    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"ABCDEFGHIJKLMNOP\",\n+        .wrap = .char,\n+    };\n+    para.render(Rect.init(0, 0, 10, 5), &buf);\n+\n+    // First 10 chars on row 0\n+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'J'), buf.get(9, 0).char);\n+    // Next 6 chars on row 1\n+    try std.testing.expectEqual(@as(u21, 'K'), buf.get(0, 1).char);\n+    try std.testing.expectEqual(@as(u21, 'P'), buf.get(5, 1).char);\n+}\n+\n+test \"behavior: Paragraph with word wrap\" {\n+    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"Hello World Today\",\n+        .wrap = .word,\n+    };\n+    para.render(Rect.init(0, 0, 10, 5), &buf);\n+\n+    // \"Hello \" should be on row 0\n+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n+    // \"World \" should be on row 1\n+    try std.testing.expectEqual(@as(u21, 'W'), buf.get(0, 1).char);\n+    try std.testing.expectEqual(@as(u21, 'd'), buf.get(4, 1).char);\n+    // \"Today\" should be on row 2\n+    try std.testing.expectEqual(@as(u21, 'T'), buf.get(0, 2).char);\n+}\n+\n+test \"behavior: Paragraph center alignment\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"Hi\",\n+        .alignment = .center,\n+    };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    // \"Hi\" (2 chars) centered in 20 = offset 9\n+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(9, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'i'), buf.get(10, 0).char);\n+}\n+\n+test \"behavior: Paragraph right alignment\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"End\",\n+        .alignment = .right,\n+    };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    // \"End\" (3 chars) right-aligned in 20 = starts at 17\n+    try std.testing.expectEqual(@as(u21, 'E'), buf.get(17, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'd'), buf.get(19, 0).char);\n+}\n+\n+test \"behavior: Paragraph applies style\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"Bold\",\n+        .style = Style.init().bold(),\n+    };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    try std.testing.expect(buf.get(0, 0).style.hasAttribute(.bold));\n+    try std.testing.expect(buf.get(1, 0).style.hasAttribute(.bold));\n+}\n+\n+test \"behavior: Paragraph renders at area offset\" {\n+    var buf = try Buffer.init(std.testing.allocator, 30, 10);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Offset\\nTest\" };\n+    para.render(Rect.init(5, 3, 10, 5), &buf);\n+\n+    try std.testing.expectEqual(@as(u21, 'O'), buf.get(5, 3).char);\n+    try std.testing.expectEqual(@as(u21, 'T'), buf.get(5, 4).char);\n+}\n+\n+// ============================================================\n+// REGRESSION TESTS - Edge cases\n+// ============================================================\n+\n+test \"regression: Paragraph handles empty area\" {\n+    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Test\" };\n+    para.render(Rect.init(0, 0, 0, 0), &buf);\n+\n+    // Buffer should be unchanged\n+    for (buf.cells) |cell| {\n+        try std.testing.expect(cell.isDefault());\n+    }\n+}\n+\n+test \"regression: Paragraph handles empty text\" {\n+    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"\" };\n+    para.render(Rect.init(0, 0, 10, 5), &buf);\n+\n+    // Buffer should be unchanged\n+    for (buf.cells) |cell| {\n+        try std.testing.expect(cell.isDefault());\n+    }\n+}\n+\n+test \"regression: Paragraph clips lines beyond height\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 2);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\\nLine4\" };\n+    para.render(Rect.init(0, 0, 20, 2), &buf);\n+\n+    // Only first 2 lines should be rendered\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n+    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n+}\n+\n+test \"regression: Paragraph word wrap handles long words\" {\n+    var buf = try Buffer.init(std.testing.allocator, 5, 5);\n+    defer buf.deinit();\n+\n+    // Word longer than width - should hard wrap\n+    const para = Paragraph{\n+        .text = \"ABCDEFGH\",\n+        .wrap = .word,\n+    };\n+    para.render(Rect.init(0, 0, 5, 5), &buf);\n+\n+    // Should hard wrap at width since no spaces\n+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'E'), buf.get(4, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'F'), buf.get(0, 1).char);\n+}\n+\n+test \"regression: Paragraph handles trailing newline\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Line1\\n\" };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n+}\n+\n+test \"regression: Paragraph handles consecutive newlines\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"A\\n\\nB\" };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    // A on row 0, empty row 1, B on row 2\n+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'B'), buf.get(0, 2).char);\n+}\n+\n+test \"regression: findWordWrapEnd handles empty text\" {\n+    const result = findWordWrapEnd(\"\", 10);\n+    try std.testing.expectEqual(@as(usize, 0), result);\n+}\n+\n+test \"regression: findWordWrapEnd handles short text\" {\n+    const result = findWordWrapEnd(\"Hi\", 10);\n+    try std.testing.expectEqual(@as(usize, 2), result);\n+}\n+\n+test \"regression: findWordWrapEnd breaks at space\" {\n+    const result = findWordWrapEnd(\"Hello World\", 7);\n+    // Should break after \"Hello \" (6 chars including space)\n+    try std.testing.expectEqual(@as(usize, 6), result);\n+}\n+\n+test \"regression: findWordWrapEnd hard breaks long word\" {\n+    const result = findWordWrapEnd(\"Supercalifragilistic\", 5);\n+    // No space found, hard break at width\n+    try std.testing.expectEqual(@as(usize, 5), result);\n+}\n+\n+test \"regression: textDisplayWidth handles ASCII\" {\n+    const w = textDisplayWidth(\"Hello\");\n+    try std.testing.expectEqual(@as(u16, 5), w);\n+}\n+\n+test \"regression: textDisplayWidth handles wide chars\" {\n+    const w = textDisplayWidth(\"\\u{4E2D}\");\n+    try std.testing.expectEqual(@as(u16, 2), w);\n+}"
  stderr: ""
  interrupted: false
  isImage: false
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01PCw8adbhW2EPdnTj1Xk4vn
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01Eot76dZjSheo1wPSmZeWCA
      name: Read
      input:
        file_path: /home/hotschmoe/.claude/projects/-home-hotschmoe-zithril/1bb8dd36-e928-4d38-bca6-6793125c3cb1/tool-results/toolu_01QmeUiQgnzxpU2uN9Swdb8c.txt
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 902
    cache_read_input_tokens: 24281
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 902
    output_tokens: 18
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "22cc216f-21e3-45e3-b59d-d97238325b52"
type: user
message:
  role: user
  content[1]{tool_use_id,type,content}:
    toolu_01Eot76dZjSheo1wPSmZeWCA,tool_result,"     1→diff --git a/examples/counter.zig b/examples/counter.zig\n     2→index ed5b801..bdc7155 100644\n     3→--- a/examples/counter.zig\n     4→+++ b/examples/counter.zig\n     5→@@ -1,20 +1,81 @@\n     6→-// Minimal counter example - placeholder for full zithril implementation\n     7→+// Minimal counter example for zithril TUI framework\n     8→+//\n     9→+// Demonstrates:\n    10→+// - Single counter value state\n    11→+// - Key handling (q=quit, up/down=increment/decrement)\n    12→+// - Simple view with Block and counter display\n    13→+\n    14→ const std = @import(\"std\");\n    15→ const zithril = @import(\"zithril\");\n    16→-const rich_zig = @import(\"rich_zig\");\n    17→+\n    18→+// Application state: a single counter value\n    19→+const State = struct {\n    20→+    count: i32 = 0,\n    21→+};\n    22→+\n    23→+// Handle events and return actions\n    24→+fn update(state: *State, event: zithril.Event) zithril.Action {\n    25→+    switch (event) {\n    26→+        .key => |key| {\n    27→+            // No modifiers for these keys\n    28→+            if (!key.modifiers.any()) {\n    29→+                switch (key.code) {\n    30→+                    .char => |c| {\n    31→+                        if (c == 'q') return .quit;\n    32→+                    },\n    33→+                    .up => state.count +|= 1,\n    34→+                    .down => state.count -|= 1,\n    35→+                    else => {},\n    36→+                }\n    37→+            }\n    38→+        },\n    39→+        else => {},\n    40→+    }\n    41→+    return .none;\n    42→+}\n    43→+\n    44→+// Render the UI\n    45→+fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n    46→+    const area = frame.size();\n    47→+\n    48→+    // Draw a block with title\n    49→+    const block = zithril.Block{\n    50→+        .title = \"Counter\",\n    51→+        .border = .rounded,\n    52→+        .border_style = zithril.Style.init().fg(.cyan),\n    53→+    };\n    54→+    frame.render(block, area);\n    55→+\n    56→+    // Get interior area for content\n    57→+    const inner = block.inner(area);\n    58→+    if (inner.isEmpty()) return;\n    59→+\n    60→+    // Format the counter value\n    61→+    var buf: [64]u8 = undefined;\n    62→+    const count_str = std.fmt.bufPrint(&buf, \"Count: {d}\", .{state.count}) catch \"???\";\n    63→+\n    64→+    // Draw counter text centered in the block\n    65→+    const text = zithril.Text{\n    66→+        .content = count_str,\n    67→+        .style = zithril.Style.init().bold().fg(.green),\n    68→+        .alignment = .center,\n    69→+    };\n    70→+    frame.render(text, inner);\n    71→+}\n    72→ \n    73→ pub fn main() !void {\n    74→     var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    75→     defer _ = gpa.deinit();\n    76→     const allocator = gpa.allocator();\n    77→ \n    78→-    var console = rich_zig.Console.init(allocator);\n    79→-    defer console.deinit();\n    80→+    var app = zithril.App(State).init(.{\n    81→+        .state = .{},\n    82→+        .update = update,\n    83→+        .view = view,\n    84→+    });\n    85→ \n    86→-    const style = zithril.Style.init().bold().fg(.green);\n    87→-    const segments = [_]rich_zig.Segment{\n    88→-        rich_zig.Segment.styled(\"Counter Example\", style.toRichStyle()),\n    89→-    };\n    90→-    try console.printSegments(&segments);\n    91→-    try console.print(\"(Full TUI implementation coming soon)\");\n    92→+    try app.run(allocator);\n    93→ }\n    94→+\n    95→+// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\n    96→+pub const panic = zithril.terminal_panic;\n    97→diff --git a/examples/list.zig b/examples/list.zig\n    98→index 8e94db0..39257b9 100644\n    99→--- a/examples/list.zig\n   100→+++ b/examples/list.zig\n   101→@@ -1,20 +1,123 @@\n   102→-// List example - demonstrates a navigable list widget\n   103→+// List example for zithril TUI framework\n   104→+//\n   105→+// Demonstrates:\n   106→+// - Navigable list with items and selected index state\n   107→+// - Key handling (q=quit, j/down=next, k/up=previous)\n   108→+// - Selection highlight with visual feedback\n   109→+\n   110→ const std = @import(\"std\");\n   111→ const zithril = @import(\"zithril\");\n   112→-const rich_zig = @import(\"rich_zig\");\n   113→+\n   114→+// Application state: list items and selection index\n   115→+const State = struct {\n   116→+    items: []const []const u8,\n   117→+    selected: usize = 0,\n   118→+\n   119→+    fn selectNext(self: *State) void {\n   120→+        if (self.items.len == 0) return;\n   121→+        if (self.selected < self.items.len - 1) {\n   122→+            self.selected += 1;\n   123→+        }\n   124→+    }\n   125→+\n   126→+    fn selectPrev(self: *State) void {\n   127→+        if (self.selected > 0) {\n   128→+            self.selected -= 1;\n   129→+        }\n   130→+    }\n   131→+\n   132→+    fn selectFirst(self: *State) void {\n   133→+        self.selected = 0;\n   134→+    }\n   135→+\n   136→+    fn selectLast(self: *State) void {\n   137→+        if (self.items.len > 0) {\n   138→+            self.selected = self.items.len - 1;\n   139→+        }\n   140→+    }\n   141→+};\n   142→+\n   143→+// Handle events and return actions\n   144→+fn update(state: *State, event: zithril.Event) zithril.Action {\n   145→+    switch (event) {\n   146→+        .key => |key| {\n   147→+            if (!key.modifiers.any()) {\n   148→+                switch (key.code) {\n   149→+                    .char => |c| switch (c) {\n   150→+                        'q' => return .quit,\n   151→+                        'j' => state.selectNext(),\n   152→+                        'k' => state.selectPrev(),\n   153→+                        'g' => state.selectFirst(),\n   154→+                        'G' => state.selectLast(),\n   155→+                        else => {},\n   156→+                    },\n   157→+                    .up => state.selectPrev(),\n   158→+                    .down => state.selectNext(),\n   159→+                    .home => state.selectFirst(),\n   160→+                    .end => state.selectLast(),\n   161→+                    else => {},\n   162→+                }\n   163→+            }\n   164→+        },\n   165→+        else => {},\n   166→+    }\n   167→+    return .none;\n   168→+}\n   169→+\n   170→+// Render the UI\n   171→+fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n   172→+    const area = frame.size();\n   173→+\n   174→+    // Outer block with title\n   175→+    const block = zithril.Block{\n   176→+        .title = \"List Navigation (j/k or arrows, q to quit)\",\n   177→+        .border = .rounded,\n   178→+        .border_style = zithril.Style.init().fg(.cyan),\n   179→+    };\n   180→+    frame.render(block, area);\n   181→+\n   182→+    // Get interior area for the list\n   183→+    const inner = block.inner(area);\n   184→+    if (inner.isEmpty()) return;\n   185→+\n   186→+    // Render the list widget\n   187→+    const list = zithril.List{\n   188→+        .items = state.items,\n   189→+        .selected = state.selected,\n   190→+        .style = zithril.Style.init().fg(.white),\n   191→+        .highlight_style = zithril.Style.init().bg(.blue).fg(.white).bold(),\n   192→+        .highlight_symbol = \"> \",\n   193→+    };\n   194→+    frame.render(list, inner);\n   195→+}\n   196→ \n   197→ pub fn main() !void {\n   198→     var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n   199→     defer _ = gpa.deinit();\n   200→     const allocator = gpa.allocator();\n   201→ \n   202→-    var console = rich_zig.Console.init(allocator);\n   203→-    defer console.deinit();\n   204→-\n   205→-    const style = zithril.Style.init().bold().fg(.cyan);\n   206→-    const segments = [_]rich_zig.Segment{\n   207→-        rich_zig.Segment.styled(\"List Example\", style.toRichStyle()),\n   208→+    // Sample items for the list\n   209→+    const items = [_][]const u8{\n   210→+        \"Apple\",\n   211→+        \"Banana\",\n   212→+        \"Cherry\",\n   213→+        \"Date\",\n   214→+        \"Elderberry\",\n   215→+        \"Fig\",\n   216→+        \"Grape\",\n   217→+        \"Honeydew\",\n   218→+        \"Jackfruit\",\n   219→+        \"Kiwi\",\n   220→     };\n   221→-    try console.printSegments(&segments);\n   222→-    try console.print(\"(Full TUI list implementation coming soon)\");\n   223→+\n   224→+    var app = zithril.App(State).init(.{\n   225→+        .state = .{ .items = &items, .selected = 0 },\n   226→+        .update = update,\n   227→+        .view = view,\n   228→+    });\n   229→+\n   230→+    try app.run(allocator);\n   231→ }\n   232→+\n   233→+// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\n   234→+pub const panic = zithril.terminal_panic;\n   235→diff --git a/src/backend.zig b/src/backend.zig\n   236→index 271f7d4..2178ba7 100644\n   237→--- a/src/backend.zig\n   238→+++ b/src/backend.zig\n   239→@@ -61,125 +61,147 @@ fn emergencyCleanup() void {\n   240→ /// Applications can use this by adding to their root source file:\n   241→ ///   pub const panic = @import(\"zithril\").backend_mod.panic;\n   242→ /// This ensures terminal state is restored before panic output is displayed.\n   243→+///\n   244→+/// The panic namespace matches Zig 0.15's expected interface (std.debug.no_panic).\n   245→ pub const panic = struct {\n   246→     /// Core panic function called by @panic and runtime safety checks.\n   247→     pub fn call(msg: []const u8, ret_addr: ?usize) noreturn {\n   248→         @branchHint(.cold);\n   249→+        _ = ret_addr;\n   250→+\n   251→         // Perform cleanup first so panic message is visible\n   252→         emergencyCleanup();\n   253→ \n   254→-        // Use standard panic behavior\n   255→-        _ = ret_addr;\n   256→-        std.debug.lockStdErr();\n   257→-        const stderr = std.io.getStdErr();\n   258→+        // Write error message directly to stderr fd\n   259→+        const stderr_fd = std.posix.STDERR_FILENO;\n   260→+        const stderr = std.fs.File{ .handle = stderr_fd };\n   261→         stderr.writeAll(msg) catch {};\n   262→         stderr.writeAll(\"\\n\") catch {};\n   263→         @trap();\n   264→     }\n   265→ \n   266→-    pub fn sentinelMismatch(expected: anytype, found: @TypeOf(expected)) noreturn {\n   267→-        _ = found;\n   268→+    pub fn sentinelMismatch(_: anytype, _: anytype) noreturn {\n   269→+        @branchHint(.cold);\n   270→         call(\"sentinel mismatch\", null);\n   271→     }\n   272→ \n   273→-    pub fn unwrapError(err: anyerror) noreturn {\n   274→-        _ = &err;\n   275→+    pub fn unwrapError(_: anyerror) noreturn {\n   276→+        @branchHint(.cold);\n   277→         call(\"attempt to unwrap error\", null);\n   278→     }\n   279→ \n   280→-    pub fn outOfBounds(index: usize, len: usize) noreturn {\n   281→-        _ = index;\n   282→-        _ = len;\n   283→+    pub fn outOfBounds(_: usize, _: usize) noreturn {\n   284→+        @branchHint(.cold);\n   285→         call(\"index out of bounds\", null);\n   286→     }\n   287→ \n   288→-    pub fn startGreaterThanEnd(start: usize, end: usize) noreturn {\n   289→-        _ = start;\n   290→-        _ = end;\n   291→+    pub fn startGreaterThanEnd(_: usize, _: usize) noreturn {\n   292→+        @branchHint(.cold);\n   293→         call(\"start index is larger than end index\", null);\n   294→     }\n   295→ \n   296→-    pub fn inactiveUnionField(active: anytype, accessed: @TypeOf(active)) noreturn {\n   297→-        _ = accessed;\n   298→+    pub fn inactiveUnionField(_: anytype, _: anytype) noreturn {\n   299→+        @branchHint(.cold);\n   300→         call(\"access of inactive union field\", null);\n   301→     }\n   302→ \n   303→-    pub fn sliceCastLenRemainder(src_len: usize) noreturn {\n   304→-        _ = src_len;\n   305→+    pub fn sliceCastLenRemainder(_: usize) noreturn {\n   306→+        @branchHint(.cold);\n   307→         call(\"slice cast has len remainder\", null);\n   308→     }\n   309→ \n   310→-    pub fn castToNull(value: anytype) noreturn {\n   311→-        _ = value;\n   312→-        call(\"cast to null\", null);\n   313→-    }\n   314→-\n   315→     pub fn reachedUnreachable() noreturn {\n   316→+        @branchHint(.cold);\n   317→         call(\"reached unreachable code\", null);\n   318→     }\n   319→ \n   320→     pub fn unwrapNull() noreturn {\n   321→+        @branchHint(.cold);\n   322→         call(\"unwrap of null optional\", null);\n   323→     }\n   324→ \n   325→-    pub fn signedOverflow(a: anytype, b: anytype) noreturn {\n   326→-        _ = a;\n   327→-        _ = b;\n   328→-        call(\"signed integer overflow\", null);\n   329→+    pub fn castToNull() noreturn {\n   330→+        @branchHint(.cold);\n   331→+        call(\"cast to null\", null);\n   332→     }\n   333→ \n   334→-    pub fn unsignedOverflow(a: anytype, b: anytype) noreturn {\n   335→-        _ = a;\n   336→-        _ = b;\n   337→-        call(\"unsigned integer overflow\", null);\n   338→+    pub fn incorrectAlignment() noreturn {\n   339→+        @branchHint(.cold);\n   340→+        call(\"incorrect alignment\", null);\n   341→     }\n   342→ \n   343→-    pub fn exactDivisionRemainder(numerator: anytype, denominator: anytype) noreturn {\n   344→-        _ = numerator;\n   345→-        _ = denominator;\n   346→-        call(\"exact division has remainder\", null);\n   347→+    pub fn invalidErrorCode() noreturn {\n   348→+        @branchHint(.cold);\n   349→+        call(\"invalid error code\", null);\n   350→+    }\n   351→+\n   352→+    pub fn integerOutOfBounds() noreturn {\n   353→+        @branchHint(.cold);\n   354→+        call(\"integer out of bounds\", null);\n   355→     }\n   356→ \n   357→-    pub fn divisionByZero(numerator: anytype) noreturn {\n   358→-        _ = numerator;\n   359→+    pub fn integerOverflow() noreturn {\n   360→+        @branchHint(.cold);\n   361→+        call(\"integer overflow\", null);\n   362→+    }\n   363→+\n   364→+    pub fn shlOverflow() noreturn {\n   365→+        @branchHint(.cold);\n   366→+        call(\"shift left overflow\", null);\n   367→+    }\n   368→+\n   369→+    pub fn shrOverflow() noreturn {\n   370→+        @branchHint(.cold);\n   371→+        call(\"shift right overflow\", null);\n   372→+    }\n   373→+\n   374→+    pub fn divideByZero() noreturn {\n   375→+        @branchHint(.cold);\n   376→         call(\"division by zero\", null);\n   377→     }\n   378→ \n   379→-    pub fn negativeShiftCount(count: anytype) noreturn {\n   380→-        _ = count;\n   381→-        call(\"negative shift count\", null);\n   382→+    pub fn exactDivisionRemainder() noreturn {\n   383→+        @branchHint(.cold);\n   384→+        call(\"exact division has remainder\", null);\n   385→+    }\n   386→+\n   387→+    pub fn integerPartOutOfBounds() noreturn {\n   388→+        @branchHint(.cold);\n   389→+        call(\"integer part out of bounds\", null);\n   390→     }\n   391→ \n   392→-    pub fn shiftOverflow(a: anytype, b: anytype) noreturn {\n   393→-        _ = a;\n   394→-        _ = b;\n   395→-        call(\"shift overflow\", null);\n   396→+    pub fn corruptSwitch() noreturn {\n   397→+        @branchHint(.cold);\n   398→+        call(\"corrupt switch\", null);\n   399→     }\n   400→ \n   401→-    pub fn memcpyDestOverlap() noreturn {\n   402→-        call(\"memcpy dest overlaps src\", null);\n   403→+    pub fn shiftRhsTooBig() noreturn {\n   404→+        @branchHint(.cold);\n   405→+        call(\"shift rhs too big\", null);\n   406→     }\n   407→ \n   408→-    pub fn intToEnumOverflow() noreturn {\n   409→-        call(\"int to enum overflow\", null);\n   410→+    pub fn invalidEnumValue() noreturn {\n   411→+        @branchHint(.cold);\n   412→+        call(\"invalid enum value\", null);\n   413→     }\n   414→ \n   415→-    pub fn intToFloatOverflow(value: anytype) noreturn {\n   416→-        _ = value;\n   417→-        call(\"int to float overflow\", null);\n   418→+    pub fn forLenMismatch() noreturn {\n   419→+        @branchHint(.cold);\n   420→+        call(\"for loop length mismatch\", null);\n   421→     }\n   422→ \n   423→-    pub fn floatToIntOverflow(value: anytype) noreturn {\n   424→-        _ = value;\n   425→-        call(\"float to int overflow\", null);\n   426→+    pub fn copyLenMismatch() noreturn {\n   427→+        @branchHint(.cold);\n   428→+        call(\"copy length mismatch\", null);\n   429→     }\n   430→ \n   431→-    pub fn invalidEnumCast(value: anytype) noreturn {\n   432→-        _ = value;\n   433→-        call(\"invalid enum cast\", null);\n   434→+    pub fn memcpyAlias() noreturn {\n   435→+        @branchHint(.cold);\n   436→+        call(\"memcpy with overlapping memory\", null);\n   437→     }\n   438→ \n   439→-    pub fn noReturn() noreturn {\n   440→+    pub fn noreturnReturned() noreturn {\n   441→+        @branchHint(.cold);\n   442→         call(\"noreturn function returned\", null);\n   443→     }\n   444→ };\n   445→diff --git a/src/root.zig b/src/root.zig\n   446→index 5823d8c..56788ef 100644\n   447→--- a/src/root.zig\n   448→+++ b/src/root.zig\n   449→@@ -93,6 +93,8 @@ pub const BorderChars = widgets.BorderChars;\n   450→ pub const Text = widgets.Text;\n   451→ pub const List = widgets.List;\n   452→ pub const Gauge = widgets.Gauge;\n   453→+pub const Paragraph = widgets.Paragraph;\n   454→+pub const Wrap = widgets.Wrap;\n   455→ pub const Alignment = widgets.Alignment;\n   456→ \n   457→ test \"style wrapper\" {\n   458→diff --git a/src/widgets.zig b/src/widgets.zig\n   459→index 64bb16c..ea926e2 100644\n   460→--- a/src/widgets.zig\n   461→+++ b/src/widgets.zig\n   462→@@ -16,9 +16,14 @@ pub const List = list.List;\n   463→ pub const gauge = @import(\"widgets/gauge.zig\");\n   464→ pub const Gauge = gauge.Gauge;\n   465→ \n   466→+pub const paragraph = @import(\"widgets/paragraph.zig\");\n   467→+pub const Paragraph = paragraph.Paragraph;\n   468→+pub const Wrap = paragraph.Wrap;\n   469→+\n   470→ test \"widgets module\" {\n   471→     _ = block;\n   472→     _ = text;\n   473→     _ = list;\n   474→     _ = gauge;\n   475→+    _ = paragraph;\n   476→ }\n   477→diff --git a/src/widgets/paragraph.zig b/src/widgets/paragraph.zig\n   478→new file mode 100644\n   479→index 0000000..a147499\n   480→--- /dev/null\n   481→+++ b/src/widgets/paragraph.zig\n   482→@@ -0,0 +1,452 @@\n   483→+// Paragraph widget for zithril TUI framework\n   484→+// Multi-line text with wrapping and alignment\n   485→+\n   486→+const std = @import(\"std\");\n   487→+const buffer_mod = @import(\"../buffer.zig\");\n   488→+const geometry = @import(\"../geometry.zig\");\n   489→+const style_mod = @import(\"../style.zig\");\n   490→+\n   491→+pub const Buffer = buffer_mod.Buffer;\n   492→+pub const Rect = geometry.Rect;\n   493→+pub const Style = style_mod.Style;\n   494→+\n   495→+/// Text wrapping modes\n   496→+pub const Wrap = enum {\n   497→+    /// No wrapping, clip at boundary\n   498→+    none,\n   499→+    /// Wrap at any character position\n   500→+    char,\n   501→+    /// Wrap at word boundaries (spaces)\n   502→+    word,\n   503→+};\n   504→+\n   505→+/// Text alignment options\n   506→+pub const Alignment = enum {\n   507→+    left,\n   508→+    center,\n   509→+    right,\n   510→+};\n   511→+\n   512→+/// Multi-line text widget with optional wrapping.\n   513→+///\n   514→+/// Renders text content across multiple lines with configurable wrapping\n   515→+/// behavior and alignment. Lines beyond the area height are not rendered.\n   516→+pub const Paragraph = struct {\n   517→+    /// The text content to display\n   518→+    text: []const u8,\n   519→+\n   520→+    /// Style applied to the text\n   521→+    style: Style = Style.empty,\n   522→+\n   523→+    /// Text wrapping mode\n   524→+    wrap: Wrap = .none,\n   525→+\n   526→+    /// Text alignment within each line\n   527→+    alignment: Alignment = .left,\n   528→+\n   529→+    /// Render the paragraph into the buffer at the given area.\n   530→+    /// Text is split into lines (either by newlines or wrapping) and rendered\n   531→+    /// until the area height is filled.\n   532→+    pub fn render(self: Paragraph, area: Rect, buf: *Buffer) void {\n   533→+        if (area.isEmpty()) return;\n   534→+        if (self.text.len == 0) return;\n   535→+\n   536→+        var y = area.y;\n   537→+        const max_y = area.bottom();\n   538→+\n   539→+        // Process text line by line (split by newlines first)\n   540→+        var line_iter = std.mem.splitScalar(u8, self.text, '\\n');\n   541→+        while (line_iter.next()) |logical_line| {\n   542→+            if (y >= max_y) break;\n   543→+\n   544→+            // Apply wrapping to this logical line\n   545→+            switch (self.wrap) {\n   546→+                .none => {\n   547→+                    self.renderLine(logical_line, area.x, y, area.width, buf);\n   548→+                    y += 1;\n   549→+                },\n   550→+                .char => {\n   551→+                    var remaining = logical_line;\n   552→+                    while (remaining.len > 0 and y < max_y) {\n   553→+                        const chunk_len = @min(remaining.len, area.width);\n   554→+                        const chunk = remaining[0..chunk_len];\n   555→+                        self.renderLine(chunk, area.x, y, area.width, buf);\n   556→+                        remaining = remaining[chunk_len..];\n   557→+                        y += 1;\n   558→+                    }\n   559→+                    // Empty line should still take a row\n   560→+                    if (logical_line.len == 0) {\n   561→+                        y += 1;\n   562→+                    }\n   563→+                },\n   564→+                .word => {\n   565→+                    if (logical_line.len == 0) {\n   566→+                        y += 1;\n   567→+                        continue;\n   568→+                    }\n   569→+                    var line_start: usize = 0;\n   570→+                    while (line_start < logical_line.len and y < max_y) {\n   571→+                        const wrap_end = findWordWrapEnd(logical_line[line_start..], area.width);\n   572→+                        const line = logical_line[line_start .. line_start + wrap_end];\n   573→+                        self.renderLine(line, area.x, y, area.width, buf);\n   574→+                        line_start += wrap_end;\n   575→+                        // Skip leading spaces on next line\n   576→+                        while (line_start < logical_line.len and logical_line[line_start] == ' ') {\n   577→+                            line_start += 1;\n   578→+                        }\n   579→+                        y += 1;\n   580→+                    }\n   581→+                },\n   582→+            }\n   583→+        }\n   584→+    }\n   585→+\n   586→+    /// Render a single line of text with alignment\n   587→+    fn renderLine(self: Paragraph, line: []const u8, x: u16, y: u16, width: u16, buf: *Buffer) void {\n   588→+        if (line.len == 0) return;\n   589→+\n   590→+        const text_len = textDisplayWidth(line);\n   591→+        const visible_len = @min(text_len, width);\n   592→+\n   593→+        if (visible_len == 0) return;\n   594→+\n   595→+        const x_offset: u16 = switch (self.alignment) {\n   596→+            .left => 0,\n   597→+            .center => (width -| visible_len) / 2,\n   598→+            .right => width -| visible_len,\n   599→+        };\n   600→+\n   601→+        buf.setString(x +| x_offset, y, line, self.style);\n   602→+    }\n   603→+};\n   604→+\n   605→+/// Find the end index for word wrapping within a max width.\n   606→+/// Returns the number of characters to include on this line.\n   607→+fn findWordWrapEnd(text: []const u8, max_width: u16) usize {\n   608→+    if (text.len == 0) return 0;\n   609→+\n   610→+    const width: usize = @intCast(max_width);\n   611→+    if (text.len <= width) return text.len;\n   612→+\n   613→+    // Find the last space within the width limit\n   614→+    var last_space: ?usize = null;\n   615→+    for (0..width) |i| {\n   616→+        if (text[i] == ' ') {\n   617→+            last_space = i;\n   618→+        }\n   619→+    }\n   620→+\n   621→+    // If we found a space, wrap there (include the space in this line)\n   622→+    if (last_space) |space_pos| {\n   623→+        // Return position including the space, so next line starts after it\n   624→+        return space_pos + 1;\n   625→+    }\n   626→+\n   627→+    // No space found - break at max width (hard wrap)\n   628→+    return width;\n   629→+}\n   630→+\n   631→+/// Calculate the display width of a string (counting grapheme columns).\n   632→+/// Simple implementation: counts codepoints, treating wide chars as width 2.\n   633→+fn textDisplayWidth(str: []const u8) u16 {\n   634→+    var width: u16 = 0;\n   635→+    var iter = std.unicode.Utf8View.initUnchecked(str).iterator();\n   636→+    while (iter.nextCodepoint()) |cp| {\n   637→+        width +|= if (isWideCodepoint(cp)) 2 else 1;\n   638→+    }\n   639→+    return width;\n   640→+}\n   641→+\n   642→+/// Check if a codepoint is a wide character (CJK, etc.)\n   643→+fn isWideCodepoint(cp: u21) bool {\n   644→+    return (cp >= 0x4E00 and cp <= 0x9FFF) or // CJK Unified Ideographs\n   645→+        (cp >= 0x3400 and cp <= 0x4DBF) or // CJK Extension A\n   646→+        (cp >= 0x20000 and cp <= 0x2A6DF) or // CJK Extension B\n   647→+        (cp >= 0xF900 and cp <= 0xFAFF) or // CJK Compatibility\n   648→+        (cp >= 0xFF00 and cp <= 0xFF60) or // Fullwidth forms\n   649→+        (cp >= 0xFFE0 and cp <= 0xFFE6) or // Fullwidth symbols\n   650→+        (cp >= 0x3000 and cp <= 0x303F) or // CJK Punctuation\n   651→+        (cp >= 0x1100 and cp <= 0x11FF); // Hangul Jamo\n   652→+}\n   653→+\n   654→+// ============================================================\n   655→+// SANITY TESTS - Basic Paragraph functionality\n   656→+// ============================================================\n   657→+\n   658→+test \"sanity: Paragraph with default values\" {\n   659→+    const para = Paragraph{ .text = \"Hello\\nWorld\" };\n   660→+    try std.testing.expectEqualStrings(\"Hello\\nWorld\", para.text);\n   661→+    try std.testing.expect(para.style.isEmpty());\n   662→+    try std.testing.expect(para.wrap == .none);\n   663→+    try std.testing.expect(para.alignment == .left);\n   664→+}\n   665→+\n   666→+test \"sanity: Paragraph with custom style\" {\n   667→+    const para = Paragraph{\n   668→+        .text = \"Styled\",\n   669→+        .style = Style.init().bold().fg(.red),\n   670→+    };\n   671→+    try std.testing.expect(para.style.hasAttribute(.bold));\n   672→+}\n   673→+\n   674→+test \"sanity: Paragraph with wrap modes\" {\n   675→+    const none_wrap = Paragraph{ .text = \"T\", .wrap = .none };\n   676→+    const char_wrap = Paragraph{ .text = \"T\", .wrap = .char };\n   677→+    const word_wrap = Paragraph{ .text = \"T\", .wrap = .word };\n   678→+\n   679→+    try std.testing.expect(none_wrap.wrap == .none);\n   680→+    try std.testing.expect(char_wrap.wrap == .char);\n   681→+    try std.testing.expect(word_wrap.wrap == .word);\n   682→+}\n   683→+\n   684→+test \"sanity: Paragraph with alignment\" {\n   685→+    const left = Paragraph{ .text = \"L\", .alignment = .left };\n   686→+    const center = Paragraph{ .text = \"C\", .alignment = .center };\n   687→+    const right = Paragraph{ .text = \"R\", .alignment = .right };\n   688→+\n   689→+    try std.testing.expect(left.alignment == .left);\n   690→+    try std.testing.expect(center.alignment == .center);\n   691→+    try std.testing.expect(right.alignment == .right);\n   692→+}\n   693→+\n   694→+// ============================================================\n   695→+// BEHAVIOR TESTS - Rendering\n   696→+// ============================================================\n   697→+\n   698→+test \"behavior: Paragraph renders single line\" {\n   699→+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   700→+    defer buf.deinit();\n   701→+\n   702→+    const para = Paragraph{ .text = \"Hello\" };\n   703→+    para.render(Rect.init(0, 0, 20, 5), &buf);\n   704→+\n   705→+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n   706→+    try std.testing.expectEqual(@as(u21, 'e'), buf.get(1, 0).char);\n   707→+    try std.testing.expectEqual(@as(u21, 'l'), buf.get(2, 0).char);\n   708→+    try std.testing.expectEqual(@as(u21, 'l'), buf.get(3, 0).char);\n   709→+    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n   710→+}\n   711→+\n   712→+test \"behavior: Paragraph renders multiple lines with newlines\" {\n   713→+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   714→+    defer buf.deinit();\n   715→+\n   716→+    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\" };\n   717→+    para.render(Rect.init(0, 0, 20, 5), &buf);\n   718→+\n   719→+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n   720→+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n   721→+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n   722→+    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n   723→+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 2).char);\n   724→+    try std.testing.expectEqual(@as(u21, '3'), buf.get(4, 2).char);\n   725→+}\n   726→+\n   727→+test \"behavior: Paragraph with char wrap\" {\n   728→+    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n   729→+    defer buf.deinit();\n   730→+\n   731→+    const para = Paragraph{\n   732→+        .text = \"ABCDEFGHIJKLMNOP\",\n   733→+        .wrap = .char,\n   734→+    };\n   735→+    para.render(Rect.init(0, 0, 10, 5), &buf);\n   736→+\n   737→+    // First 10 chars on row 0\n   738→+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n   739→+    try std.testing.expectEqual(@as(u21, 'J'), buf.get(9, 0).char);\n   740→+    // Next 6 chars on row 1\n   741→+    try std.testing.expectEqual(@as(u21, 'K'), buf.get(0, 1).char);\n   742→+    try std.testing.expectEqual(@as(u21, 'P'), buf.get(5, 1).char);\n   743→+}\n   744→+\n   745→+test \"behavior: Paragraph with word wrap\" {\n   746→+    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n   747→+    defer buf.deinit();\n   748→+\n   749→+    const para = Paragraph{\n   750→+        .text = \"Hello World Today\",\n   751→+        .wrap = .word,\n   752→+    };\n   753→+    para.render(Rect.init(0, 0, 10, 5), &buf);\n   754→+\n   755→+    // \"Hello \" should be on row 0\n   756→+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n   757→+    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n   758→+    // \"World \" should be on row 1\n   759→+    try std.testing.expectEqual(@as(u21, 'W'), buf.get(0, 1).char);\n   760→+    try std.testing.expectEqual(@as(u21, 'd'), buf.get(4, 1).char);\n   761→+    // \"Today\" should be on row 2\n   762→+    try std.testing.expectEqual(@as(u21, 'T'), buf.get(0, 2).char);\n   763→+}\n   764→+\n   765→+test \"behavior: Paragraph center alignment\" {\n   766→+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   767→+    defer buf.deinit();\n   768→+\n   769→+    const para = Paragraph{\n   770→+        .text = \"Hi\",\n   771→+        .alignment = .center,\n   772→+    };\n   773→+    para.render(Rect.init(0, 0, 20, 5), &buf);\n   774→+\n   775→+    // \"Hi\" (2 chars) centered in 20 = offset 9\n   776→+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(9, 0).char);\n   777→+    try std.testing.expectEqual(@as(u21, 'i'), buf.get(10, 0).char);\n   778→+}\n   779→+\n   780→+test \"behavior: Paragraph right alignment\" {\n   781→+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   782→+    defer buf.deinit();\n   783→+\n   784→+    const para = Paragraph{\n   785→+        .text = \"End\",\n   786→+        .alignment = .right,\n   787→+    };\n   788→+    para.render(Rect.init(0, 0, 20, 5), &buf);\n   789→+\n   790→+    // \"End\" (3 chars) right-aligned in 20 = starts at 17\n   791→+    try std.testing.expectEqual(@as(u21, 'E'), buf.get(17, 0).char);\n   792→+    try std.testing.expectEqual(@as(u21, 'd'), buf.get(19, 0).char);\n   793→+}\n   794→+\n   795→+test \"behavior: Paragraph applies style\" {\n   796→+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   797→+    defer buf.deinit();\n   798→+\n   799→+    const para = Paragraph{\n   800→+        .text = \"Bold\",\n   801→+        .style = Style.init().bold(),\n   802→+    };\n   803→+    para.render(Rect.init(0, 0, 20, 5), &buf);\n   804→+\n   805→+    try std.testing.expect(buf.get(0, 0).style.hasAttribute(.bold));\n   806→+    try std.testing.expect(buf.get(1, 0).style.hasAttribute(.bold));\n   807→+}\n   808→+\n   809→+test \"behavior: Paragraph renders at area offset\" {\n   810→+    var buf = try Buffer.init(std.testing.allocator, 30, 10);\n   811→+    defer buf.deinit();\n   812→+\n   813→+    const para = Paragraph{ .text = \"Offset\\nTest\" };\n   814→+    para.render(Rect.init(5, 3, 10, 5), &buf);\n   815→+\n   816→+    try std.testing.expectEqual(@as(u21, 'O'), buf.get(5, 3).char);\n   817→+    try std.testing.expectEqual(@as(u21, 'T'), buf.get(5, 4).char);\n   818→+}\n   819→+\n   820→+// ============================================================\n   821→+// REGRESSION TESTS - Edge cases\n   822→+// ============================================================\n   823→+\n   824→+test \"regression: Paragraph handles empty area\" {\n   825→+    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n   826→+    defer buf.deinit();\n   827→+\n   828→+    const para = Paragraph{ .text = \"Test\" };\n   829→+    para.render(Rect.init(0, 0, 0, 0), &buf);\n   830→+\n   831→+    // Buffer should be unchanged\n   832→+    for (buf.cells) |cell| {\n   833→+        try std.testing.expect(cell.isDefault());\n   834→+    }\n   835→+}\n   836→+\n   837→+test \"regression: Paragraph handles empty text\" {\n   838→+    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n   839→+    defer buf.deinit();\n   840→+\n   841→+    const para = Paragraph{ .text = \"\" };\n   842→+    para.render(Rect.init(0, 0, 10, 5), &buf);\n   843→+\n   844→+    // Buffer should be unchanged\n   845→+    for (buf.cells) |cell| {\n   846→+        try std.testing.expect(cell.isDefault());\n   847→+    }\n   848→+}\n   849→+\n   850→+test \"regression: Paragraph clips lines beyond height\" {\n   851→+    var buf = try Buffer.init(std.testing.allocator, 20, 2);\n   852→+    defer buf.deinit();\n   853→+\n   854→+    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\\nLine4\" };\n   855→+    para.render(Rect.init(0, 0, 20, 2), &buf);\n   856→+\n   857→+    // Only first 2 lines should be rendered\n   858→+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n   859→+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n   860→+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n   861→+    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n   862→+}\n   863→+\n   864→+test \"regression: Paragraph word wrap handles long words\" {\n   865→+    var buf = try Buffer.init(std.testing.allocator, 5, 5);\n   866→+    defer buf.deinit();\n   867→+\n   868→+    // Word longer than width - should hard wrap\n   869→+    const para = Paragraph{\n   870→+        .text = \"ABCDEFGH\",\n   871→+        .wrap = .word,\n   872→+    };\n   873→+    para.render(Rect.init(0, 0, 5, 5), &buf);\n   874→+\n   875→+    // Should hard wrap at width since no spaces\n   876→+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n   877→+    try std.testing.expectEqual(@as(u21, 'E'), buf.get(4, 0).char);\n   878→+    try std.testing.expectEqual(@as(u21, 'F'), buf.get(0, 1).char);\n   879→+}\n   880→+\n   881→+test \"regression: Paragraph handles trailing newline\" {\n   882→+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   883→+    defer buf.deinit();\n   884→+\n   885→+    const para = Paragraph{ .text = \"Line1\\n\" };\n   886→+    para.render(Rect.init(0, 0, 20, 5), &buf);\n   887→+\n   888→+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n   889→+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n   890→+}\n   891→+\n   892→+test \"regression: Paragraph handles consecutive newlines\" {\n   893→+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   894→+    defer buf.deinit();\n   895→+\n   896→+    const para = Paragraph{ .text = \"A\\n\\nB\" };\n   897→+    para.render(Rect.init(0, 0, 20, 5), &buf);\n   898→+\n   899→+    // A on row 0, empty row 1, B on row 2\n   900→+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n   901→+    try std.testing.expectEqual(@as(u21, 'B'), buf.get(0, 2).char);\n   902→+}\n   903→+\n   904→+test \"regression: findWordWrapEnd handles empty text\" {\n   905→+    const result = findWordWrapEnd(\"\", 10);\n   906→+    try std.testing.expectEqual(@as(usize, 0), result);\n   907→+}\n   908→+\n   909→+test \"regression: findWordWrapEnd handles short text\" {\n   910→+    const result = findWordWrapEnd(\"Hi\", 10);\n   911→+    try std.testing.expectEqual(@as(usize, 2), result);\n   912→+}\n   913→+\n   914→+test \"regression: findWordWrapEnd breaks at space\" {\n   915→+    const result = findWordWrapEnd(\"Hello World\", 7);\n   916→+    // Should break after \"Hello \" (6 chars including space)\n   917→+    try std.testing.expectEqual(@as(usize, 6), result);\n   918→+}\n   919→+\n   920→+test \"regression: findWordWrapEnd hard breaks long word\" {\n   921→+    const result = findWordWrapEnd(\"Supercalifragilistic\", 5);\n   922→+    // No space found, hard break at width\n   923→+    try std.testing.expectEqual(@as(usize, 5), result);\n   924→+}\n   925→+\n   926→+test \"regression: textDisplayWidth handles ASCII\" {\n   927→+    const w = textDisplayWidth(\"Hello\");\n   928→+    try std.testing.expectEqual(@as(u16, 5), w);\n   929→+}\n   930→+\n   931→+test \"regression: textDisplayWidth handles wide chars\" {\n   932→+    const w = textDisplayWidth(\"\\u{4E2D}\");\n   933→+    try std.testing.expectEqual(@as(u16, 2), w);\n   934→+}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "6a052cfc-ba1e-4813-bbf6-f981adfcc94e"
tool_use_result:
  type: text
  file:
    filePath: /home/hotschmoe/.claude/projects/-home-hotschmoe-zithril/1bb8dd36-e928-4d38-bca6-6793125c3cb1/tool-results/toolu_01QmeUiQgnzxpU2uN9Swdb8c.txt
    content: "diff --git a/examples/counter.zig b/examples/counter.zig\nindex ed5b801..bdc7155 100644\n--- a/examples/counter.zig\n+++ b/examples/counter.zig\n@@ -1,20 +1,81 @@\n-// Minimal counter example - placeholder for full zithril implementation\n+// Minimal counter example for zithril TUI framework\n+//\n+// Demonstrates:\n+// - Single counter value state\n+// - Key handling (q=quit, up/down=increment/decrement)\n+// - Simple view with Block and counter display\n+\n const std = @import(\"std\");\n const zithril = @import(\"zithril\");\n-const rich_zig = @import(\"rich_zig\");\n+\n+// Application state: a single counter value\n+const State = struct {\n+    count: i32 = 0,\n+};\n+\n+// Handle events and return actions\n+fn update(state: *State, event: zithril.Event) zithril.Action {\n+    switch (event) {\n+        .key => |key| {\n+            // No modifiers for these keys\n+            if (!key.modifiers.any()) {\n+                switch (key.code) {\n+                    .char => |c| {\n+                        if (c == 'q') return .quit;\n+                    },\n+                    .up => state.count +|= 1,\n+                    .down => state.count -|= 1,\n+                    else => {},\n+                }\n+            }\n+        },\n+        else => {},\n+    }\n+    return .none;\n+}\n+\n+// Render the UI\n+fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n+    const area = frame.size();\n+\n+    // Draw a block with title\n+    const block = zithril.Block{\n+        .title = \"Counter\",\n+        .border = .rounded,\n+        .border_style = zithril.Style.init().fg(.cyan),\n+    };\n+    frame.render(block, area);\n+\n+    // Get interior area for content\n+    const inner = block.inner(area);\n+    if (inner.isEmpty()) return;\n+\n+    // Format the counter value\n+    var buf: [64]u8 = undefined;\n+    const count_str = std.fmt.bufPrint(&buf, \"Count: {d}\", .{state.count}) catch \"???\";\n+\n+    // Draw counter text centered in the block\n+    const text = zithril.Text{\n+        .content = count_str,\n+        .style = zithril.Style.init().bold().fg(.green),\n+        .alignment = .center,\n+    };\n+    frame.render(text, inner);\n+}\n \n pub fn main() !void {\n     var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n     defer _ = gpa.deinit();\n     const allocator = gpa.allocator();\n \n-    var console = rich_zig.Console.init(allocator);\n-    defer console.deinit();\n+    var app = zithril.App(State).init(.{\n+        .state = .{},\n+        .update = update,\n+        .view = view,\n+    });\n \n-    const style = zithril.Style.init().bold().fg(.green);\n-    const segments = [_]rich_zig.Segment{\n-        rich_zig.Segment.styled(\"Counter Example\", style.toRichStyle()),\n-    };\n-    try console.printSegments(&segments);\n-    try console.print(\"(Full TUI implementation coming soon)\");\n+    try app.run(allocator);\n }\n+\n+// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\n+pub const panic = zithril.terminal_panic;\ndiff --git a/examples/list.zig b/examples/list.zig\nindex 8e94db0..39257b9 100644\n--- a/examples/list.zig\n+++ b/examples/list.zig\n@@ -1,20 +1,123 @@\n-// List example - demonstrates a navigable list widget\n+// List example for zithril TUI framework\n+//\n+// Demonstrates:\n+// - Navigable list with items and selected index state\n+// - Key handling (q=quit, j/down=next, k/up=previous)\n+// - Selection highlight with visual feedback\n+\n const std = @import(\"std\");\n const zithril = @import(\"zithril\");\n-const rich_zig = @import(\"rich_zig\");\n+\n+// Application state: list items and selection index\n+const State = struct {\n+    items: []const []const u8,\n+    selected: usize = 0,\n+\n+    fn selectNext(self: *State) void {\n+        if (self.items.len == 0) return;\n+        if (self.selected < self.items.len - 1) {\n+            self.selected += 1;\n+        }\n+    }\n+\n+    fn selectPrev(self: *State) void {\n+        if (self.selected > 0) {\n+            self.selected -= 1;\n+        }\n+    }\n+\n+    fn selectFirst(self: *State) void {\n+        self.selected = 0;\n+    }\n+\n+    fn selectLast(self: *State) void {\n+        if (self.items.len > 0) {\n+            self.selected = self.items.len - 1;\n+        }\n+    }\n+};\n+\n+// Handle events and return actions\n+fn update(state: *State, event: zithril.Event) zithril.Action {\n+    switch (event) {\n+        .key => |key| {\n+            if (!key.modifiers.any()) {\n+                switch (key.code) {\n+                    .char => |c| switch (c) {\n+                        'q' => return .quit,\n+                        'j' => state.selectNext(),\n+                        'k' => state.selectPrev(),\n+                        'g' => state.selectFirst(),\n+                        'G' => state.selectLast(),\n+                        else => {},\n+                    },\n+                    .up => state.selectPrev(),\n+                    .down => state.selectNext(),\n+                    .home => state.selectFirst(),\n+                    .end => state.selectLast(),\n+                    else => {},\n+                }\n+            }\n+        },\n+        else => {},\n+    }\n+    return .none;\n+}\n+\n+// Render the UI\n+fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n+    const area = frame.size();\n+\n+    // Outer block with title\n+    const block = zithril.Block{\n+        .title = \"List Navigation (j/k or arrows, q to quit)\",\n+        .border = .rounded,\n+        .border_style = zithril.Style.init().fg(.cyan),\n+    };\n+    frame.render(block, area);\n+\n+    // Get interior area for the list\n+    const inner = block.inner(area);\n+    if (inner.isEmpty()) return;\n+\n+    // Render the list widget\n+    const list = zithril.List{\n+        .items = state.items,\n+        .selected = state.selected,\n+        .style = zithril.Style.init().fg(.white),\n+        .highlight_style = zithril.Style.init().bg(.blue).fg(.white).bold(),\n+        .highlight_symbol = \"> \",\n+    };\n+    frame.render(list, inner);\n+}\n \n pub fn main() !void {\n     var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n     defer _ = gpa.deinit();\n     const allocator = gpa.allocator();\n \n-    var console = rich_zig.Console.init(allocator);\n-    defer console.deinit();\n-\n-    const style = zithril.Style.init().bold().fg(.cyan);\n-    const segments = [_]rich_zig.Segment{\n-        rich_zig.Segment.styled(\"List Example\", style.toRichStyle()),\n+    // Sample items for the list\n+    const items = [_][]const u8{\n+        \"Apple\",\n+        \"Banana\",\n+        \"Cherry\",\n+        \"Date\",\n+        \"Elderberry\",\n+        \"Fig\",\n+        \"Grape\",\n+        \"Honeydew\",\n+        \"Jackfruit\",\n+        \"Kiwi\",\n     };\n-    try console.printSegments(&segments);\n-    try console.print(\"(Full TUI list implementation coming soon)\");\n+\n+    var app = zithril.App(State).init(.{\n+        .state = .{ .items = &items, .selected = 0 },\n+        .update = update,\n+        .view = view,\n+    });\n+\n+    try app.run(allocator);\n }\n+\n+// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\n+pub const panic = zithril.terminal_panic;\ndiff --git a/src/backend.zig b/src/backend.zig\nindex 271f7d4..2178ba7 100644\n--- a/src/backend.zig\n+++ b/src/backend.zig\n@@ -61,125 +61,147 @@ fn emergencyCleanup() void {\n /// Applications can use this by adding to their root source file:\n ///   pub const panic = @import(\"zithril\").backend_mod.panic;\n /// This ensures terminal state is restored before panic output is displayed.\n+///\n+/// The panic namespace matches Zig 0.15's expected interface (std.debug.no_panic).\n pub const panic = struct {\n     /// Core panic function called by @panic and runtime safety checks.\n     pub fn call(msg: []const u8, ret_addr: ?usize) noreturn {\n         @branchHint(.cold);\n+        _ = ret_addr;\n+\n         // Perform cleanup first so panic message is visible\n         emergencyCleanup();\n \n-        // Use standard panic behavior\n-        _ = ret_addr;\n-        std.debug.lockStdErr();\n-        const stderr = std.io.getStdErr();\n+        // Write error message directly to stderr fd\n+        const stderr_fd = std.posix.STDERR_FILENO;\n+        const stderr = std.fs.File{ .handle = stderr_fd };\n         stderr.writeAll(msg) catch {};\n         stderr.writeAll(\"\\n\") catch {};\n         @trap();\n     }\n \n-    pub fn sentinelMismatch(expected: anytype, found: @TypeOf(expected)) noreturn {\n-        _ = found;\n+    pub fn sentinelMismatch(_: anytype, _: anytype) noreturn {\n+        @branchHint(.cold);\n         call(\"sentinel mismatch\", null);\n     }\n \n-    pub fn unwrapError(err: anyerror) noreturn {\n-        _ = &err;\n+    pub fn unwrapError(_: anyerror) noreturn {\n+        @branchHint(.cold);\n         call(\"attempt to unwrap error\", null);\n     }\n \n-    pub fn outOfBounds(index: usize, len: usize) noreturn {\n-        _ = index;\n-        _ = len;\n+    pub fn outOfBounds(_: usize, _: usize) noreturn {\n+        @branchHint(.cold);\n         call(\"index out of bounds\", null);\n     }\n \n-    pub fn startGreaterThanEnd(start: usize, end: usize) noreturn {\n-        _ = start;\n-        _ = end;\n+    pub fn startGreaterThanEnd(_: usize, _: usize) noreturn {\n+        @branchHint(.cold);\n         call(\"start index is larger than end index\", null);\n     }\n \n-    pub fn inactiveUnionField(active: anytype, accessed: @TypeOf(active)) noreturn {\n-        _ = accessed;\n+    pub fn inactiveUnionField(_: anytype, _: anytype) noreturn {\n+        @branchHint(.cold);\n         call(\"access of inactive union field\", null);\n     }\n \n-    pub fn sliceCastLenRemainder(src_len: usize) noreturn {\n-        _ = src_len;\n+    pub fn sliceCastLenRemainder(_: usize) noreturn {\n+        @branchHint(.cold);\n         call(\"slice cast has len remainder\", null);\n     }\n \n-    pub fn castToNull(value: anytype) noreturn {\n-        _ = value;\n-        call(\"cast to null\", null);\n-    }\n-\n     pub fn reachedUnreachable() noreturn {\n+        @branchHint(.cold);\n         call(\"reached unreachable code\", null);\n     }\n \n     pub fn unwrapNull() noreturn {\n+        @branchHint(.cold);\n         call(\"unwrap of null optional\", null);\n     }\n \n-    pub fn signedOverflow(a: anytype, b: anytype) noreturn {\n-        _ = a;\n-        _ = b;\n-        call(\"signed integer overflow\", null);\n+    pub fn castToNull() noreturn {\n+        @branchHint(.cold);\n+        call(\"cast to null\", null);\n     }\n \n-    pub fn unsignedOverflow(a: anytype, b: anytype) noreturn {\n-        _ = a;\n-        _ = b;\n-        call(\"unsigned integer overflow\", null);\n+    pub fn incorrectAlignment() noreturn {\n+        @branchHint(.cold);\n+        call(\"incorrect alignment\", null);\n     }\n \n-    pub fn exactDivisionRemainder(numerator: anytype, denominator: anytype) noreturn {\n-        _ = numerator;\n-        _ = denominator;\n-        call(\"exact division has remainder\", null);\n+    pub fn invalidErrorCode() noreturn {\n+        @branchHint(.cold);\n+        call(\"invalid error code\", null);\n+    }\n+\n+    pub fn integerOutOfBounds() noreturn {\n+        @branchHint(.cold);\n+        call(\"integer out of bounds\", null);\n     }\n \n-    pub fn divisionByZero(numerator: anytype) noreturn {\n-        _ = numerator;\n+    pub fn integerOverflow() noreturn {\n+        @branchHint(.cold);\n+        call(\"integer overflow\", null);\n+    }\n+\n+    pub fn shlOverflow() noreturn {\n+        @branchHint(.cold);\n+        call(\"shift left overflow\", null);\n+    }\n+\n+    pub fn shrOverflow() noreturn {\n+        @branchHint(.cold);\n+        call(\"shift right overflow\", null);\n+    }\n+\n+    pub fn divideByZero() noreturn {\n+        @branchHint(.cold);\n         call(\"division by zero\", null);\n     }\n \n-    pub fn negativeShiftCount(count: anytype) noreturn {\n-        _ = count;\n-        call(\"negative shift count\", null);\n+    pub fn exactDivisionRemainder() noreturn {\n+        @branchHint(.cold);\n+        call(\"exact division has remainder\", null);\n+    }\n+\n+    pub fn integerPartOutOfBounds() noreturn {\n+        @branchHint(.cold);\n+        call(\"integer part out of bounds\", null);\n     }\n \n-    pub fn shiftOverflow(a: anytype, b: anytype) noreturn {\n-        _ = a;\n-        _ = b;\n-        call(\"shift overflow\", null);\n+    pub fn corruptSwitch() noreturn {\n+        @branchHint(.cold);\n+        call(\"corrupt switch\", null);\n     }\n \n-    pub fn memcpyDestOverlap() noreturn {\n-        call(\"memcpy dest overlaps src\", null);\n+    pub fn shiftRhsTooBig() noreturn {\n+        @branchHint(.cold);\n+        call(\"shift rhs too big\", null);\n     }\n \n-    pub fn intToEnumOverflow() noreturn {\n-        call(\"int to enum overflow\", null);\n+    pub fn invalidEnumValue() noreturn {\n+        @branchHint(.cold);\n+        call(\"invalid enum value\", null);\n     }\n \n-    pub fn intToFloatOverflow(value: anytype) noreturn {\n-        _ = value;\n-        call(\"int to float overflow\", null);\n+    pub fn forLenMismatch() noreturn {\n+        @branchHint(.cold);\n+        call(\"for loop length mismatch\", null);\n     }\n \n-    pub fn floatToIntOverflow(value: anytype) noreturn {\n-        _ = value;\n-        call(\"float to int overflow\", null);\n+    pub fn copyLenMismatch() noreturn {\n+        @branchHint(.cold);\n+        call(\"copy length mismatch\", null);\n     }\n \n-    pub fn invalidEnumCast(value: anytype) noreturn {\n-        _ = value;\n-        call(\"invalid enum cast\", null);\n+    pub fn memcpyAlias() noreturn {\n+        @branchHint(.cold);\n+        call(\"memcpy with overlapping memory\", null);\n     }\n \n-    pub fn noReturn() noreturn {\n+    pub fn noreturnReturned() noreturn {\n+        @branchHint(.cold);\n         call(\"noreturn function returned\", null);\n     }\n };\ndiff --git a/src/root.zig b/src/root.zig\nindex 5823d8c..56788ef 100644\n--- a/src/root.zig\n+++ b/src/root.zig\n@@ -93,6 +93,8 @@ pub const BorderChars = widgets.BorderChars;\n pub const Text = widgets.Text;\n pub const List = widgets.List;\n pub const Gauge = widgets.Gauge;\n+pub const Paragraph = widgets.Paragraph;\n+pub const Wrap = widgets.Wrap;\n pub const Alignment = widgets.Alignment;\n \n test \"style wrapper\" {\ndiff --git a/src/widgets.zig b/src/widgets.zig\nindex 64bb16c..ea926e2 100644\n--- a/src/widgets.zig\n+++ b/src/widgets.zig\n@@ -16,9 +16,14 @@ pub const List = list.List;\n pub const gauge = @import(\"widgets/gauge.zig\");\n pub const Gauge = gauge.Gauge;\n \n+pub const paragraph = @import(\"widgets/paragraph.zig\");\n+pub const Paragraph = paragraph.Paragraph;\n+pub const Wrap = paragraph.Wrap;\n+\n test \"widgets module\" {\n     _ = block;\n     _ = text;\n     _ = list;\n     _ = gauge;\n+    _ = paragraph;\n }\ndiff --git a/src/widgets/paragraph.zig b/src/widgets/paragraph.zig\nnew file mode 100644\nindex 0000000..a147499\n--- /dev/null\n+++ b/src/widgets/paragraph.zig\n@@ -0,0 +1,452 @@\n+// Paragraph widget for zithril TUI framework\n+// Multi-line text with wrapping and alignment\n+\n+const std = @import(\"std\");\n+const buffer_mod = @import(\"../buffer.zig\");\n+const geometry = @import(\"../geometry.zig\");\n+const style_mod = @import(\"../style.zig\");\n+\n+pub const Buffer = buffer_mod.Buffer;\n+pub const Rect = geometry.Rect;\n+pub const Style = style_mod.Style;\n+\n+/// Text wrapping modes\n+pub const Wrap = enum {\n+    /// No wrapping, clip at boundary\n+    none,\n+    /// Wrap at any character position\n+    char,\n+    /// Wrap at word boundaries (spaces)\n+    word,\n+};\n+\n+/// Text alignment options\n+pub const Alignment = enum {\n+    left,\n+    center,\n+    right,\n+};\n+\n+/// Multi-line text widget with optional wrapping.\n+///\n+/// Renders text content across multiple lines with configurable wrapping\n+/// behavior and alignment. Lines beyond the area height are not rendered.\n+pub const Paragraph = struct {\n+    /// The text content to display\n+    text: []const u8,\n+\n+    /// Style applied to the text\n+    style: Style = Style.empty,\n+\n+    /// Text wrapping mode\n+    wrap: Wrap = .none,\n+\n+    /// Text alignment within each line\n+    alignment: Alignment = .left,\n+\n+    /// Render the paragraph into the buffer at the given area.\n+    /// Text is split into lines (either by newlines or wrapping) and rendered\n+    /// until the area height is filled.\n+    pub fn render(self: Paragraph, area: Rect, buf: *Buffer) void {\n+        if (area.isEmpty()) return;\n+        if (self.text.len == 0) return;\n+\n+        var y = area.y;\n+        const max_y = area.bottom();\n+\n+        // Process text line by line (split by newlines first)\n+        var line_iter = std.mem.splitScalar(u8, self.text, '\\n');\n+        while (line_iter.next()) |logical_line| {\n+            if (y >= max_y) break;\n+\n+            // Apply wrapping to this logical line\n+            switch (self.wrap) {\n+                .none => {\n+                    self.renderLine(logical_line, area.x, y, area.width, buf);\n+                    y += 1;\n+                },\n+                .char => {\n+                    var remaining = logical_line;\n+                    while (remaining.len > 0 and y < max_y) {\n+                        const chunk_len = @min(remaining.len, area.width);\n+                        const chunk = remaining[0..chunk_len];\n+                        self.renderLine(chunk, area.x, y, area.width, buf);\n+                        remaining = remaining[chunk_len..];\n+                        y += 1;\n+                    }\n+                    // Empty line should still take a row\n+                    if (logical_line.len == 0) {\n+                        y += 1;\n+                    }\n+                },\n+                .word => {\n+                    if (logical_line.len == 0) {\n+                        y += 1;\n+                        continue;\n+                    }\n+                    var line_start: usize = 0;\n+                    while (line_start < logical_line.len and y < max_y) {\n+                        const wrap_end = findWordWrapEnd(logical_line[line_start..], area.width);\n+                        const line = logical_line[line_start .. line_start + wrap_end];\n+                        self.renderLine(line, area.x, y, area.width, buf);\n+                        line_start += wrap_end;\n+                        // Skip leading spaces on next line\n+                        while (line_start < logical_line.len and logical_line[line_start] == ' ') {\n+                            line_start += 1;\n+                        }\n+                        y += 1;\n+                    }\n+                },\n+            }\n+        }\n+    }\n+\n+    /// Render a single line of text with alignment\n+    fn renderLine(self: Paragraph, line: []const u8, x: u16, y: u16, width: u16, buf: *Buffer) void {\n+        if (line.len == 0) return;\n+\n+        const text_len = textDisplayWidth(line);\n+        const visible_len = @min(text_len, width);\n+\n+        if (visible_len == 0) return;\n+\n+        const x_offset: u16 = switch (self.alignment) {\n+            .left => 0,\n+            .center => (width -| visible_len) / 2,\n+            .right => width -| visible_len,\n+        };\n+\n+        buf.setString(x +| x_offset, y, line, self.style);\n+    }\n+};\n+\n+/// Find the end index for word wrapping within a max width.\n+/// Returns the number of characters to include on this line.\n+fn findWordWrapEnd(text: []const u8, max_width: u16) usize {\n+    if (text.len == 0) return 0;\n+\n+    const width: usize = @intCast(max_width);\n+    if (text.len <= width) return text.len;\n+\n+    // Find the last space within the width limit\n+    var last_space: ?usize = null;\n+    for (0..width) |i| {\n+        if (text[i] == ' ') {\n+            last_space = i;\n+        }\n+    }\n+\n+    // If we found a space, wrap there (include the space in this line)\n+    if (last_space) |space_pos| {\n+        // Return position including the space, so next line starts after it\n+        return space_pos + 1;\n+    }\n+\n+    // No space found - break at max width (hard wrap)\n+    return width;\n+}\n+\n+/// Calculate the display width of a string (counting grapheme columns).\n+/// Simple implementation: counts codepoints, treating wide chars as width 2.\n+fn textDisplayWidth(str: []const u8) u16 {\n+    var width: u16 = 0;\n+    var iter = std.unicode.Utf8View.initUnchecked(str).iterator();\n+    while (iter.nextCodepoint()) |cp| {\n+        width +|= if (isWideCodepoint(cp)) 2 else 1;\n+    }\n+    return width;\n+}\n+\n+/// Check if a codepoint is a wide character (CJK, etc.)\n+fn isWideCodepoint(cp: u21) bool {\n+    return (cp >= 0x4E00 and cp <= 0x9FFF) or // CJK Unified Ideographs\n+        (cp >= 0x3400 and cp <= 0x4DBF) or // CJK Extension A\n+        (cp >= 0x20000 and cp <= 0x2A6DF) or // CJK Extension B\n+        (cp >= 0xF900 and cp <= 0xFAFF) or // CJK Compatibility\n+        (cp >= 0xFF00 and cp <= 0xFF60) or // Fullwidth forms\n+        (cp >= 0xFFE0 and cp <= 0xFFE6) or // Fullwidth symbols\n+        (cp >= 0x3000 and cp <= 0x303F) or // CJK Punctuation\n+        (cp >= 0x1100 and cp <= 0x11FF); // Hangul Jamo\n+}\n+\n+// ============================================================\n+// SANITY TESTS - Basic Paragraph functionality\n+// ============================================================\n+\n+test \"sanity: Paragraph with default values\" {\n+    const para = Paragraph{ .text = \"Hello\\nWorld\" };\n+    try std.testing.expectEqualStrings(\"Hello\\nWorld\", para.text);\n+    try std.testing.expect(para.style.isEmpty());\n+    try std.testing.expect(para.wrap == .none);\n+    try std.testing.expect(para.alignment == .left);\n+}\n+\n+test \"sanity: Paragraph with custom style\" {\n+    const para = Paragraph{\n+        .text = \"Styled\",\n+        .style = Style.init().bold().fg(.red),\n+    };\n+    try std.testing.expect(para.style.hasAttribute(.bold));\n+}\n+\n+test \"sanity: Paragraph with wrap modes\" {\n+    const none_wrap = Paragraph{ .text = \"T\", .wrap = .none };\n+    const char_wrap = Paragraph{ .text = \"T\", .wrap = .char };\n+    const word_wrap = Paragraph{ .text = \"T\", .wrap = .word };\n+\n+    try std.testing.expect(none_wrap.wrap == .none);\n+    try std.testing.expect(char_wrap.wrap == .char);\n+    try std.testing.expect(word_wrap.wrap == .word);\n+}\n+\n+test \"sanity: Paragraph with alignment\" {\n+    const left = Paragraph{ .text = \"L\", .alignment = .left };\n+    const center = Paragraph{ .text = \"C\", .alignment = .center };\n+    const right = Paragraph{ .text = \"R\", .alignment = .right };\n+\n+    try std.testing.expect(left.alignment == .left);\n+    try std.testing.expect(center.alignment == .center);\n+    try std.testing.expect(right.alignment == .right);\n+}\n+\n+// ============================================================\n+// BEHAVIOR TESTS - Rendering\n+// ============================================================\n+\n+test \"behavior: Paragraph renders single line\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Hello\" };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'e'), buf.get(1, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'l'), buf.get(2, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'l'), buf.get(3, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n+}\n+\n+test \"behavior: Paragraph renders multiple lines with newlines\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\" };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n+    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 2).char);\n+    try std.testing.expectEqual(@as(u21, '3'), buf.get(4, 2).char);\n+}\n+\n+test \"behavior: Paragraph with char wrap\" {\n+    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"ABCDEFGHIJKLMNOP\",\n+        .wrap = .char,\n+    };\n+    para.render(Rect.init(0, 0, 10, 5), &buf);\n+\n+    // First 10 chars on row 0\n+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'J'), buf.get(9, 0).char);\n+    // Next 6 chars on row 1\n+    try std.testing.expectEqual(@as(u21, 'K'), buf.get(0, 1).char);\n+    try std.testing.expectEqual(@as(u21, 'P'), buf.get(5, 1).char);\n+}\n+\n+test \"behavior: Paragraph with word wrap\" {\n+    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"Hello World Today\",\n+        .wrap = .word,\n+    };\n+    para.render(Rect.init(0, 0, 10, 5), &buf);\n+\n+    // \"Hello \" should be on row 0\n+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n+    // \"World \" should be on row 1\n+    try std.testing.expectEqual(@as(u21, 'W'), buf.get(0, 1).char);\n+    try std.testing.expectEqual(@as(u21, 'd'), buf.get(4, 1).char);\n+    // \"Today\" should be on row 2\n+    try std.testing.expectEqual(@as(u21, 'T'), buf.get(0, 2).char);\n+}\n+\n+test \"behavior: Paragraph center alignment\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"Hi\",\n+        .alignment = .center,\n+    };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    // \"Hi\" (2 chars) centered in 20 = offset 9\n+    try std.testing.expectEqual(@as(u21, 'H'), buf.get(9, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'i'), buf.get(10, 0).char);\n+}\n+\n+test \"behavior: Paragraph right alignment\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"End\",\n+        .alignment = .right,\n+    };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    // \"End\" (3 chars) right-aligned in 20 = starts at 17\n+    try std.testing.expectEqual(@as(u21, 'E'), buf.get(17, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'd'), buf.get(19, 0).char);\n+}\n+\n+test \"behavior: Paragraph applies style\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{\n+        .text = \"Bold\",\n+        .style = Style.init().bold(),\n+    };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    try std.testing.expect(buf.get(0, 0).style.hasAttribute(.bold));\n+    try std.testing.expect(buf.get(1, 0).style.hasAttribute(.bold));\n+}\n+\n+test \"behavior: Paragraph renders at area offset\" {\n+    var buf = try Buffer.init(std.testing.allocator, 30, 10);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Offset\\nTest\" };\n+    para.render(Rect.init(5, 3, 10, 5), &buf);\n+\n+    try std.testing.expectEqual(@as(u21, 'O'), buf.get(5, 3).char);\n+    try std.testing.expectEqual(@as(u21, 'T'), buf.get(5, 4).char);\n+}\n+\n+// ============================================================\n+// REGRESSION TESTS - Edge cases\n+// ============================================================\n+\n+test \"regression: Paragraph handles empty area\" {\n+    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Test\" };\n+    para.render(Rect.init(0, 0, 0, 0), &buf);\n+\n+    // Buffer should be unchanged\n+    for (buf.cells) |cell| {\n+        try std.testing.expect(cell.isDefault());\n+    }\n+}\n+\n+test \"regression: Paragraph handles empty text\" {\n+    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"\" };\n+    para.render(Rect.init(0, 0, 10, 5), &buf);\n+\n+    // Buffer should be unchanged\n+    for (buf.cells) |cell| {\n+        try std.testing.expect(cell.isDefault());\n+    }\n+}\n+\n+test \"regression: Paragraph clips lines beyond height\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 2);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\\nLine4\" };\n+    para.render(Rect.init(0, 0, 20, 2), &buf);\n+\n+    // Only first 2 lines should be rendered\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n+    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n+}\n+\n+test \"regression: Paragraph word wrap handles long words\" {\n+    var buf = try Buffer.init(std.testing.allocator, 5, 5);\n+    defer buf.deinit();\n+\n+    // Word longer than width - should hard wrap\n+    const para = Paragraph{\n+        .text = \"ABCDEFGH\",\n+        .wrap = .word,\n+    };\n+    para.render(Rect.init(0, 0, 5, 5), &buf);\n+\n+    // Should hard wrap at width since no spaces\n+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'E'), buf.get(4, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'F'), buf.get(0, 1).char);\n+}\n+\n+test \"regression: Paragraph handles trailing newline\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"Line1\\n\" };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n+}\n+\n+test \"regression: Paragraph handles consecutive newlines\" {\n+    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n+    defer buf.deinit();\n+\n+    const para = Paragraph{ .text = \"A\\n\\nB\" };\n+    para.render(Rect.init(0, 0, 20, 5), &buf);\n+\n+    // A on row 0, empty row 1, B on row 2\n+    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n+    try std.testing.expectEqual(@as(u21, 'B'), buf.get(0, 2).char);\n+}\n+\n+test \"regression: findWordWrapEnd handles empty text\" {\n+    const result = findWordWrapEnd(\"\", 10);\n+    try std.testing.expectEqual(@as(usize, 0), result);\n+}\n+\n+test \"regression: findWordWrapEnd handles short text\" {\n+    const result = findWordWrapEnd(\"Hi\", 10);\n+    try std.testing.expectEqual(@as(usize, 2), result);\n+}\n+\n+test \"regression: findWordWrapEnd breaks at space\" {\n+    const result = findWordWrapEnd(\"Hello World\", 7);\n+    // Should break after \"Hello \" (6 chars including space)\n+    try std.testing.expectEqual(@as(usize, 6), result);\n+}\n+\n+test \"regression: findWordWrapEnd hard breaks long word\" {\n+    const result = findWordWrapEnd(\"Supercalifragilistic\", 5);\n+    // No space found, hard break at width\n+    try std.testing.expectEqual(@as(usize, 5), result);\n+}\n+\n+test \"regression: textDisplayWidth handles ASCII\" {\n+    const w = textDisplayWidth(\"Hello\");\n+    try std.testing.expectEqual(@as(u16, 5), w);\n+}\n+\n+test \"regression: textDisplayWidth handles wide chars\" {\n+    const w = textDisplayWidth(\"\\u{4E2D}\");\n+    try std.testing.expectEqual(@as(u16, 2), w);\n+}"
    numLines: 934
    startLine: 1
    totalLines: 934
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01DtWcAf8NAhCQirwU7AwcfY
  type: message
  role: assistant
  content[1]{type,text}:
    text,Now I have a clear view of the changes. Let me read the current state of the key modified files to review them for simplification opportunities.
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 13919
    cache_read_input_tokens: 25183
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 13919
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: a757b492-9a67-4d65-902f-1e16a4886188
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01DtWcAf8NAhCQirwU7AwcfY
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01Ln8nKrtpz4c2Cz9kUu7MzR
      name: Read
      input:
        file_path: /home/hotschmoe/zithril/examples/counter.zig
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 13919
    cache_read_input_tokens: 25183
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 13919
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "2005b0fe-230f-4f79-b4bb-a922bfbf5368"
type: user
message:
  role: user
  content[1]{tool_use_id,type,content}:
    toolu_01Ln8nKrtpz4c2Cz9kUu7MzR,tool_result,"     1→// Minimal counter example for zithril TUI framework\n     2→//\n     3→// Demonstrates:\n     4→// - Single counter value state\n     5→// - Key handling (q=quit, up/down=increment/decrement)\n     6→// - Simple view with Block and counter display\n     7→\n     8→const std = @import(\"std\");\n     9→const zithril = @import(\"zithril\");\n    10→\n    11→// Application state: a single counter value\n    12→const State = struct {\n    13→    count: i32 = 0,\n    14→};\n    15→\n    16→// Handle events and return actions\n    17→fn update(state: *State, event: zithril.Event) zithril.Action {\n    18→    switch (event) {\n    19→        .key => |key| {\n    20→            // No modifiers for these keys\n    21→            if (!key.modifiers.any()) {\n    22→                switch (key.code) {\n    23→                    .char => |c| {\n    24→                        if (c == 'q') return .quit;\n    25→                    },\n    26→                    .up => state.count +|= 1,\n    27→                    .down => state.count -|= 1,\n    28→                    else => {},\n    29→                }\n    30→            }\n    31→        },\n    32→        else => {},\n    33→    }\n    34→    return .none;\n    35→}\n    36→\n    37→// Render the UI\n    38→fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n    39→    const area = frame.size();\n    40→\n    41→    // Draw a block with title\n    42→    const block = zithril.Block{\n    43→        .title = \"Counter\",\n    44→        .border = .rounded,\n    45→        .border_style = zithril.Style.init().fg(.cyan),\n    46→    };\n    47→    frame.render(block, area);\n    48→\n    49→    // Get interior area for content\n    50→    const inner = block.inner(area);\n    51→    if (inner.isEmpty()) return;\n    52→\n    53→    // Format the counter value\n    54→    var buf: [64]u8 = undefined;\n    55→    const count_str = std.fmt.bufPrint(&buf, \"Count: {d}\", .{state.count}) catch \"???\";\n    56→\n    57→    // Draw counter text centered in the block\n    58→    const text = zithril.Text{\n    59→        .content = count_str,\n    60→        .style = zithril.Style.init().bold().fg(.green),\n    61→        .alignment = .center,\n    62→    };\n    63→    frame.render(text, inner);\n    64→}\n    65→\n    66→pub fn main() !void {\n    67→    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    68→    defer _ = gpa.deinit();\n    69→    const allocator = gpa.allocator();\n    70→\n    71→    var app = zithril.App(State).init(.{\n    72→        .state = .{},\n    73→        .update = update,\n    74→        .view = view,\n    75→    });\n    76→\n    77→    try app.run(allocator);\n    78→}\n    79→\n    80→// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\n    81→pub const panic = zithril.terminal_panic;\n    82→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: bc7399d0-2572-41bf-b73b-0aefc69585df
tool_use_result:
  type: text
  file:
    filePath: /home/hotschmoe/zithril/examples/counter.zig
    content: "// Minimal counter example for zithril TUI framework\n//\n// Demonstrates:\n// - Single counter value state\n// - Key handling (q=quit, up/down=increment/decrement)\n// - Simple view with Block and counter display\n\nconst std = @import(\"std\");\nconst zithril = @import(\"zithril\");\n\n// Application state: a single counter value\nconst State = struct {\n    count: i32 = 0,\n};\n\n// Handle events and return actions\nfn update(state: *State, event: zithril.Event) zithril.Action {\n    switch (event) {\n        .key => |key| {\n            // No modifiers for these keys\n            if (!key.modifiers.any()) {\n                switch (key.code) {\n                    .char => |c| {\n                        if (c == 'q') return .quit;\n                    },\n                    .up => state.count +|= 1,\n                    .down => state.count -|= 1,\n                    else => {},\n                }\n            }\n        },\n        else => {},\n    }\n    return .none;\n}\n\n// Render the UI\nfn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n    const area = frame.size();\n\n    // Draw a block with title\n    const block = zithril.Block{\n        .title = \"Counter\",\n        .border = .rounded,\n        .border_style = zithril.Style.init().fg(.cyan),\n    };\n    frame.render(block, area);\n\n    // Get interior area for content\n    const inner = block.inner(area);\n    if (inner.isEmpty()) return;\n\n    // Format the counter value\n    var buf: [64]u8 = undefined;\n    const count_str = std.fmt.bufPrint(&buf, \"Count: {d}\", .{state.count}) catch \"???\";\n\n    // Draw counter text centered in the block\n    const text = zithril.Text{\n        .content = count_str,\n        .style = zithril.Style.init().bold().fg(.green),\n        .alignment = .center,\n    };\n    frame.render(text, inner);\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    var app = zithril.App(State).init(.{\n        .state = .{},\n        .update = update,\n        .view = view,\n    });\n\n    try app.run(allocator);\n}\n\n// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\npub const panic = zithril.terminal_panic;\n"
    numLines: 82
    startLine: 1
    totalLines: 82
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01DtWcAf8NAhCQirwU7AwcfY
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01Eoo6EQFCWij97ZfL6hqXcM
      name: Read
      input:
        file_path: /home/hotschmoe/zithril/examples/list.zig
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 13919
    cache_read_input_tokens: 25183
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 13919
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "61c37544-e5a8-4a80-8077-9d990486b189"
type: user
message:
  role: user
  content[1]{tool_use_id,type,content}:
    toolu_01Eoo6EQFCWij97ZfL6hqXcM,tool_result,"     1→// List example for zithril TUI framework\n     2→//\n     3→// Demonstrates:\n     4→// - Navigable list with items and selected index state\n     5→// - Key handling (q=quit, j/down=next, k/up=previous)\n     6→// - Selection highlight with visual feedback\n     7→\n     8→const std = @import(\"std\");\n     9→const zithril = @import(\"zithril\");\n    10→\n    11→// Application state: list items and selection index\n    12→const State = struct {\n    13→    items: []const []const u8,\n    14→    selected: usize = 0,\n    15→\n    16→    fn selectNext(self: *State) void {\n    17→        if (self.items.len == 0) return;\n    18→        if (self.selected < self.items.len - 1) {\n    19→            self.selected += 1;\n    20→        }\n    21→    }\n    22→\n    23→    fn selectPrev(self: *State) void {\n    24→        if (self.selected > 0) {\n    25→            self.selected -= 1;\n    26→        }\n    27→    }\n    28→\n    29→    fn selectFirst(self: *State) void {\n    30→        self.selected = 0;\n    31→    }\n    32→\n    33→    fn selectLast(self: *State) void {\n    34→        if (self.items.len > 0) {\n    35→            self.selected = self.items.len - 1;\n    36→        }\n    37→    }\n    38→};\n    39→\n    40→// Handle events and return actions\n    41→fn update(state: *State, event: zithril.Event) zithril.Action {\n    42→    switch (event) {\n    43→        .key => |key| {\n    44→            if (!key.modifiers.any()) {\n    45→                switch (key.code) {\n    46→                    .char => |c| switch (c) {\n    47→                        'q' => return .quit,\n    48→                        'j' => state.selectNext(),\n    49→                        'k' => state.selectPrev(),\n    50→                        'g' => state.selectFirst(),\n    51→                        'G' => state.selectLast(),\n    52→                        else => {},\n    53→                    },\n    54→                    .up => state.selectPrev(),\n    55→                    .down => state.selectNext(),\n    56→                    .home => state.selectFirst(),\n    57→                    .end => state.selectLast(),\n    58→                    else => {},\n    59→                }\n    60→            }\n    61→        },\n    62→        else => {},\n    63→    }\n    64→    return .none;\n    65→}\n    66→\n    67→// Render the UI\n    68→fn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n    69→    const area = frame.size();\n    70→\n    71→    // Outer block with title\n    72→    const block = zithril.Block{\n    73→        .title = \"List Navigation (j/k or arrows, q to quit)\",\n    74→        .border = .rounded,\n    75→        .border_style = zithril.Style.init().fg(.cyan),\n    76→    };\n    77→    frame.render(block, area);\n    78→\n    79→    // Get interior area for the list\n    80→    const inner = block.inner(area);\n    81→    if (inner.isEmpty()) return;\n    82→\n    83→    // Render the list widget\n    84→    const list = zithril.List{\n    85→        .items = state.items,\n    86→        .selected = state.selected,\n    87→        .style = zithril.Style.init().fg(.white),\n    88→        .highlight_style = zithril.Style.init().bg(.blue).fg(.white).bold(),\n    89→        .highlight_symbol = \"> \",\n    90→    };\n    91→    frame.render(list, inner);\n    92→}\n    93→\n    94→pub fn main() !void {\n    95→    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    96→    defer _ = gpa.deinit();\n    97→    const allocator = gpa.allocator();\n    98→\n    99→    // Sample items for the list\n   100→    const items = [_][]const u8{\n   101→        \"Apple\",\n   102→        \"Banana\",\n   103→        \"Cherry\",\n   104→        \"Date\",\n   105→        \"Elderberry\",\n   106→        \"Fig\",\n   107→        \"Grape\",\n   108→        \"Honeydew\",\n   109→        \"Jackfruit\",\n   110→        \"Kiwi\",\n   111→    };\n   112→\n   113→    var app = zithril.App(State).init(.{\n   114→        .state = .{ .items = &items, .selected = 0 },\n   115→        .update = update,\n   116→        .view = view,\n   117→    });\n   118→\n   119→    try app.run(allocator);\n   120→}\n   121→\n   122→// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\n   123→pub const panic = zithril.terminal_panic;\n   124→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "9d285ba9-c76b-4b06-8249-0822c3386de7"
tool_use_result:
  type: text
  file:
    filePath: /home/hotschmoe/zithril/examples/list.zig
    content: "// List example for zithril TUI framework\n//\n// Demonstrates:\n// - Navigable list with items and selected index state\n// - Key handling (q=quit, j/down=next, k/up=previous)\n// - Selection highlight with visual feedback\n\nconst std = @import(\"std\");\nconst zithril = @import(\"zithril\");\n\n// Application state: list items and selection index\nconst State = struct {\n    items: []const []const u8,\n    selected: usize = 0,\n\n    fn selectNext(self: *State) void {\n        if (self.items.len == 0) return;\n        if (self.selected < self.items.len - 1) {\n            self.selected += 1;\n        }\n    }\n\n    fn selectPrev(self: *State) void {\n        if (self.selected > 0) {\n            self.selected -= 1;\n        }\n    }\n\n    fn selectFirst(self: *State) void {\n        self.selected = 0;\n    }\n\n    fn selectLast(self: *State) void {\n        if (self.items.len > 0) {\n            self.selected = self.items.len - 1;\n        }\n    }\n};\n\n// Handle events and return actions\nfn update(state: *State, event: zithril.Event) zithril.Action {\n    switch (event) {\n        .key => |key| {\n            if (!key.modifiers.any()) {\n                switch (key.code) {\n                    .char => |c| switch (c) {\n                        'q' => return .quit,\n                        'j' => state.selectNext(),\n                        'k' => state.selectPrev(),\n                        'g' => state.selectFirst(),\n                        'G' => state.selectLast(),\n                        else => {},\n                    },\n                    .up => state.selectPrev(),\n                    .down => state.selectNext(),\n                    .home => state.selectFirst(),\n                    .end => state.selectLast(),\n                    else => {},\n                }\n            }\n        },\n        else => {},\n    }\n    return .none;\n}\n\n// Render the UI\nfn view(state: *State, frame: *zithril.Frame(zithril.App(State).DefaultMaxWidgets)) void {\n    const area = frame.size();\n\n    // Outer block with title\n    const block = zithril.Block{\n        .title = \"List Navigation (j/k or arrows, q to quit)\",\n        .border = .rounded,\n        .border_style = zithril.Style.init().fg(.cyan),\n    };\n    frame.render(block, area);\n\n    // Get interior area for the list\n    const inner = block.inner(area);\n    if (inner.isEmpty()) return;\n\n    // Render the list widget\n    const list = zithril.List{\n        .items = state.items,\n        .selected = state.selected,\n        .style = zithril.Style.init().fg(.white),\n        .highlight_style = zithril.Style.init().bg(.blue).fg(.white).bold(),\n        .highlight_symbol = \"> \",\n    };\n    frame.render(list, inner);\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer _ = gpa.deinit();\n    const allocator = gpa.allocator();\n\n    // Sample items for the list\n    const items = [_][]const u8{\n        \"Apple\",\n        \"Banana\",\n        \"Cherry\",\n        \"Date\",\n        \"Elderberry\",\n        \"Fig\",\n        \"Grape\",\n        \"Honeydew\",\n        \"Jackfruit\",\n        \"Kiwi\",\n    };\n\n    var app = zithril.App(State).init(.{\n        .state = .{ .items = &items, .selected = 0 },\n        .update = update,\n        .view = view,\n    });\n\n    try app.run(allocator);\n}\n\n// Use zithril's panic handler to ensure terminal cleanup on abnormal exit\npub const panic = zithril.terminal_panic;\n"
    numLines: 124
    startLine: 1
    totalLines: 124
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01DtWcAf8NAhCQirwU7AwcfY
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01A1Xn7ZMU1R7uS5a1We8b47
      name: Read
      input:
        file_path: /home/hotschmoe/zithril/src/backend.zig
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 13919
    cache_read_input_tokens: 25183
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 13919
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: c4f90e60-83e9-4b30-b7e1-a50a60058210
type: user
message:
  role: user
  content[1]{tool_use_id,type,content}:
    toolu_01A1Xn7ZMU1R7uS5a1We8b47,tool_result,"     1→// Terminal backend for zithril TUI framework\n     2→// Handles raw mode, alternate screen, cursor control, mouse, and bracketed paste\n     3→// Provides buffered output with rich_zig integration for ANSI rendering\n     4→// Includes panic handler to ensure terminal cleanup on abnormal exit\n     5→\n     6→const std = @import(\"std\");\n     7→const posix = std.posix;\n     8→const rich_zig = @import(\"rich_zig\");\n     9→const style_mod = @import(\"style.zig\");\n    10→pub const Style = style_mod.Style;\n    11→pub const Color = style_mod.Color;\n    12→pub const ColorSystem = style_mod.ColorSystem;\n    13→pub const Segment = style_mod.Segment;\n    14→pub const ControlCode = style_mod.ControlCode;\n    15→\n    16→/// Global pointer to the active backend for panic/signal cleanup.\n    17→/// Only one backend can be active at a time (standard for TUI apps).\n    18→var global_backend: ?*Backend = null;\n    19→\n    20→/// Global storage for original termios when using emergency cleanup.\n    21→var emergency_original_termios: ?posix.termios = null;\n    22→var emergency_config: ?BackendConfig = null;\n    23→\n    24→/// Perform emergency terminal cleanup.\n    25→/// Called from panic handler and signal handlers.\n    26→/// Writes cleanup sequences directly to fd without checking state,\n    27→/// as the Backend state may be corrupted during panic.\n    28→fn emergencyCleanup() void {\n    29→    const fd = posix.STDOUT_FILENO;\n    30→    const file = std.fs.File{ .handle = fd };\n    31→\n    32→    // Restore terminal based on saved config\n    33→    if (emergency_config) |config| {\n    34→        if (config.bracketed_paste) {\n    35→            file.writeAll(\"\\x1b[?2004l\") catch {};\n    36→        }\n    37→        if (config.mouse_capture) {\n    38→            file.writeAll(\"\\x1b[?1006l\") catch {};\n    39→            file.writeAll(\"\\x1b[?1003l\\x1b[?1002l\\x1b[?1000l\") catch {};\n    40→        }\n    41→        if (config.hide_cursor) {\n    42→            file.writeAll(\"\\x1b[?25h\") catch {};\n    43→        }\n    44→        if (config.alternate_screen) {\n    45→            file.writeAll(\"\\x1b[?1049l\") catch {};\n    46→        }\n    47→    }\n    48→\n    49→    // Restore termios\n    50→    if (emergency_original_termios) |original| {\n    51→        posix.tcsetattr(fd, .FLUSH, original) catch {};\n    52→    }\n    53→\n    54→    // Clear global state\n    55→    global_backend = null;\n    56→    emergency_original_termios = null;\n    57→    emergency_config = null;\n    58→}\n    59→\n    60→/// Panic handler namespace for terminal cleanup.\n    61→/// Applications can use this by adding to their root source file:\n    62→///   pub const panic = @import(\"zithril\").backend_mod.panic;\n    63→/// This ensures terminal state is restored before panic output is displayed.\n    64→///\n    65→/// The panic namespace matches Zig 0.15's expected interface (std.debug.no_panic).\n    66→pub const panic = struct {\n    67→    /// Core panic function called by @panic and runtime safety checks.\n    68→    pub fn call(msg: []const u8, ret_addr: ?usize) noreturn {\n    69→        @branchHint(.cold);\n    70→        _ = ret_addr;\n    71→\n    72→        // Perform cleanup first so panic message is visible\n    73→        emergencyCleanup();\n    74→\n    75→        // Write error message directly to stderr fd\n    76→        const stderr_fd = std.posix.STDERR_FILENO;\n    77→        const stderr = std.fs.File{ .handle = stderr_fd };\n    78→        stderr.writeAll(msg) catch {};\n    79→        stderr.writeAll(\"\\n\") catch {};\n    80→        @trap();\n    81→    }\n    82→\n    83→    pub fn sentinelMismatch(_: anytype, _: anytype) noreturn {\n    84→        @branchHint(.cold);\n    85→        call(\"sentinel mismatch\", null);\n    86→    }\n    87→\n    88→    pub fn unwrapError(_: anyerror) noreturn {\n    89→        @branchHint(.cold);\n    90→        call(\"attempt to unwrap error\", null);\n    91→    }\n    92→\n    93→    pub fn outOfBounds(_: usize, _: usize) noreturn {\n    94→        @branchHint(.cold);\n    95→        call(\"index out of bounds\", null);\n    96→    }\n    97→\n    98→    pub fn startGreaterThanEnd(_: usize, _: usize) noreturn {\n    99→        @branchHint(.cold);\n   100→        call(\"start index is larger than end index\", null);\n   101→    }\n   102→\n   103→    pub fn inactiveUnionField(_: anytype, _: anytype) noreturn {\n   104→        @branchHint(.cold);\n   105→        call(\"access of inactive union field\", null);\n   106→    }\n   107→\n   108→    pub fn sliceCastLenRemainder(_: usize) noreturn {\n   109→        @branchHint(.cold);\n   110→        call(\"slice cast has len remainder\", null);\n   111→    }\n   112→\n   113→    pub fn reachedUnreachable() noreturn {\n   114→        @branchHint(.cold);\n   115→        call(\"reached unreachable code\", null);\n   116→    }\n   117→\n   118→    pub fn unwrapNull() noreturn {\n   119→        @branchHint(.cold);\n   120→        call(\"unwrap of null optional\", null);\n   121→    }\n   122→\n   123→    pub fn castToNull() noreturn {\n   124→        @branchHint(.cold);\n   125→        call(\"cast to null\", null);\n   126→    }\n   127→\n   128→    pub fn incorrectAlignment() noreturn {\n   129→        @branchHint(.cold);\n   130→        call(\"incorrect alignment\", null);\n   131→    }\n   132→\n   133→    pub fn invalidErrorCode() noreturn {\n   134→        @branchHint(.cold);\n   135→        call(\"invalid error code\", null);\n   136→    }\n   137→\n   138→    pub fn integerOutOfBounds() noreturn {\n   139→        @branchHint(.cold);\n   140→        call(\"integer out of bounds\", null);\n   141→    }\n   142→\n   143→    pub fn integerOverflow() noreturn {\n   144→        @branchHint(.cold);\n   145→        call(\"integer overflow\", null);\n   146→    }\n   147→\n   148→    pub fn shlOverflow() noreturn {\n   149→        @branchHint(.cold);\n   150→        call(\"shift left overflow\", null);\n   151→    }\n   152→\n   153→    pub fn shrOverflow() noreturn {\n   154→        @branchHint(.cold);\n   155→        call(\"shift right overflow\", null);\n   156→    }\n   157→\n   158→    pub fn divideByZero() noreturn {\n   159→        @branchHint(.cold);\n   160→        call(\"division by zero\", null);\n   161→    }\n   162→\n   163→    pub fn exactDivisionRemainder() noreturn {\n   164→        @branchHint(.cold);\n   165→        call(\"exact division has remainder\", null);\n   166→    }\n   167→\n   168→    pub fn integerPartOutOfBounds() noreturn {\n   169→        @branchHint(.cold);\n   170→        call(\"integer part out of bounds\", null);\n   171→    }\n   172→\n   173→    pub fn corruptSwitch() noreturn {\n   174→        @branchHint(.cold);\n   175→        call(\"corrupt switch\", null);\n   176→    }\n   177→\n   178→    pub fn shiftRhsTooBig() noreturn {\n   179→        @branchHint(.cold);\n   180→        call(\"shift rhs too big\", null);\n   181→    }\n   182→\n   183→    pub fn invalidEnumValue() noreturn {\n   184→        @branchHint(.cold);\n   185→        call(\"invalid enum value\", null);\n   186→    }\n   187→\n   188→    pub fn forLenMismatch() noreturn {\n   189→        @branchHint(.cold);\n   190→        call(\"for loop length mismatch\", null);\n   191→    }\n   192→\n   193→    pub fn copyLenMismatch() noreturn {\n   194→        @branchHint(.cold);\n   195→        call(\"copy length mismatch\", null);\n   196→    }\n   197→\n   198→    pub fn memcpyAlias() noreturn {\n   199→        @branchHint(.cold);\n   200→        call(\"memcpy with overlapping memory\", null);\n   201→    }\n   202→\n   203→    pub fn noreturnReturned() noreturn {\n   204→        @branchHint(.cold);\n   205→        call(\"noreturn function returned\", null);\n   206→    }\n   207→};\n   208→\n   209→/// Color support levels detected from terminal capabilities.\n   210→pub const ColorSupport = enum {\n   211→    /// Basic 8/16 colors (standard ANSI).\n   212→    basic,\n   213→    /// 256 color palette (xterm-256color).\n   214→    extended,\n   215→    /// 24-bit true color (RGB).\n   216→    true_color,\n   217→\n   218→    /// Returns the number of colors supported.\n   219→    pub fn colorCount(self: ColorSupport) u32 {\n   220→        return switch (self) {\n   221→            .basic => 16,\n   222→            .extended => 256,\n   223→            .true_color => 16_777_216,\n   224→        };\n   225→    }\n   226→\n   227→    /// Returns true if this support level includes the given level.\n   228→    pub fn supports(self: ColorSupport, level: ColorSupport) bool {\n   229→        return @intFromEnum(self) >= @intFromEnum(level);\n   230→    }\n   231→};\n   232→\n   233→/// Terminal size in cells.\n   234→pub const TerminalSize = struct {\n   235→    width: u16,\n   236→    height: u16,\n   237→};\n   238→\n   239→/// Configuration options for terminal initialization.\n   240→pub const BackendConfig = struct {\n   241→    /// Enter alternate screen buffer (preserves original terminal content).\n   242→    alternate_screen: bool = true,\n   243→    /// Hide cursor during TUI operation.\n   244→    hide_cursor: bool = true,\n   245→    /// Enable mouse event reporting.\n   246→    mouse_capture: bool = false,\n   247→    /// Enable bracketed paste mode (distinguish pasted text from typed).\n   248→    bracketed_paste: bool = false,\n   249→};\n   250→\n   251→/// Terminal backend state.\n   252→/// Manages raw mode, alternate screen, and other terminal features.\n   253→/// RAII pattern: deinit() restores terminal to original state.\n   254→pub const Backend = struct {\n   255→    /// File descriptor for terminal output (typically stdout).\n   256→    fd: posix.fd_t,\n   257→    /// Original terminal settings, saved for restoration.\n   258→    original_termios: ?posix.termios,\n   259→    /// Configuration used during initialization.\n   260→    config: BackendConfig,\n   261→    /// Whether the backend is currently active.\n   262→    active: bool,\n   263→\n   264→    /// Error type for backend operations.\n   265→    pub const Error = error{\n   266→        NotATty,\n   267→        TerminalQueryFailed,\n   268→        TerminalSetFailed,\n   269→        IoError,\n   270→    };\n   271→\n   272→    /// Initialize the terminal backend.\n   273→    /// Enables raw mode and optional features based on config.\n   274→    /// Registers panic handler to ensure cleanup on abnormal exit.\n   275→    /// Returns error if stdout is not a TTY or terminal ops fail.\n   276→    pub fn init(config: BackendConfig) Error!Backend {\n   277→        const fd = posix.STDOUT_FILENO;\n   278→\n   279→        if (!posix.isatty(fd)) {\n   280→            return Error.NotATty;\n   281→        }\n   282→\n   283→        var self = Backend{\n   284→            .fd = fd,\n   285→            .original_termios = null,\n   286→            .config = config,\n   287→            .active = false,\n   288→        };\n   289→\n   290→        try self.enterRawMode();\n   291→        self.active = true;\n   292→\n   293→        // Store state for emergency cleanup\n   294→        emergency_original_termios = self.original_termios;\n   295→        emergency_config = config;\n   296→        global_backend = &self;\n   297→\n   298→        if (config.alternate_screen) {\n   299→            self.writeEscape(ENTER_ALTERNATE_SCREEN);\n   300→        }\n   301→\n   302→        if (config.hide_cursor) {\n   303→            self.writeEscape(HIDE_CURSOR);\n   304→        }\n   305→\n   306→        if (config.mouse_capture) {\n   307→            self.enableMouse();\n   308→        }\n   309→\n   310→        if (config.bracketed_paste) {\n   311→            self.writeEscape(ENABLE_BRACKETED_PASTE);\n   312→        }\n   313→\n   314→        return self;\n   315→    }\n   316→\n   317→    /// Restore terminal to original state.\n   318→    /// Disables bracketed paste, mouse capture, shows cursor, leaves alternate screen,\n   319→    /// and restores raw mode settings.\n   320→    /// Safe to call multiple times.\n   321→    pub fn deinit(self: *Backend) void {\n   322→        if (!self.active) return;\n   323→\n   324→        // Disable bracketed paste\n   325→        if (self.config.bracketed_paste) {\n   326→            self.writeEscape(DISABLE_BRACKETED_PASTE);\n   327→        }\n   328→\n   329→        // Disable mouse capture\n   330→        if (self.config.mouse_capture) {\n   331→            self.disableMouse();\n   332→        }\n   333→\n   334→        // Show cursor\n   335→        if (self.config.hide_cursor) {\n   336→            self.writeEscape(SHOW_CURSOR);\n   337→        }\n   338→\n   339→        // Leave alternate screen\n   340→        if (self.config.alternate_screen) {\n   341→            self.writeEscape(LEAVE_ALTERNATE_SCREEN);\n   342→        }\n   343→\n   344→        // Restore raw mode (disable raw mode)\n   345→        self.exitRawMode();\n   346→        self.active = false;\n   347→\n   348→        // Clear global state for panic handler\n   349→        if (global_backend == self) {\n   350→            global_backend = null;\n   351→            emergency_original_termios = null;\n   352→            emergency_config = null;\n   353→        }\n   354→    }\n   355→\n   356→    /// Enter raw mode: disable line buffering, echo, and canonical mode.\n   357→    fn enterRawMode(self: *Backend) Error!void {\n   358→        const original = posix.tcgetattr(self.fd) catch {\n   359→            return Error.TerminalQueryFailed;\n   360→        };\n   361→        self.original_termios = original;\n   362→\n   363→        var raw = original;\n   364→\n   365→        // Input flags: disable break handling, CR-to-NL, parity, strip, flow control\n   366→        raw.iflag.BRKINT = false;\n   367→        raw.iflag.ICRNL = false;\n   368→        raw.iflag.INPCK = false;\n   369→        raw.iflag.ISTRIP = false;\n   370→        raw.iflag.IXON = false;\n   371→\n   372→        // Output flags: disable post-processing\n   373→        raw.oflag.OPOST = false;\n   374→\n   375→        // Control flags: set character size to 8 bits\n   376→        raw.cflag.CSIZE = .CS8;\n   377→\n   378→        // Local flags: disable echo, canonical mode, signals, extended input\n   379→        raw.lflag.ECHO = false;\n   380→        raw.lflag.ICANON = false;\n   381→        raw.lflag.ISIG = false;\n   382→        raw.lflag.IEXTEN = false;\n   383→\n   384→        // Set minimum chars for non-canonical read\n   385→        raw.cc[@intFromEnum(posix.V.MIN)] = 0;\n   386→        raw.cc[@intFromEnum(posix.V.TIME)] = 1;\n   387→\n   388→        posix.tcsetattr(self.fd, .FLUSH, raw) catch {\n   389→            return Error.TerminalSetFailed;\n   390→        };\n   391→    }\n   392→\n   393→    /// Exit raw mode: restore original terminal settings.\n   394→    fn exitRawMode(self: *Backend) void {\n   395→        if (self.original_termios) |original| {\n   396→            posix.tcsetattr(self.fd, .FLUSH, original) catch {};\n   397→        }\n   398→    }\n   399→\n   400→    /// Enable mouse reporting (SGR mode for better coordinate handling).\n   401→    fn enableMouse(self: *Backend) void {\n   402→        self.writeEscape(ENABLE_MOUSE_CAPTURE);\n   403→        self.writeEscape(ENABLE_MOUSE_SGR);\n   404→    }\n   405→\n   406→    /// Disable mouse reporting.\n   407→    fn disableMouse(self: *Backend) void {\n   408→        self.writeEscape(DISABLE_MOUSE_SGR);\n   409→        self.writeEscape(DISABLE_MOUSE_CAPTURE);\n   410→    }\n   411→\n   412→    /// Write an escape sequence to the terminal.\n   413→    fn writeEscape(self: *Backend, seq: []const u8) void {\n   414→        const file = std.fs.File{ .handle = self.fd };\n   415→        file.writeAll(seq) catch {};\n   416→    }\n   417→\n   418→    /// Flush output to terminal.\n   419→    pub fn flush(self: *Backend) void {\n   420→        const file = std.fs.File{ .handle = self.fd };\n   421→        file.sync() catch {};\n   422→    }\n   423→\n   424→    /// Write bytes to the terminal.\n   425→    pub fn write(self: *Backend, data: []const u8) Error!void {\n   426→        const file = std.fs.File{ .handle = self.fd };\n   427→        file.writeAll(data) catch {\n   428→            return Error.IoError;\n   429→        };\n   430→    }\n   431→\n   432→    /// Move cursor to home position (0, 0).\n   433→    pub fn cursorHome(self: *Backend) void {\n   434→        self.writeEscape(CURSOR_HOME);\n   435→    }\n   436→\n   437→    /// Move cursor to specific position (0-indexed).\n   438→    pub fn cursorTo(self: *Backend, x: u16, y: u16) void {\n   439→        var buf: [32]u8 = undefined;\n   440→        const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d};{d}H\", .{ y + 1, x + 1 }) catch return;\n   441→        self.writeEscape(seq);\n   442→    }\n   443→\n   444→    /// Clear the entire screen.\n   445→    pub fn clearScreen(self: *Backend) void {\n   446→        self.writeEscape(CLEAR_SCREEN);\n   447→    }\n   448→\n   449→    /// Get terminal size (width, height).\n   450→    pub fn getSize(self: *Backend) TerminalSize {\n   451→        return getSizeForFd(self.fd);\n   452→    }\n   453→\n   454→    /// Detect terminal color support level.\n   455→    /// Checks environment variables COLORTERM and TERM to determine capability.\n   456→    /// Returns the highest detected color support level.\n   457→    pub fn getColorSupport(_: *Backend) ColorSupport {\n   458→        return detectColorSupport();\n   459→    }\n   460→\n   461→    // ANSI escape sequences\n   462→    const ENTER_ALTERNATE_SCREEN = \"\\x1b[?1049h\";\n   463→    const LEAVE_ALTERNATE_SCREEN = \"\\x1b[?1049l\";\n   464→    const HIDE_CURSOR = \"\\x1b[?25l\";\n   465→    const SHOW_CURSOR = \"\\x1b[?25h\";\n   466→    const CLEAR_SCREEN = \"\\x1b[2J\";\n   467→    const CURSOR_HOME = \"\\x1b[H\";\n   468→\n   469→    const ENABLE_MOUSE_CAPTURE = \"\\x1b[?1000h\\x1b[?1002h\\x1b[?1003h\";\n   470→    const DISABLE_MOUSE_CAPTURE = \"\\x1b[?1003l\\x1b[?1002l\\x1b[?1000l\";\n   471→    const ENABLE_MOUSE_SGR = \"\\x1b[?1006h\";\n   472→    const DISABLE_MOUSE_SGR = \"\\x1b[?1006l\";\n   473→\n   474→    const ENABLE_BRACKETED_PASTE = \"\\x1b[?2004h\";\n   475→    const DISABLE_BRACKETED_PASTE = \"\\x1b[?2004l\";\n   476→};\n   477→\n   478→/// Detect terminal color support from environment variables.\n   479→/// This is a standalone function that doesn't require a Backend instance.\n   480→/// Checks COLORTERM and TERM environment variables to determine capability.\n   481→pub fn detectColorSupport() ColorSupport {\n   482→    // Check COLORTERM first - most reliable indicator of true color\n   483→    if (std.posix.getenv(\"COLORTERM\")) |colorterm| {\n   484→        if (std.mem.eql(u8, colorterm, \"truecolor\") or std.mem.eql(u8, colorterm, \"24bit\")) {\n   485→            return .true_color;\n   486→        }\n   487→    }\n   488→\n   489→    // Check TERM for terminal type hints\n   490→    if (std.posix.getenv(\"TERM\")) |term| {\n   491→        // True color indicators in TERM\n   492→        if (std.mem.indexOf(u8, term, \"truecolor\") != null or\n   493→            std.mem.indexOf(u8, term, \"24bit\") != null or\n   494→            std.mem.indexOf(u8, term, \"direct\") != null)\n   495→        {\n   496→            return .true_color;\n   497→        }\n   498→\n   499→        // 256 color indicators\n   500→        if (std.mem.indexOf(u8, term, \"256color\") != null or\n   501→            std.mem.indexOf(u8, term, \"256\") != null)\n   502→        {\n   503→            return .extended;\n   504→        }\n   505→\n   506→        // Known modern terminals that support true color\n   507→        if (std.mem.startsWith(u8, term, \"xterm\") or\n   508→            std.mem.startsWith(u8, term, \"screen\") or\n   509→            std.mem.startsWith(u8, term, \"tmux\") or\n   510→            std.mem.startsWith(u8, term, \"vte\") or\n   511→            std.mem.startsWith(u8, term, \"gnome\") or\n   512→            std.mem.startsWith(u8, term, \"konsole\") or\n   513→            std.mem.startsWith(u8, term, \"alacritty\") or\n   514→            std.mem.startsWith(u8, term, \"kitty\") or\n   515→            std.mem.startsWith(u8, term, \"iterm\"))\n   516→        {\n   517→            // These terminals typically support at least 256 colors\n   518→            // Many support true color but we're conservative\n   519→            return .extended;\n   520→        }\n   521→    }\n   522→\n   523→    // Default to basic 16-color support\n   524→    return .basic;\n   525→}\n   526→\n   527→/// Internal: get terminal size for a specific file descriptor.\n   528→fn getSizeForFd(fd: posix.fd_t) TerminalSize {\n   529→    var ws: posix.winsize = undefined;\n   530→    const result = posix.system.ioctl(fd, posix.T.IOCGWINSZ, @intFromPtr(&ws));\n   531→    if (result == 0) {\n   532→        return .{ .width = ws.col, .height = ws.row };\n   533→    }\n   534→    return .{ .width = 80, .height = 24 };\n   535→}\n   536→\n   537→/// Get terminal size without requiring a Backend instance.\n   538→/// Useful for initial configuration before Backend initialization.\n   539→/// Returns default 80x24 if size cannot be determined.\n   540→pub fn getTerminalSize() TerminalSize {\n   541→    return getSizeForFd(posix.STDOUT_FILENO);\n   542→}\n   543→\n   544→/// Buffered terminal output with rich_zig integration.\n   545→/// Accumulates output in a buffer and flushes to the terminal efficiently.\n   546→/// Provides cursor positioning, clearing, and styled text output.\n   547→pub fn Output(comptime buffer_size: usize) type {\n   548→    return struct {\n   549→        const Self = @This();\n   550→\n   551→        /// Internal buffer for accumulating output.\n   552→        buffer: [buffer_size]u8 = undefined,\n   553→        /// Current position in the buffer.\n   554→        pos: usize = 0,\n   555→        /// File descriptor for output.\n   556→        fd: posix.fd_t,\n   557→        /// Detected color system for ANSI rendering.\n   558→        color_system: ColorSystem,\n   559→        /// Last style written (for optimization).\n   560→        last_style: ?Style = null,\n   561→\n   562→        /// Initialize output with detected color support.\n   563→        pub fn init(fd: posix.fd_t) Self {\n   564→            return .{\n   565→                .fd = fd,\n   566→                .color_system = colorSupportToSystem(detectColorSupport()),\n   567→            };\n   568→        }\n   569→\n   570→        /// Initialize output with explicit color system.\n   571→        pub fn initWithColorSystem(fd: posix.fd_t, color_system: ColorSystem) Self {\n   572→            return .{\n   573→                .fd = fd,\n   574→                .color_system = color_system,\n   575→            };\n   576→        }\n   577→\n   578→        /// Write raw bytes to the buffer.\n   579→        pub fn writeRaw(self: *Self, data: []const u8) void {\n   580→            for (data) |byte| {\n   581→                if (self.pos >= buffer_size) {\n   582→                    self.flushInternal();\n   583→                }\n   584→                self.buffer[self.pos] = byte;\n   585→                self.pos += 1;\n   586→            }\n   587→        }\n   588→\n   589→        /// Write a single byte to the buffer.\n   590→        pub fn writeByte(self: *Self, byte: u8) void {\n   591→            if (self.pos >= buffer_size) {\n   592→                self.flushInternal();\n   593→            }\n   594→            self.buffer[self.pos] = byte;\n   595→            self.pos += 1;\n   596→        }\n   597→\n   598→        /// Get a writer interface for use with std.fmt.\n   599→        pub fn writer(self: *Self) std.io.GenericWriter(*Self, error{}, writeFn) {\n   600→            return .{ .context = self };\n   601→        }\n   602→\n   603→        fn writeFn(self: *Self, data: []const u8) error{}!usize {\n   604→            self.writeRaw(data);\n   605→            return data.len;\n   606→        }\n   607→\n   608→        /// Move cursor to home position (0, 0).\n   609→        pub fn cursorHome(self: *Self) void {\n   610→            self.writeRaw(\"\\x1b[H\");\n   611→        }\n   612→\n   613→        /// Move cursor to specific position (0-indexed).\n   614→        pub fn cursorTo(self: *Self, x: u16, y: u16) void {\n   615→            var buf: [32]u8 = undefined;\n   616→            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d};{d}H\", .{ y + 1, x + 1 }) catch return;\n   617→            self.writeRaw(seq);\n   618→        }\n   619→\n   620→        /// Move cursor up by n rows.\n   621→        pub fn cursorUp(self: *Self, n: u16) void {\n   622→            if (n == 0) return;\n   623→            var buf: [16]u8 = undefined;\n   624→            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d}A\", .{n}) catch return;\n   625→            self.writeRaw(seq);\n   626→        }\n   627→\n   628→        /// Move cursor down by n rows.\n   629→        pub fn cursorDown(self: *Self, n: u16) void {\n   630→            if (n == 0) return;\n   631→            var buf: [16]u8 = undefined;\n   632→            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d}B\", .{n}) catch return;\n   633→            self.writeRaw(seq);\n   634→        }\n   635→\n   636→        /// Move cursor forward by n columns.\n   637→        pub fn cursorForward(self: *Self, n: u16) void {\n   638→            if (n == 0) return;\n   639→            var buf: [16]u8 = undefined;\n   640→            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d}C\", .{n}) catch return;\n   641→            self.writeRaw(seq);\n   642→        }\n   643→\n   644→        /// Move cursor backward by n columns.\n   645→        pub fn cursorBackward(self: *Self, n: u16) void {\n   646→            if (n == 0) return;\n   647→            var buf: [16]u8 = undefined;\n   648→            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d}D\", .{n}) catch return;\n   649→            self.writeRaw(seq);\n   650→        }\n   651→\n   652→        /// Clear the entire screen.\n   653→        pub fn clearScreen(self: *Self) void {\n   654→            self.writeRaw(\"\\x1b[2J\");\n   655→        }\n   656→\n   657→        /// Clear from cursor to end of screen.\n   658→        pub fn clearToEndOfScreen(self: *Self) void {\n   659→            self.writeRaw(\"\\x1b[0J\");\n   660→        }\n   661→\n   662→        /// Clear from cursor to start of screen.\n   663→        pub fn clearToStartOfScreen(self: *Self) void {\n   664→            self.writeRaw(\"\\x1b[1J\");\n   665→        }\n   666→\n   667→        /// Clear the current line.\n   668→        pub fn clearLine(self: *Self) void {\n   669→            self.writeRaw(\"\\x1b[2K\");\n   670→        }\n   671→\n   672→        /// Clear from cursor to end of line.\n   673→        pub fn clearToEndOfLine(self: *Self) void {\n   674→            self.writeRaw(\"\\x1b[0K\");\n   675→        }\n   676→\n   677→        /// Clear from cursor to start of line.\n   678→        pub fn clearToStartOfLine(self: *Self) void {\n   679→            self.writeRaw(\"\\x1b[1K\");\n   680→        }\n   681→\n   682→        /// Show the cursor.\n   683→        pub fn showCursor(self: *Self) void {\n   684→            self.writeRaw(\"\\x1b[?25h\");\n   685→        }\n   686→\n   687→        /// Hide the cursor.\n   688→        pub fn hideCursor(self: *Self) void {\n   689→            self.writeRaw(\"\\x1b[?25l\");\n   690→        }\n   691→\n   692→        /// Set the text style using rich_zig ANSI rendering.\n   693→        pub fn setStyle(self: *Self, style: Style) void {\n   694→            // Skip if same as last style\n   695→            if (self.last_style) |last| {\n   696→                if (last.eql(style)) return;\n   697→            }\n   698→\n   699→            style.renderAnsi(self.color_system, self.writer()) catch {};\n   700→            self.last_style = style;\n   701→        }\n   702→\n   703→        /// Reset to default style.\n   704→        pub fn resetStyle(self: *Self) void {\n   705→            self.writeRaw(\"\\x1b[0m\");\n   706→            self.last_style = null;\n   707→        }\n   708→\n   709→        /// Write styled text (sets style, writes text, does not reset).\n   710→        pub fn writeStyled(self: *Self, text: []const u8, style: Style) void {\n   711→            if (!style.isEmpty()) {\n   712→                self.setStyle(style);\n   713→            }\n   714→            self.writeRaw(text);\n   715→        }\n   716→\n   717→        /// Write a character with the given style.\n   718→        pub fn writeChar(self: *Self, char: u21, style: Style) void {\n   719→            if (!style.isEmpty()) {\n   720→                self.setStyle(style);\n   721→            }\n   722→            var utf8_buf: [4]u8 = undefined;\n   723→            const len = std.unicode.utf8Encode(char, &utf8_buf) catch 1;\n   724→            self.writeRaw(utf8_buf[0..len]);\n   725→        }\n   726→\n   727→        /// Write a segment (styled text span from rich_zig).\n   728→        pub fn writeSegment(self: *Self, segment: Segment) void {\n   729→            segment.render(self.writer(), self.color_system) catch {};\n   730→        }\n   731→\n   732→        /// Execute a control code.\n   733→        pub fn writeControl(self: *Self, control: ControlCode) void {\n   734→            control.toEscapeSequence(self.writer()) catch {};\n   735→        }\n   736→\n   737→        /// Flush buffered output to the terminal.\n   738→        pub fn flush(self: *Self) void {\n   739→            self.flushInternal();\n   740→        }\n   741→\n   742→        fn flushInternal(self: *Self) void {\n   743→            if (self.pos == 0) return;\n   744→            const file = std.fs.File{ .handle = self.fd };\n   745→            file.writeAll(self.buffer[0..self.pos]) catch {};\n   746→            self.pos = 0;\n   747→        }\n   748→\n   749→        /// Get remaining buffer capacity.\n   750→        pub fn remaining(self: Self) usize {\n   751→            return buffer_size - self.pos;\n   752→        }\n   753→\n   754→        /// Check if buffer is empty.\n   755→        pub fn isEmpty(self: Self) bool {\n   756→            return self.pos == 0;\n   757→        }\n   758→    };\n   759→}\n   760→\n   761→/// Default output type with 8KB buffer.\n   762→pub const DefaultOutput = Output(8192);\n   763→\n   764→/// Convert ColorSupport enum to rich_zig's ColorSystem.\n   765→pub fn colorSupportToSystem(support: ColorSupport) ColorSystem {\n   766→    return switch (support) {\n   767→        .basic => .standard,\n   768→        .extended => .eight_bit,\n   769→        .true_color => .truecolor,\n   770→    };\n   771→}\n   772→\n   773→// ============================================================\n   774→// SANITY TESTS - Backend configuration\n   775→// ============================================================\n   776→\n   777→test \"sanity: BackendConfig defaults\" {\n   778→    const config = BackendConfig{};\n   779→    try std.testing.expect(config.alternate_screen);\n   780→    try std.testing.expect(config.hide_cursor);\n   781→    try std.testing.expect(!config.mouse_capture);\n   782→    try std.testing.expect(!config.bracketed_paste);\n   783→}\n   784→\n   785→test \"sanity: BackendConfig custom\" {\n   786→    const config = BackendConfig{\n   787→        .alternate_screen = false,\n   788→        .hide_cursor = false,\n   789→        .mouse_capture = true,\n   790→        .bracketed_paste = true,\n   791→    };\n   792→    try std.testing.expect(!config.alternate_screen);\n   793→    try std.testing.expect(!config.hide_cursor);\n   794→    try std.testing.expect(config.mouse_capture);\n   795→    try std.testing.expect(config.bracketed_paste);\n   796→}\n   797→\n   798→// ============================================================\n   799→// BEHAVIOR TESTS - Escape sequences\n   800→// ============================================================\n   801→\n   802→test \"behavior: escape sequences are correct format\" {\n   803→    try std.testing.expectEqualStrings(\"\\x1b[?1049h\", Backend.ENTER_ALTERNATE_SCREEN);\n   804→    try std.testing.expectEqualStrings(\"\\x1b[?1049l\", Backend.LEAVE_ALTERNATE_SCREEN);\n   805→    try std.testing.expectEqualStrings(\"\\x1b[?25l\", Backend.HIDE_CURSOR);\n   806→    try std.testing.expectEqualStrings(\"\\x1b[?25h\", Backend.SHOW_CURSOR);\n   807→    try std.testing.expectEqualStrings(\"\\x1b[2J\", Backend.CLEAR_SCREEN);\n   808→    try std.testing.expectEqualStrings(\"\\x1b[H\", Backend.CURSOR_HOME);\n   809→}\n   810→\n   811→test \"behavior: bracketed paste sequences are correct\" {\n   812→    try std.testing.expectEqualStrings(\"\\x1b[?2004h\", Backend.ENABLE_BRACKETED_PASTE);\n   813→    try std.testing.expectEqualStrings(\"\\x1b[?2004l\", Backend.DISABLE_BRACKETED_PASTE);\n   814→}\n   815→\n   816→test \"behavior: mouse SGR sequences are correct\" {\n   817→    try std.testing.expectEqualStrings(\"\\x1b[?1006h\", Backend.ENABLE_MOUSE_SGR);\n   818→    try std.testing.expectEqualStrings(\"\\x1b[?1006l\", Backend.DISABLE_MOUSE_SGR);\n   819→}\n   820→\n   821→// ============================================================\n   822→// BEHAVIOR TESTS - Cleanup sequences\n   823→// ============================================================\n   824→\n   825→test \"behavior: cleanup sequences in deinit order\" {\n   826→    // deinit should disable features in reverse order of init:\n   827→    // 1. Disable bracketed paste\n   828→    // 2. Disable mouse\n   829→    // 3. Show cursor\n   830→    // 4. Leave alternate screen\n   831→    // 5. Restore termios (raw mode)\n   832→\n   833→    // Verify the escape sequences exist and are correct\n   834→    try std.testing.expectEqualStrings(\"\\x1b[?2004l\", Backend.DISABLE_BRACKETED_PASTE);\n   835→    try std.testing.expectEqualStrings(\"\\x1b[?1006l\", Backend.DISABLE_MOUSE_SGR);\n   836→    try std.testing.expectEqualStrings(\"\\x1b[?1003l\\x1b[?1002l\\x1b[?1000l\", Backend.DISABLE_MOUSE_CAPTURE);\n   837→    try std.testing.expectEqualStrings(\"\\x1b[?25h\", Backend.SHOW_CURSOR);\n   838→    try std.testing.expectEqualStrings(\"\\x1b[?1049l\", Backend.LEAVE_ALTERNATE_SCREEN);\n   839→}\n   840→\n   841→// ============================================================\n   842→// SANITY TESTS - Global state for panic handler\n   843→// ============================================================\n   844→\n   845→test \"sanity: global_backend starts null\" {\n   846→    try std.testing.expect(global_backend == null);\n   847→    try std.testing.expect(emergency_original_termios == null);\n   848→    try std.testing.expect(emergency_config == null);\n   849→}\n   850→\n   851→test \"sanity: emergencyCleanup handles null state\" {\n   852→    // Should not crash when called with no backend registered\n   853→    emergencyCleanup();\n   854→    try std.testing.expect(global_backend == null);\n   855→}\n   856→\n   857→test \"sanity: panic namespace exists with call function\" {\n   858→    // Verify the panic namespace has the correct structure\n   859→    try std.testing.expect(@hasDecl(panic, \"call\"));\n   860→    try std.testing.expect(@hasDecl(panic, \"outOfBounds\"));\n   861→    try std.testing.expect(@hasDecl(panic, \"unwrapError\"));\n   862→}\n   863→\n   864→// ============================================================\n   865→// SANITY TESTS - Color support detection\n   866→// ============================================================\n   867→\n   868→test \"sanity: ColorSupport enum values\" {\n   869→    try std.testing.expect(@intFromEnum(ColorSupport.basic) < @intFromEnum(ColorSupport.extended));\n   870→    try std.testing.expect(@intFromEnum(ColorSupport.extended) < @intFromEnum(ColorSupport.true_color));\n   871→}\n   872→\n   873→test \"sanity: ColorSupport.colorCount returns correct values\" {\n   874→    try std.testing.expectEqual(@as(u32, 16), ColorSupport.basic.colorCount());\n   875→    try std.testing.expectEqual(@as(u32, 256), ColorSupport.extended.colorCount());\n   876→    try std.testing.expectEqual(@as(u32, 16_777_216), ColorSupport.true_color.colorCount());\n   877→}\n   878→\n   879→test \"sanity: ColorSupport.supports comparison\" {\n   880→    // basic supports only basic\n   881→    try std.testing.expect(ColorSupport.basic.supports(.basic));\n   882→    try std.testing.expect(!ColorSupport.basic.supports(.extended));\n   883→    try std.testing.expect(!ColorSupport.basic.supports(.true_color));\n   884→\n   885→    // extended supports basic and extended\n   886→    try std.testing.expect(ColorSupport.extended.supports(.basic));\n   887→    try std.testing.expect(ColorSupport.extended.supports(.extended));\n   888→    try std.testing.expect(!ColorSupport.extended.supports(.true_color));\n   889→\n   890→    // true_color supports all\n   891→    try std.testing.expect(ColorSupport.true_color.supports(.basic));\n   892→    try std.testing.expect(ColorSupport.true_color.supports(.extended));\n   893→    try std.testing.expect(ColorSupport.true_color.supports(.true_color));\n   894→}\n   895→\n   896→test \"behavior: detectColorSupport returns valid enum\" {\n   897→    // Just verify it returns one of the valid enum values without crashing\n   898→    const support = detectColorSupport();\n   899→    try std.testing.expect(support == .basic or support == .extended or support == .true_color);\n   900→}\n   901→\n   902→test \"behavior: getTerminalSize returns reasonable values\" {\n   903→    // Just verify it returns values without crashing\n   904→    // In a non-TTY test environment, it returns default 80x24\n   905→    const size = getTerminalSize();\n   906→    try std.testing.expect(size.width > 0);\n   907→    try std.testing.expect(size.height > 0);\n   908→}\n   909→\n   910→// ============================================================\n   911→// SANITY TESTS - Output buffering\n   912→// ============================================================\n   913→\n   914→test \"sanity: Output buffer initialization\" {\n   915→    const TestOutput = Output(256);\n   916→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   917→    try std.testing.expect(out.isEmpty());\n   918→    try std.testing.expectEqual(@as(usize, 256), out.remaining());\n   919→}\n   920→\n   921→test \"sanity: Output.writeRaw buffers data\" {\n   922→    const TestOutput = Output(256);\n   923→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   924→\n   925→    out.writeRaw(\"Hello\");\n   926→    try std.testing.expect(!out.isEmpty());\n   927→    try std.testing.expectEqual(@as(usize, 251), out.remaining());\n   928→}\n   929→\n   930→test \"sanity: Output.writeByte buffers single byte\" {\n   931→    const TestOutput = Output(256);\n   932→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   933→\n   934→    out.writeByte('X');\n   935→    try std.testing.expectEqual(@as(usize, 255), out.remaining());\n   936→}\n   937→\n   938→// ============================================================\n   939→// BEHAVIOR TESTS - Output cursor control\n   940→// ============================================================\n   941→\n   942→test \"behavior: Output.cursorHome writes correct sequence\" {\n   943→    const TestOutput = Output(256);\n   944→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   945→\n   946→    out.cursorHome();\n   947→    try std.testing.expectEqualStrings(\"\\x1b[H\", out.buffer[0..out.pos]);\n   948→}\n   949→\n   950→test \"behavior: Output.cursorTo writes correct sequence\" {\n   951→    const TestOutput = Output(256);\n   952→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   953→\n   954→    out.cursorTo(5, 10);\n   955→    try std.testing.expectEqualStrings(\"\\x1b[11;6H\", out.buffer[0..out.pos]);\n   956→}\n   957→\n   958→test \"behavior: Output.cursorUp writes correct sequence\" {\n   959→    const TestOutput = Output(256);\n   960→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   961→\n   962→    out.cursorUp(3);\n   963→    try std.testing.expectEqualStrings(\"\\x1b[3A\", out.buffer[0..out.pos]);\n   964→}\n   965→\n   966→test \"behavior: Output.cursorDown writes correct sequence\" {\n   967→    const TestOutput = Output(256);\n   968→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   969→\n   970→    out.cursorDown(5);\n   971→    try std.testing.expectEqualStrings(\"\\x1b[5B\", out.buffer[0..out.pos]);\n   972→}\n   973→\n   974→test \"behavior: Output.cursorForward writes correct sequence\" {\n   975→    const TestOutput = Output(256);\n   976→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   977→\n   978→    out.cursorForward(2);\n   979→    try std.testing.expectEqualStrings(\"\\x1b[2C\", out.buffer[0..out.pos]);\n   980→}\n   981→\n   982→test \"behavior: Output.cursorBackward writes correct sequence\" {\n   983→    const TestOutput = Output(256);\n   984→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   985→\n   986→    out.cursorBackward(4);\n   987→    try std.testing.expectEqualStrings(\"\\x1b[4D\", out.buffer[0..out.pos]);\n   988→}\n   989→\n   990→// ============================================================\n   991→// BEHAVIOR TESTS - Output screen clearing\n   992→// ============================================================\n   993→\n   994→test \"behavior: Output.clearScreen writes correct sequence\" {\n   995→    const TestOutput = Output(256);\n   996→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n   997→\n   998→    out.clearScreen();\n   999→    try std.testing.expectEqualStrings(\"\\x1b[2J\", out.buffer[0..out.pos]);\n  1000→}\n  1001→\n  1002→test \"behavior: Output.clearToEndOfScreen writes correct sequence\" {\n  1003→    const TestOutput = Output(256);\n  1004→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1005→\n  1006→    out.clearToEndOfScreen();\n  1007→    try std.testing.expectEqualStrings(\"\\x1b[0J\", out.buffer[0..out.pos]);\n  1008→}\n  1009→\n  1010→test \"behavior: Output.clearLine writes correct sequence\" {\n  1011→    const TestOutput = Output(256);\n  1012→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1013→\n  1014→    out.clearLine();\n  1015→    try std.testing.expectEqualStrings(\"\\x1b[2K\", out.buffer[0..out.pos]);\n  1016→}\n  1017→\n  1018→test \"behavior: Output.clearToEndOfLine writes correct sequence\" {\n  1019→    const TestOutput = Output(256);\n  1020→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1021→\n  1022→    out.clearToEndOfLine();\n  1023→    try std.testing.expectEqualStrings(\"\\x1b[0K\", out.buffer[0..out.pos]);\n  1024→}\n  1025→\n  1026→// ============================================================\n  1027→// BEHAVIOR TESTS - Output cursor visibility\n  1028→// ============================================================\n  1029→\n  1030→test \"behavior: Output.showCursor writes correct sequence\" {\n  1031→    const TestOutput = Output(256);\n  1032→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1033→\n  1034→    out.showCursor();\n  1035→    try std.testing.expectEqualStrings(\"\\x1b[?25h\", out.buffer[0..out.pos]);\n  1036→}\n  1037→\n  1038→test \"behavior: Output.hideCursor writes correct sequence\" {\n  1039→    const TestOutput = Output(256);\n  1040→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1041→\n  1042→    out.hideCursor();\n  1043→    try std.testing.expectEqualStrings(\"\\x1b[?25l\", out.buffer[0..out.pos]);\n  1044→}\n  1045→\n  1046→// ============================================================\n  1047→// BEHAVIOR TESTS - Output style rendering\n  1048→// ============================================================\n  1049→\n  1050→test \"behavior: Output.setStyle uses rich_zig rendering\" {\n  1051→    const TestOutput = Output(256);\n  1052→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1053→\n  1054→    const style = Style.init().bold().fg(.red);\n  1055→    out.setStyle(style);\n  1056→\n  1057→    const written = out.buffer[0..out.pos];\n  1058→    // Should contain ANSI escape sequence\n  1059→    try std.testing.expect(written[0] == 0x1b);\n  1060→    try std.testing.expect(written[1] == '[');\n  1061→    try std.testing.expect(written[written.len - 1] == 'm');\n  1062→}\n  1063→\n  1064→test \"behavior: Output.resetStyle writes reset sequence\" {\n  1065→    const TestOutput = Output(256);\n  1066→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1067→\n  1068→    out.resetStyle();\n  1069→    try std.testing.expectEqualStrings(\"\\x1b[0m\", out.buffer[0..out.pos]);\n  1070→}\n  1071→\n  1072→test \"behavior: Output.setStyle skips duplicate styles\" {\n  1073→    const TestOutput = Output(256);\n  1074→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1075→\n  1076→    const style = Style.init().bold();\n  1077→    out.setStyle(style);\n  1078→    const first_len = out.pos;\n  1079→\n  1080→    out.setStyle(style);\n  1081→    // Should not write anything new\n  1082→    try std.testing.expectEqual(first_len, out.pos);\n  1083→}\n  1084→\n  1085→test \"behavior: Output.writeStyled combines style and text\" {\n  1086→    const TestOutput = Output(256);\n  1087→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1088→\n  1089→    const style = Style.init().bold();\n  1090→    out.writeStyled(\"Hello\", style);\n  1091→\n  1092→    const written = out.buffer[0..out.pos];\n  1093→    // Should contain the text \"Hello\"\n  1094→    try std.testing.expect(std.mem.indexOf(u8, written, \"Hello\") != null);\n  1095→}\n  1096→\n  1097→test \"behavior: Output.writeChar writes styled character\" {\n  1098→    const TestOutput = Output(256);\n  1099→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1100→\n  1101→    out.writeChar('X', Style.empty);\n  1102→    try std.testing.expectEqualStrings(\"X\", out.buffer[0..out.pos]);\n  1103→}\n  1104→\n  1105→test \"behavior: Output.writeChar handles UTF-8\" {\n  1106→    const TestOutput = Output(256);\n  1107→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1108→\n  1109→    out.writeChar(0x4E2D, Style.empty); // CJK character\n  1110→    try std.testing.expectEqual(@as(usize, 3), out.pos); // 3-byte UTF-8\n  1111→}\n  1112→\n  1113→// ============================================================\n  1114→// BEHAVIOR TESTS - ColorSupport to ColorSystem conversion\n  1115→// ============================================================\n  1116→\n  1117→test \"behavior: colorSupportToSystem conversion\" {\n  1118→    try std.testing.expectEqual(ColorSystem.standard, colorSupportToSystem(.basic));\n  1119→    try std.testing.expectEqual(ColorSystem.eight_bit, colorSupportToSystem(.extended));\n  1120→    try std.testing.expectEqual(ColorSystem.truecolor, colorSupportToSystem(.true_color));\n  1121→}\n  1122→\n  1123→// ============================================================\n  1124→// REGRESSION TESTS - Output edge cases\n  1125→// ============================================================\n  1126→\n  1127→test \"regression: Output.cursorUp with zero does nothing\" {\n  1128→    const TestOutput = Output(256);\n  1129→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1130→\n  1131→    out.cursorUp(0);\n  1132→    try std.testing.expect(out.isEmpty());\n  1133→}\n  1134→\n  1135→test \"regression: Output.cursorDown with zero does nothing\" {\n  1136→    const TestOutput = Output(256);\n  1137→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1138→\n  1139→    out.cursorDown(0);\n  1140→    try std.testing.expect(out.isEmpty());\n  1141→}\n  1142→\n  1143→test \"regression: Output writer interface works with fmt\" {\n  1144→    const TestOutput = Output(256);\n  1145→    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n  1146→\n  1147→    const w = out.writer();\n  1148→    try std.fmt.format(w, \"Value: {d}\", .{42});\n  1149→    try std.testing.expectEqualStrings(\"Value: 42\", out.buffer[0..out.pos]);\n  1150→}\n  1151→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: fbcc7110-2129-4665-a2fe-f4651c286ab3
tool_use_result:
  type: text
  file:
    filePath: /home/hotschmoe/zithril/src/backend.zig
    content: "// Terminal backend for zithril TUI framework\n// Handles raw mode, alternate screen, cursor control, mouse, and bracketed paste\n// Provides buffered output with rich_zig integration for ANSI rendering\n// Includes panic handler to ensure terminal cleanup on abnormal exit\n\nconst std = @import(\"std\");\nconst posix = std.posix;\nconst rich_zig = @import(\"rich_zig\");\nconst style_mod = @import(\"style.zig\");\npub const Style = style_mod.Style;\npub const Color = style_mod.Color;\npub const ColorSystem = style_mod.ColorSystem;\npub const Segment = style_mod.Segment;\npub const ControlCode = style_mod.ControlCode;\n\n/// Global pointer to the active backend for panic/signal cleanup.\n/// Only one backend can be active at a time (standard for TUI apps).\nvar global_backend: ?*Backend = null;\n\n/// Global storage for original termios when using emergency cleanup.\nvar emergency_original_termios: ?posix.termios = null;\nvar emergency_config: ?BackendConfig = null;\n\n/// Perform emergency terminal cleanup.\n/// Called from panic handler and signal handlers.\n/// Writes cleanup sequences directly to fd without checking state,\n/// as the Backend state may be corrupted during panic.\nfn emergencyCleanup() void {\n    const fd = posix.STDOUT_FILENO;\n    const file = std.fs.File{ .handle = fd };\n\n    // Restore terminal based on saved config\n    if (emergency_config) |config| {\n        if (config.bracketed_paste) {\n            file.writeAll(\"\\x1b[?2004l\") catch {};\n        }\n        if (config.mouse_capture) {\n            file.writeAll(\"\\x1b[?1006l\") catch {};\n            file.writeAll(\"\\x1b[?1003l\\x1b[?1002l\\x1b[?1000l\") catch {};\n        }\n        if (config.hide_cursor) {\n            file.writeAll(\"\\x1b[?25h\") catch {};\n        }\n        if (config.alternate_screen) {\n            file.writeAll(\"\\x1b[?1049l\") catch {};\n        }\n    }\n\n    // Restore termios\n    if (emergency_original_termios) |original| {\n        posix.tcsetattr(fd, .FLUSH, original) catch {};\n    }\n\n    // Clear global state\n    global_backend = null;\n    emergency_original_termios = null;\n    emergency_config = null;\n}\n\n/// Panic handler namespace for terminal cleanup.\n/// Applications can use this by adding to their root source file:\n///   pub const panic = @import(\"zithril\").backend_mod.panic;\n/// This ensures terminal state is restored before panic output is displayed.\n///\n/// The panic namespace matches Zig 0.15's expected interface (std.debug.no_panic).\npub const panic = struct {\n    /// Core panic function called by @panic and runtime safety checks.\n    pub fn call(msg: []const u8, ret_addr: ?usize) noreturn {\n        @branchHint(.cold);\n        _ = ret_addr;\n\n        // Perform cleanup first so panic message is visible\n        emergencyCleanup();\n\n        // Write error message directly to stderr fd\n        const stderr_fd = std.posix.STDERR_FILENO;\n        const stderr = std.fs.File{ .handle = stderr_fd };\n        stderr.writeAll(msg) catch {};\n        stderr.writeAll(\"\\n\") catch {};\n        @trap();\n    }\n\n    pub fn sentinelMismatch(_: anytype, _: anytype) noreturn {\n        @branchHint(.cold);\n        call(\"sentinel mismatch\", null);\n    }\n\n    pub fn unwrapError(_: anyerror) noreturn {\n        @branchHint(.cold);\n        call(\"attempt to unwrap error\", null);\n    }\n\n    pub fn outOfBounds(_: usize, _: usize) noreturn {\n        @branchHint(.cold);\n        call(\"index out of bounds\", null);\n    }\n\n    pub fn startGreaterThanEnd(_: usize, _: usize) noreturn {\n        @branchHint(.cold);\n        call(\"start index is larger than end index\", null);\n    }\n\n    pub fn inactiveUnionField(_: anytype, _: anytype) noreturn {\n        @branchHint(.cold);\n        call(\"access of inactive union field\", null);\n    }\n\n    pub fn sliceCastLenRemainder(_: usize) noreturn {\n        @branchHint(.cold);\n        call(\"slice cast has len remainder\", null);\n    }\n\n    pub fn reachedUnreachable() noreturn {\n        @branchHint(.cold);\n        call(\"reached unreachable code\", null);\n    }\n\n    pub fn unwrapNull() noreturn {\n        @branchHint(.cold);\n        call(\"unwrap of null optional\", null);\n    }\n\n    pub fn castToNull() noreturn {\n        @branchHint(.cold);\n        call(\"cast to null\", null);\n    }\n\n    pub fn incorrectAlignment() noreturn {\n        @branchHint(.cold);\n        call(\"incorrect alignment\", null);\n    }\n\n    pub fn invalidErrorCode() noreturn {\n        @branchHint(.cold);\n        call(\"invalid error code\", null);\n    }\n\n    pub fn integerOutOfBounds() noreturn {\n        @branchHint(.cold);\n        call(\"integer out of bounds\", null);\n    }\n\n    pub fn integerOverflow() noreturn {\n        @branchHint(.cold);\n        call(\"integer overflow\", null);\n    }\n\n    pub fn shlOverflow() noreturn {\n        @branchHint(.cold);\n        call(\"shift left overflow\", null);\n    }\n\n    pub fn shrOverflow() noreturn {\n        @branchHint(.cold);\n        call(\"shift right overflow\", null);\n    }\n\n    pub fn divideByZero() noreturn {\n        @branchHint(.cold);\n        call(\"division by zero\", null);\n    }\n\n    pub fn exactDivisionRemainder() noreturn {\n        @branchHint(.cold);\n        call(\"exact division has remainder\", null);\n    }\n\n    pub fn integerPartOutOfBounds() noreturn {\n        @branchHint(.cold);\n        call(\"integer part out of bounds\", null);\n    }\n\n    pub fn corruptSwitch() noreturn {\n        @branchHint(.cold);\n        call(\"corrupt switch\", null);\n    }\n\n    pub fn shiftRhsTooBig() noreturn {\n        @branchHint(.cold);\n        call(\"shift rhs too big\", null);\n    }\n\n    pub fn invalidEnumValue() noreturn {\n        @branchHint(.cold);\n        call(\"invalid enum value\", null);\n    }\n\n    pub fn forLenMismatch() noreturn {\n        @branchHint(.cold);\n        call(\"for loop length mismatch\", null);\n    }\n\n    pub fn copyLenMismatch() noreturn {\n        @branchHint(.cold);\n        call(\"copy length mismatch\", null);\n    }\n\n    pub fn memcpyAlias() noreturn {\n        @branchHint(.cold);\n        call(\"memcpy with overlapping memory\", null);\n    }\n\n    pub fn noreturnReturned() noreturn {\n        @branchHint(.cold);\n        call(\"noreturn function returned\", null);\n    }\n};\n\n/// Color support levels detected from terminal capabilities.\npub const ColorSupport = enum {\n    /// Basic 8/16 colors (standard ANSI).\n    basic,\n    /// 256 color palette (xterm-256color).\n    extended,\n    /// 24-bit true color (RGB).\n    true_color,\n\n    /// Returns the number of colors supported.\n    pub fn colorCount(self: ColorSupport) u32 {\n        return switch (self) {\n            .basic => 16,\n            .extended => 256,\n            .true_color => 16_777_216,\n        };\n    }\n\n    /// Returns true if this support level includes the given level.\n    pub fn supports(self: ColorSupport, level: ColorSupport) bool {\n        return @intFromEnum(self) >= @intFromEnum(level);\n    }\n};\n\n/// Terminal size in cells.\npub const TerminalSize = struct {\n    width: u16,\n    height: u16,\n};\n\n/// Configuration options for terminal initialization.\npub const BackendConfig = struct {\n    /// Enter alternate screen buffer (preserves original terminal content).\n    alternate_screen: bool = true,\n    /// Hide cursor during TUI operation.\n    hide_cursor: bool = true,\n    /// Enable mouse event reporting.\n    mouse_capture: bool = false,\n    /// Enable bracketed paste mode (distinguish pasted text from typed).\n    bracketed_paste: bool = false,\n};\n\n/// Terminal backend state.\n/// Manages raw mode, alternate screen, and other terminal features.\n/// RAII pattern: deinit() restores terminal to original state.\npub const Backend = struct {\n    /// File descriptor for terminal output (typically stdout).\n    fd: posix.fd_t,\n    /// Original terminal settings, saved for restoration.\n    original_termios: ?posix.termios,\n    /// Configuration used during initialization.\n    config: BackendConfig,\n    /// Whether the backend is currently active.\n    active: bool,\n\n    /// Error type for backend operations.\n    pub const Error = error{\n        NotATty,\n        TerminalQueryFailed,\n        TerminalSetFailed,\n        IoError,\n    };\n\n    /// Initialize the terminal backend.\n    /// Enables raw mode and optional features based on config.\n    /// Registers panic handler to ensure cleanup on abnormal exit.\n    /// Returns error if stdout is not a TTY or terminal ops fail.\n    pub fn init(config: BackendConfig) Error!Backend {\n        const fd = posix.STDOUT_FILENO;\n\n        if (!posix.isatty(fd)) {\n            return Error.NotATty;\n        }\n\n        var self = Backend{\n            .fd = fd,\n            .original_termios = null,\n            .config = config,\n            .active = false,\n        };\n\n        try self.enterRawMode();\n        self.active = true;\n\n        // Store state for emergency cleanup\n        emergency_original_termios = self.original_termios;\n        emergency_config = config;\n        global_backend = &self;\n\n        if (config.alternate_screen) {\n            self.writeEscape(ENTER_ALTERNATE_SCREEN);\n        }\n\n        if (config.hide_cursor) {\n            self.writeEscape(HIDE_CURSOR);\n        }\n\n        if (config.mouse_capture) {\n            self.enableMouse();\n        }\n\n        if (config.bracketed_paste) {\n            self.writeEscape(ENABLE_BRACKETED_PASTE);\n        }\n\n        return self;\n    }\n\n    /// Restore terminal to original state.\n    /// Disables bracketed paste, mouse capture, shows cursor, leaves alternate screen,\n    /// and restores raw mode settings.\n    /// Safe to call multiple times.\n    pub fn deinit(self: *Backend) void {\n        if (!self.active) return;\n\n        // Disable bracketed paste\n        if (self.config.bracketed_paste) {\n            self.writeEscape(DISABLE_BRACKETED_PASTE);\n        }\n\n        // Disable mouse capture\n        if (self.config.mouse_capture) {\n            self.disableMouse();\n        }\n\n        // Show cursor\n        if (self.config.hide_cursor) {\n            self.writeEscape(SHOW_CURSOR);\n        }\n\n        // Leave alternate screen\n        if (self.config.alternate_screen) {\n            self.writeEscape(LEAVE_ALTERNATE_SCREEN);\n        }\n\n        // Restore raw mode (disable raw mode)\n        self.exitRawMode();\n        self.active = false;\n\n        // Clear global state for panic handler\n        if (global_backend == self) {\n            global_backend = null;\n            emergency_original_termios = null;\n            emergency_config = null;\n        }\n    }\n\n    /// Enter raw mode: disable line buffering, echo, and canonical mode.\n    fn enterRawMode(self: *Backend) Error!void {\n        const original = posix.tcgetattr(self.fd) catch {\n            return Error.TerminalQueryFailed;\n        };\n        self.original_termios = original;\n\n        var raw = original;\n\n        // Input flags: disable break handling, CR-to-NL, parity, strip, flow control\n        raw.iflag.BRKINT = false;\n        raw.iflag.ICRNL = false;\n        raw.iflag.INPCK = false;\n        raw.iflag.ISTRIP = false;\n        raw.iflag.IXON = false;\n\n        // Output flags: disable post-processing\n        raw.oflag.OPOST = false;\n\n        // Control flags: set character size to 8 bits\n        raw.cflag.CSIZE = .CS8;\n\n        // Local flags: disable echo, canonical mode, signals, extended input\n        raw.lflag.ECHO = false;\n        raw.lflag.ICANON = false;\n        raw.lflag.ISIG = false;\n        raw.lflag.IEXTEN = false;\n\n        // Set minimum chars for non-canonical read\n        raw.cc[@intFromEnum(posix.V.MIN)] = 0;\n        raw.cc[@intFromEnum(posix.V.TIME)] = 1;\n\n        posix.tcsetattr(self.fd, .FLUSH, raw) catch {\n            return Error.TerminalSetFailed;\n        };\n    }\n\n    /// Exit raw mode: restore original terminal settings.\n    fn exitRawMode(self: *Backend) void {\n        if (self.original_termios) |original| {\n            posix.tcsetattr(self.fd, .FLUSH, original) catch {};\n        }\n    }\n\n    /// Enable mouse reporting (SGR mode for better coordinate handling).\n    fn enableMouse(self: *Backend) void {\n        self.writeEscape(ENABLE_MOUSE_CAPTURE);\n        self.writeEscape(ENABLE_MOUSE_SGR);\n    }\n\n    /// Disable mouse reporting.\n    fn disableMouse(self: *Backend) void {\n        self.writeEscape(DISABLE_MOUSE_SGR);\n        self.writeEscape(DISABLE_MOUSE_CAPTURE);\n    }\n\n    /// Write an escape sequence to the terminal.\n    fn writeEscape(self: *Backend, seq: []const u8) void {\n        const file = std.fs.File{ .handle = self.fd };\n        file.writeAll(seq) catch {};\n    }\n\n    /// Flush output to terminal.\n    pub fn flush(self: *Backend) void {\n        const file = std.fs.File{ .handle = self.fd };\n        file.sync() catch {};\n    }\n\n    /// Write bytes to the terminal.\n    pub fn write(self: *Backend, data: []const u8) Error!void {\n        const file = std.fs.File{ .handle = self.fd };\n        file.writeAll(data) catch {\n            return Error.IoError;\n        };\n    }\n\n    /// Move cursor to home position (0, 0).\n    pub fn cursorHome(self: *Backend) void {\n        self.writeEscape(CURSOR_HOME);\n    }\n\n    /// Move cursor to specific position (0-indexed).\n    pub fn cursorTo(self: *Backend, x: u16, y: u16) void {\n        var buf: [32]u8 = undefined;\n        const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d};{d}H\", .{ y + 1, x + 1 }) catch return;\n        self.writeEscape(seq);\n    }\n\n    /// Clear the entire screen.\n    pub fn clearScreen(self: *Backend) void {\n        self.writeEscape(CLEAR_SCREEN);\n    }\n\n    /// Get terminal size (width, height).\n    pub fn getSize(self: *Backend) TerminalSize {\n        return getSizeForFd(self.fd);\n    }\n\n    /// Detect terminal color support level.\n    /// Checks environment variables COLORTERM and TERM to determine capability.\n    /// Returns the highest detected color support level.\n    pub fn getColorSupport(_: *Backend) ColorSupport {\n        return detectColorSupport();\n    }\n\n    // ANSI escape sequences\n    const ENTER_ALTERNATE_SCREEN = \"\\x1b[?1049h\";\n    const LEAVE_ALTERNATE_SCREEN = \"\\x1b[?1049l\";\n    const HIDE_CURSOR = \"\\x1b[?25l\";\n    const SHOW_CURSOR = \"\\x1b[?25h\";\n    const CLEAR_SCREEN = \"\\x1b[2J\";\n    const CURSOR_HOME = \"\\x1b[H\";\n\n    const ENABLE_MOUSE_CAPTURE = \"\\x1b[?1000h\\x1b[?1002h\\x1b[?1003h\";\n    const DISABLE_MOUSE_CAPTURE = \"\\x1b[?1003l\\x1b[?1002l\\x1b[?1000l\";\n    const ENABLE_MOUSE_SGR = \"\\x1b[?1006h\";\n    const DISABLE_MOUSE_SGR = \"\\x1b[?1006l\";\n\n    const ENABLE_BRACKETED_PASTE = \"\\x1b[?2004h\";\n    const DISABLE_BRACKETED_PASTE = \"\\x1b[?2004l\";\n};\n\n/// Detect terminal color support from environment variables.\n/// This is a standalone function that doesn't require a Backend instance.\n/// Checks COLORTERM and TERM environment variables to determine capability.\npub fn detectColorSupport() ColorSupport {\n    // Check COLORTERM first - most reliable indicator of true color\n    if (std.posix.getenv(\"COLORTERM\")) |colorterm| {\n        if (std.mem.eql(u8, colorterm, \"truecolor\") or std.mem.eql(u8, colorterm, \"24bit\")) {\n            return .true_color;\n        }\n    }\n\n    // Check TERM for terminal type hints\n    if (std.posix.getenv(\"TERM\")) |term| {\n        // True color indicators in TERM\n        if (std.mem.indexOf(u8, term, \"truecolor\") != null or\n            std.mem.indexOf(u8, term, \"24bit\") != null or\n            std.mem.indexOf(u8, term, \"direct\") != null)\n        {\n            return .true_color;\n        }\n\n        // 256 color indicators\n        if (std.mem.indexOf(u8, term, \"256color\") != null or\n            std.mem.indexOf(u8, term, \"256\") != null)\n        {\n            return .extended;\n        }\n\n        // Known modern terminals that support true color\n        if (std.mem.startsWith(u8, term, \"xterm\") or\n            std.mem.startsWith(u8, term, \"screen\") or\n            std.mem.startsWith(u8, term, \"tmux\") or\n            std.mem.startsWith(u8, term, \"vte\") or\n            std.mem.startsWith(u8, term, \"gnome\") or\n            std.mem.startsWith(u8, term, \"konsole\") or\n            std.mem.startsWith(u8, term, \"alacritty\") or\n            std.mem.startsWith(u8, term, \"kitty\") or\n            std.mem.startsWith(u8, term, \"iterm\"))\n        {\n            // These terminals typically support at least 256 colors\n            // Many support true color but we're conservative\n            return .extended;\n        }\n    }\n\n    // Default to basic 16-color support\n    return .basic;\n}\n\n/// Internal: get terminal size for a specific file descriptor.\nfn getSizeForFd(fd: posix.fd_t) TerminalSize {\n    var ws: posix.winsize = undefined;\n    const result = posix.system.ioctl(fd, posix.T.IOCGWINSZ, @intFromPtr(&ws));\n    if (result == 0) {\n        return .{ .width = ws.col, .height = ws.row };\n    }\n    return .{ .width = 80, .height = 24 };\n}\n\n/// Get terminal size without requiring a Backend instance.\n/// Useful for initial configuration before Backend initialization.\n/// Returns default 80x24 if size cannot be determined.\npub fn getTerminalSize() TerminalSize {\n    return getSizeForFd(posix.STDOUT_FILENO);\n}\n\n/// Buffered terminal output with rich_zig integration.\n/// Accumulates output in a buffer and flushes to the terminal efficiently.\n/// Provides cursor positioning, clearing, and styled text output.\npub fn Output(comptime buffer_size: usize) type {\n    return struct {\n        const Self = @This();\n\n        /// Internal buffer for accumulating output.\n        buffer: [buffer_size]u8 = undefined,\n        /// Current position in the buffer.\n        pos: usize = 0,\n        /// File descriptor for output.\n        fd: posix.fd_t,\n        /// Detected color system for ANSI rendering.\n        color_system: ColorSystem,\n        /// Last style written (for optimization).\n        last_style: ?Style = null,\n\n        /// Initialize output with detected color support.\n        pub fn init(fd: posix.fd_t) Self {\n            return .{\n                .fd = fd,\n                .color_system = colorSupportToSystem(detectColorSupport()),\n            };\n        }\n\n        /// Initialize output with explicit color system.\n        pub fn initWithColorSystem(fd: posix.fd_t, color_system: ColorSystem) Self {\n            return .{\n                .fd = fd,\n                .color_system = color_system,\n            };\n        }\n\n        /// Write raw bytes to the buffer.\n        pub fn writeRaw(self: *Self, data: []const u8) void {\n            for (data) |byte| {\n                if (self.pos >= buffer_size) {\n                    self.flushInternal();\n                }\n                self.buffer[self.pos] = byte;\n                self.pos += 1;\n            }\n        }\n\n        /// Write a single byte to the buffer.\n        pub fn writeByte(self: *Self, byte: u8) void {\n            if (self.pos >= buffer_size) {\n                self.flushInternal();\n            }\n            self.buffer[self.pos] = byte;\n            self.pos += 1;\n        }\n\n        /// Get a writer interface for use with std.fmt.\n        pub fn writer(self: *Self) std.io.GenericWriter(*Self, error{}, writeFn) {\n            return .{ .context = self };\n        }\n\n        fn writeFn(self: *Self, data: []const u8) error{}!usize {\n            self.writeRaw(data);\n            return data.len;\n        }\n\n        /// Move cursor to home position (0, 0).\n        pub fn cursorHome(self: *Self) void {\n            self.writeRaw(\"\\x1b[H\");\n        }\n\n        /// Move cursor to specific position (0-indexed).\n        pub fn cursorTo(self: *Self, x: u16, y: u16) void {\n            var buf: [32]u8 = undefined;\n            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d};{d}H\", .{ y + 1, x + 1 }) catch return;\n            self.writeRaw(seq);\n        }\n\n        /// Move cursor up by n rows.\n        pub fn cursorUp(self: *Self, n: u16) void {\n            if (n == 0) return;\n            var buf: [16]u8 = undefined;\n            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d}A\", .{n}) catch return;\n            self.writeRaw(seq);\n        }\n\n        /// Move cursor down by n rows.\n        pub fn cursorDown(self: *Self, n: u16) void {\n            if (n == 0) return;\n            var buf: [16]u8 = undefined;\n            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d}B\", .{n}) catch return;\n            self.writeRaw(seq);\n        }\n\n        /// Move cursor forward by n columns.\n        pub fn cursorForward(self: *Self, n: u16) void {\n            if (n == 0) return;\n            var buf: [16]u8 = undefined;\n            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d}C\", .{n}) catch return;\n            self.writeRaw(seq);\n        }\n\n        /// Move cursor backward by n columns.\n        pub fn cursorBackward(self: *Self, n: u16) void {\n            if (n == 0) return;\n            var buf: [16]u8 = undefined;\n            const seq = std.fmt.bufPrint(&buf, \"\\x1b[{d}D\", .{n}) catch return;\n            self.writeRaw(seq);\n        }\n\n        /// Clear the entire screen.\n        pub fn clearScreen(self: *Self) void {\n            self.writeRaw(\"\\x1b[2J\");\n        }\n\n        /// Clear from cursor to end of screen.\n        pub fn clearToEndOfScreen(self: *Self) void {\n            self.writeRaw(\"\\x1b[0J\");\n        }\n\n        /// Clear from cursor to start of screen.\n        pub fn clearToStartOfScreen(self: *Self) void {\n            self.writeRaw(\"\\x1b[1J\");\n        }\n\n        /// Clear the current line.\n        pub fn clearLine(self: *Self) void {\n            self.writeRaw(\"\\x1b[2K\");\n        }\n\n        /// Clear from cursor to end of line.\n        pub fn clearToEndOfLine(self: *Self) void {\n            self.writeRaw(\"\\x1b[0K\");\n        }\n\n        /// Clear from cursor to start of line.\n        pub fn clearToStartOfLine(self: *Self) void {\n            self.writeRaw(\"\\x1b[1K\");\n        }\n\n        /// Show the cursor.\n        pub fn showCursor(self: *Self) void {\n            self.writeRaw(\"\\x1b[?25h\");\n        }\n\n        /// Hide the cursor.\n        pub fn hideCursor(self: *Self) void {\n            self.writeRaw(\"\\x1b[?25l\");\n        }\n\n        /// Set the text style using rich_zig ANSI rendering.\n        pub fn setStyle(self: *Self, style: Style) void {\n            // Skip if same as last style\n            if (self.last_style) |last| {\n                if (last.eql(style)) return;\n            }\n\n            style.renderAnsi(self.color_system, self.writer()) catch {};\n            self.last_style = style;\n        }\n\n        /// Reset to default style.\n        pub fn resetStyle(self: *Self) void {\n            self.writeRaw(\"\\x1b[0m\");\n            self.last_style = null;\n        }\n\n        /// Write styled text (sets style, writes text, does not reset).\n        pub fn writeStyled(self: *Self, text: []const u8, style: Style) void {\n            if (!style.isEmpty()) {\n                self.setStyle(style);\n            }\n            self.writeRaw(text);\n        }\n\n        /// Write a character with the given style.\n        pub fn writeChar(self: *Self, char: u21, style: Style) void {\n            if (!style.isEmpty()) {\n                self.setStyle(style);\n            }\n            var utf8_buf: [4]u8 = undefined;\n            const len = std.unicode.utf8Encode(char, &utf8_buf) catch 1;\n            self.writeRaw(utf8_buf[0..len]);\n        }\n\n        /// Write a segment (styled text span from rich_zig).\n        pub fn writeSegment(self: *Self, segment: Segment) void {\n            segment.render(self.writer(), self.color_system) catch {};\n        }\n\n        /// Execute a control code.\n        pub fn writeControl(self: *Self, control: ControlCode) void {\n            control.toEscapeSequence(self.writer()) catch {};\n        }\n\n        /// Flush buffered output to the terminal.\n        pub fn flush(self: *Self) void {\n            self.flushInternal();\n        }\n\n        fn flushInternal(self: *Self) void {\n            if (self.pos == 0) return;\n            const file = std.fs.File{ .handle = self.fd };\n            file.writeAll(self.buffer[0..self.pos]) catch {};\n            self.pos = 0;\n        }\n\n        /// Get remaining buffer capacity.\n        pub fn remaining(self: Self) usize {\n            return buffer_size - self.pos;\n        }\n\n        /// Check if buffer is empty.\n        pub fn isEmpty(self: Self) bool {\n            return self.pos == 0;\n        }\n    };\n}\n\n/// Default output type with 8KB buffer.\npub const DefaultOutput = Output(8192);\n\n/// Convert ColorSupport enum to rich_zig's ColorSystem.\npub fn colorSupportToSystem(support: ColorSupport) ColorSystem {\n    return switch (support) {\n        .basic => .standard,\n        .extended => .eight_bit,\n        .true_color => .truecolor,\n    };\n}\n\n// ============================================================\n// SANITY TESTS - Backend configuration\n// ============================================================\n\ntest \"sanity: BackendConfig defaults\" {\n    const config = BackendConfig{};\n    try std.testing.expect(config.alternate_screen);\n    try std.testing.expect(config.hide_cursor);\n    try std.testing.expect(!config.mouse_capture);\n    try std.testing.expect(!config.bracketed_paste);\n}\n\ntest \"sanity: BackendConfig custom\" {\n    const config = BackendConfig{\n        .alternate_screen = false,\n        .hide_cursor = false,\n        .mouse_capture = true,\n        .bracketed_paste = true,\n    };\n    try std.testing.expect(!config.alternate_screen);\n    try std.testing.expect(!config.hide_cursor);\n    try std.testing.expect(config.mouse_capture);\n    try std.testing.expect(config.bracketed_paste);\n}\n\n// ============================================================\n// BEHAVIOR TESTS - Escape sequences\n// ============================================================\n\ntest \"behavior: escape sequences are correct format\" {\n    try std.testing.expectEqualStrings(\"\\x1b[?1049h\", Backend.ENTER_ALTERNATE_SCREEN);\n    try std.testing.expectEqualStrings(\"\\x1b[?1049l\", Backend.LEAVE_ALTERNATE_SCREEN);\n    try std.testing.expectEqualStrings(\"\\x1b[?25l\", Backend.HIDE_CURSOR);\n    try std.testing.expectEqualStrings(\"\\x1b[?25h\", Backend.SHOW_CURSOR);\n    try std.testing.expectEqualStrings(\"\\x1b[2J\", Backend.CLEAR_SCREEN);\n    try std.testing.expectEqualStrings(\"\\x1b[H\", Backend.CURSOR_HOME);\n}\n\ntest \"behavior: bracketed paste sequences are correct\" {\n    try std.testing.expectEqualStrings(\"\\x1b[?2004h\", Backend.ENABLE_BRACKETED_PASTE);\n    try std.testing.expectEqualStrings(\"\\x1b[?2004l\", Backend.DISABLE_BRACKETED_PASTE);\n}\n\ntest \"behavior: mouse SGR sequences are correct\" {\n    try std.testing.expectEqualStrings(\"\\x1b[?1006h\", Backend.ENABLE_MOUSE_SGR);\n    try std.testing.expectEqualStrings(\"\\x1b[?1006l\", Backend.DISABLE_MOUSE_SGR);\n}\n\n// ============================================================\n// BEHAVIOR TESTS - Cleanup sequences\n// ============================================================\n\ntest \"behavior: cleanup sequences in deinit order\" {\n    // deinit should disable features in reverse order of init:\n    // 1. Disable bracketed paste\n    // 2. Disable mouse\n    // 3. Show cursor\n    // 4. Leave alternate screen\n    // 5. Restore termios (raw mode)\n\n    // Verify the escape sequences exist and are correct\n    try std.testing.expectEqualStrings(\"\\x1b[?2004l\", Backend.DISABLE_BRACKETED_PASTE);\n    try std.testing.expectEqualStrings(\"\\x1b[?1006l\", Backend.DISABLE_MOUSE_SGR);\n    try std.testing.expectEqualStrings(\"\\x1b[?1003l\\x1b[?1002l\\x1b[?1000l\", Backend.DISABLE_MOUSE_CAPTURE);\n    try std.testing.expectEqualStrings(\"\\x1b[?25h\", Backend.SHOW_CURSOR);\n    try std.testing.expectEqualStrings(\"\\x1b[?1049l\", Backend.LEAVE_ALTERNATE_SCREEN);\n}\n\n// ============================================================\n// SANITY TESTS - Global state for panic handler\n// ============================================================\n\ntest \"sanity: global_backend starts null\" {\n    try std.testing.expect(global_backend == null);\n    try std.testing.expect(emergency_original_termios == null);\n    try std.testing.expect(emergency_config == null);\n}\n\ntest \"sanity: emergencyCleanup handles null state\" {\n    // Should not crash when called with no backend registered\n    emergencyCleanup();\n    try std.testing.expect(global_backend == null);\n}\n\ntest \"sanity: panic namespace exists with call function\" {\n    // Verify the panic namespace has the correct structure\n    try std.testing.expect(@hasDecl(panic, \"call\"));\n    try std.testing.expect(@hasDecl(panic, \"outOfBounds\"));\n    try std.testing.expect(@hasDecl(panic, \"unwrapError\"));\n}\n\n// ============================================================\n// SANITY TESTS - Color support detection\n// ============================================================\n\ntest \"sanity: ColorSupport enum values\" {\n    try std.testing.expect(@intFromEnum(ColorSupport.basic) < @intFromEnum(ColorSupport.extended));\n    try std.testing.expect(@intFromEnum(ColorSupport.extended) < @intFromEnum(ColorSupport.true_color));\n}\n\ntest \"sanity: ColorSupport.colorCount returns correct values\" {\n    try std.testing.expectEqual(@as(u32, 16), ColorSupport.basic.colorCount());\n    try std.testing.expectEqual(@as(u32, 256), ColorSupport.extended.colorCount());\n    try std.testing.expectEqual(@as(u32, 16_777_216), ColorSupport.true_color.colorCount());\n}\n\ntest \"sanity: ColorSupport.supports comparison\" {\n    // basic supports only basic\n    try std.testing.expect(ColorSupport.basic.supports(.basic));\n    try std.testing.expect(!ColorSupport.basic.supports(.extended));\n    try std.testing.expect(!ColorSupport.basic.supports(.true_color));\n\n    // extended supports basic and extended\n    try std.testing.expect(ColorSupport.extended.supports(.basic));\n    try std.testing.expect(ColorSupport.extended.supports(.extended));\n    try std.testing.expect(!ColorSupport.extended.supports(.true_color));\n\n    // true_color supports all\n    try std.testing.expect(ColorSupport.true_color.supports(.basic));\n    try std.testing.expect(ColorSupport.true_color.supports(.extended));\n    try std.testing.expect(ColorSupport.true_color.supports(.true_color));\n}\n\ntest \"behavior: detectColorSupport returns valid enum\" {\n    // Just verify it returns one of the valid enum values without crashing\n    const support = detectColorSupport();\n    try std.testing.expect(support == .basic or support == .extended or support == .true_color);\n}\n\ntest \"behavior: getTerminalSize returns reasonable values\" {\n    // Just verify it returns values without crashing\n    // In a non-TTY test environment, it returns default 80x24\n    const size = getTerminalSize();\n    try std.testing.expect(size.width > 0);\n    try std.testing.expect(size.height > 0);\n}\n\n// ============================================================\n// SANITY TESTS - Output buffering\n// ============================================================\n\ntest \"sanity: Output buffer initialization\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n    try std.testing.expect(out.isEmpty());\n    try std.testing.expectEqual(@as(usize, 256), out.remaining());\n}\n\ntest \"sanity: Output.writeRaw buffers data\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.writeRaw(\"Hello\");\n    try std.testing.expect(!out.isEmpty());\n    try std.testing.expectEqual(@as(usize, 251), out.remaining());\n}\n\ntest \"sanity: Output.writeByte buffers single byte\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.writeByte('X');\n    try std.testing.expectEqual(@as(usize, 255), out.remaining());\n}\n\n// ============================================================\n// BEHAVIOR TESTS - Output cursor control\n// ============================================================\n\ntest \"behavior: Output.cursorHome writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.cursorHome();\n    try std.testing.expectEqualStrings(\"\\x1b[H\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.cursorTo writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.cursorTo(5, 10);\n    try std.testing.expectEqualStrings(\"\\x1b[11;6H\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.cursorUp writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.cursorUp(3);\n    try std.testing.expectEqualStrings(\"\\x1b[3A\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.cursorDown writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.cursorDown(5);\n    try std.testing.expectEqualStrings(\"\\x1b[5B\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.cursorForward writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.cursorForward(2);\n    try std.testing.expectEqualStrings(\"\\x1b[2C\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.cursorBackward writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.cursorBackward(4);\n    try std.testing.expectEqualStrings(\"\\x1b[4D\", out.buffer[0..out.pos]);\n}\n\n// ============================================================\n// BEHAVIOR TESTS - Output screen clearing\n// ============================================================\n\ntest \"behavior: Output.clearScreen writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.clearScreen();\n    try std.testing.expectEqualStrings(\"\\x1b[2J\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.clearToEndOfScreen writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.clearToEndOfScreen();\n    try std.testing.expectEqualStrings(\"\\x1b[0J\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.clearLine writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.clearLine();\n    try std.testing.expectEqualStrings(\"\\x1b[2K\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.clearToEndOfLine writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.clearToEndOfLine();\n    try std.testing.expectEqualStrings(\"\\x1b[0K\", out.buffer[0..out.pos]);\n}\n\n// ============================================================\n// BEHAVIOR TESTS - Output cursor visibility\n// ============================================================\n\ntest \"behavior: Output.showCursor writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.showCursor();\n    try std.testing.expectEqualStrings(\"\\x1b[?25h\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.hideCursor writes correct sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.hideCursor();\n    try std.testing.expectEqualStrings(\"\\x1b[?25l\", out.buffer[0..out.pos]);\n}\n\n// ============================================================\n// BEHAVIOR TESTS - Output style rendering\n// ============================================================\n\ntest \"behavior: Output.setStyle uses rich_zig rendering\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    const style = Style.init().bold().fg(.red);\n    out.setStyle(style);\n\n    const written = out.buffer[0..out.pos];\n    // Should contain ANSI escape sequence\n    try std.testing.expect(written[0] == 0x1b);\n    try std.testing.expect(written[1] == '[');\n    try std.testing.expect(written[written.len - 1] == 'm');\n}\n\ntest \"behavior: Output.resetStyle writes reset sequence\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.resetStyle();\n    try std.testing.expectEqualStrings(\"\\x1b[0m\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.setStyle skips duplicate styles\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    const style = Style.init().bold();\n    out.setStyle(style);\n    const first_len = out.pos;\n\n    out.setStyle(style);\n    // Should not write anything new\n    try std.testing.expectEqual(first_len, out.pos);\n}\n\ntest \"behavior: Output.writeStyled combines style and text\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    const style = Style.init().bold();\n    out.writeStyled(\"Hello\", style);\n\n    const written = out.buffer[0..out.pos];\n    // Should contain the text \"Hello\"\n    try std.testing.expect(std.mem.indexOf(u8, written, \"Hello\") != null);\n}\n\ntest \"behavior: Output.writeChar writes styled character\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.writeChar('X', Style.empty);\n    try std.testing.expectEqualStrings(\"X\", out.buffer[0..out.pos]);\n}\n\ntest \"behavior: Output.writeChar handles UTF-8\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.writeChar(0x4E2D, Style.empty); // CJK character\n    try std.testing.expectEqual(@as(usize, 3), out.pos); // 3-byte UTF-8\n}\n\n// ============================================================\n// BEHAVIOR TESTS - ColorSupport to ColorSystem conversion\n// ============================================================\n\ntest \"behavior: colorSupportToSystem conversion\" {\n    try std.testing.expectEqual(ColorSystem.standard, colorSupportToSystem(.basic));\n    try std.testing.expectEqual(ColorSystem.eight_bit, colorSupportToSystem(.extended));\n    try std.testing.expectEqual(ColorSystem.truecolor, colorSupportToSystem(.true_color));\n}\n\n// ============================================================\n// REGRESSION TESTS - Output edge cases\n// ============================================================\n\ntest \"regression: Output.cursorUp with zero does nothing\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.cursorUp(0);\n    try std.testing.expect(out.isEmpty());\n}\n\ntest \"regression: Output.cursorDown with zero does nothing\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    out.cursorDown(0);\n    try std.testing.expect(out.isEmpty());\n}\n\ntest \"regression: Output writer interface works with fmt\" {\n    const TestOutput = Output(256);\n    var out = TestOutput.initWithColorSystem(posix.STDOUT_FILENO, .truecolor);\n\n    const w = out.writer();\n    try std.fmt.format(w, \"Value: {d}\", .{42});\n    try std.testing.expectEqualStrings(\"Value: 42\", out.buffer[0..out.pos]);\n}\n"
    numLines: 1151
    startLine: 1
    totalLines: 1151
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01DtWcAf8NAhCQirwU7AwcfY
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_017uyY3XAg6kWmktMXgybkCz
      name: Read
      input:
        file_path: /home/hotschmoe/zithril/src/widgets/paragraph.zig
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 13919
    cache_read_input_tokens: 25183
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 13919
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: cabbd435-e499-4f33-a2db-47a464473b27
type: user
message:
  role: user
  content[1]{tool_use_id,type,content}:
    toolu_017uyY3XAg6kWmktMXgybkCz,tool_result,"     1→// Paragraph widget for zithril TUI framework\n     2→// Multi-line text with wrapping and alignment\n     3→\n     4→const std = @import(\"std\");\n     5→const buffer_mod = @import(\"../buffer.zig\");\n     6→const geometry = @import(\"../geometry.zig\");\n     7→const style_mod = @import(\"../style.zig\");\n     8→\n     9→pub const Buffer = buffer_mod.Buffer;\n    10→pub const Rect = geometry.Rect;\n    11→pub const Style = style_mod.Style;\n    12→\n    13→/// Text wrapping modes\n    14→pub const Wrap = enum {\n    15→    /// No wrapping, clip at boundary\n    16→    none,\n    17→    /// Wrap at any character position\n    18→    char,\n    19→    /// Wrap at word boundaries (spaces)\n    20→    word,\n    21→};\n    22→\n    23→/// Text alignment options\n    24→pub const Alignment = enum {\n    25→    left,\n    26→    center,\n    27→    right,\n    28→};\n    29→\n    30→/// Multi-line text widget with optional wrapping.\n    31→///\n    32→/// Renders text content across multiple lines with configurable wrapping\n    33→/// behavior and alignment. Lines beyond the area height are not rendered.\n    34→pub const Paragraph = struct {\n    35→    /// The text content to display\n    36→    text: []const u8,\n    37→\n    38→    /// Style applied to the text\n    39→    style: Style = Style.empty,\n    40→\n    41→    /// Text wrapping mode\n    42→    wrap: Wrap = .none,\n    43→\n    44→    /// Text alignment within each line\n    45→    alignment: Alignment = .left,\n    46→\n    47→    /// Render the paragraph into the buffer at the given area.\n    48→    /// Text is split into lines (either by newlines or wrapping) and rendered\n    49→    /// until the area height is filled.\n    50→    pub fn render(self: Paragraph, area: Rect, buf: *Buffer) void {\n    51→        if (area.isEmpty()) return;\n    52→        if (self.text.len == 0) return;\n    53→\n    54→        var y = area.y;\n    55→        const max_y = area.bottom();\n    56→\n    57→        // Process text line by line (split by newlines first)\n    58→        var line_iter = std.mem.splitScalar(u8, self.text, '\\n');\n    59→        while (line_iter.next()) |logical_line| {\n    60→            if (y >= max_y) break;\n    61→\n    62→            // Apply wrapping to this logical line\n    63→            switch (self.wrap) {\n    64→                .none => {\n    65→                    self.renderLine(logical_line, area.x, y, area.width, buf);\n    66→                    y += 1;\n    67→                },\n    68→                .char => {\n    69→                    var remaining = logical_line;\n    70→                    while (remaining.len > 0 and y < max_y) {\n    71→                        const chunk_len = @min(remaining.len, area.width);\n    72→                        const chunk = remaining[0..chunk_len];\n    73→                        self.renderLine(chunk, area.x, y, area.width, buf);\n    74→                        remaining = remaining[chunk_len..];\n    75→                        y += 1;\n    76→                    }\n    77→                    // Empty line should still take a row\n    78→                    if (logical_line.len == 0) {\n    79→                        y += 1;\n    80→                    }\n    81→                },\n    82→                .word => {\n    83→                    if (logical_line.len == 0) {\n    84→                        y += 1;\n    85→                        continue;\n    86→                    }\n    87→                    var line_start: usize = 0;\n    88→                    while (line_start < logical_line.len and y < max_y) {\n    89→                        const wrap_end = findWordWrapEnd(logical_line[line_start..], area.width);\n    90→                        const line = logical_line[line_start .. line_start + wrap_end];\n    91→                        self.renderLine(line, area.x, y, area.width, buf);\n    92→                        line_start += wrap_end;\n    93→                        // Skip leading spaces on next line\n    94→                        while (line_start < logical_line.len and logical_line[line_start] == ' ') {\n    95→                            line_start += 1;\n    96→                        }\n    97→                        y += 1;\n    98→                    }\n    99→                },\n   100→            }\n   101→        }\n   102→    }\n   103→\n   104→    /// Render a single line of text with alignment\n   105→    fn renderLine(self: Paragraph, line: []const u8, x: u16, y: u16, width: u16, buf: *Buffer) void {\n   106→        if (line.len == 0) return;\n   107→\n   108→        const text_len = textDisplayWidth(line);\n   109→        const visible_len = @min(text_len, width);\n   110→\n   111→        if (visible_len == 0) return;\n   112→\n   113→        const x_offset: u16 = switch (self.alignment) {\n   114→            .left => 0,\n   115→            .center => (width -| visible_len) / 2,\n   116→            .right => width -| visible_len,\n   117→        };\n   118→\n   119→        buf.setString(x +| x_offset, y, line, self.style);\n   120→    }\n   121→};\n   122→\n   123→/// Find the end index for word wrapping within a max width.\n   124→/// Returns the number of characters to include on this line.\n   125→fn findWordWrapEnd(text: []const u8, max_width: u16) usize {\n   126→    if (text.len == 0) return 0;\n   127→\n   128→    const width: usize = @intCast(max_width);\n   129→    if (text.len <= width) return text.len;\n   130→\n   131→    // Find the last space within the width limit\n   132→    var last_space: ?usize = null;\n   133→    for (0..width) |i| {\n   134→        if (text[i] == ' ') {\n   135→            last_space = i;\n   136→        }\n   137→    }\n   138→\n   139→    // If we found a space, wrap there (include the space in this line)\n   140→    if (last_space) |space_pos| {\n   141→        // Return position including the space, so next line starts after it\n   142→        return space_pos + 1;\n   143→    }\n   144→\n   145→    // No space found - break at max width (hard wrap)\n   146→    return width;\n   147→}\n   148→\n   149→/// Calculate the display width of a string (counting grapheme columns).\n   150→/// Simple implementation: counts codepoints, treating wide chars as width 2.\n   151→fn textDisplayWidth(str: []const u8) u16 {\n   152→    var width: u16 = 0;\n   153→    var iter = std.unicode.Utf8View.initUnchecked(str).iterator();\n   154→    while (iter.nextCodepoint()) |cp| {\n   155→        width +|= if (isWideCodepoint(cp)) 2 else 1;\n   156→    }\n   157→    return width;\n   158→}\n   159→\n   160→/// Check if a codepoint is a wide character (CJK, etc.)\n   161→fn isWideCodepoint(cp: u21) bool {\n   162→    return (cp >= 0x4E00 and cp <= 0x9FFF) or // CJK Unified Ideographs\n   163→        (cp >= 0x3400 and cp <= 0x4DBF) or // CJK Extension A\n   164→        (cp >= 0x20000 and cp <= 0x2A6DF) or // CJK Extension B\n   165→        (cp >= 0xF900 and cp <= 0xFAFF) or // CJK Compatibility\n   166→        (cp >= 0xFF00 and cp <= 0xFF60) or // Fullwidth forms\n   167→        (cp >= 0xFFE0 and cp <= 0xFFE6) or // Fullwidth symbols\n   168→        (cp >= 0x3000 and cp <= 0x303F) or // CJK Punctuation\n   169→        (cp >= 0x1100 and cp <= 0x11FF); // Hangul Jamo\n   170→}\n   171→\n   172→// ============================================================\n   173→// SANITY TESTS - Basic Paragraph functionality\n   174→// ============================================================\n   175→\n   176→test \"sanity: Paragraph with default values\" {\n   177→    const para = Paragraph{ .text = \"Hello\\nWorld\" };\n   178→    try std.testing.expectEqualStrings(\"Hello\\nWorld\", para.text);\n   179→    try std.testing.expect(para.style.isEmpty());\n   180→    try std.testing.expect(para.wrap == .none);\n   181→    try std.testing.expect(para.alignment == .left);\n   182→}\n   183→\n   184→test \"sanity: Paragraph with custom style\" {\n   185→    const para = Paragraph{\n   186→        .text = \"Styled\",\n   187→        .style = Style.init().bold().fg(.red),\n   188→    };\n   189→    try std.testing.expect(para.style.hasAttribute(.bold));\n   190→}\n   191→\n   192→test \"sanity: Paragraph with wrap modes\" {\n   193→    const none_wrap = Paragraph{ .text = \"T\", .wrap = .none };\n   194→    const char_wrap = Paragraph{ .text = \"T\", .wrap = .char };\n   195→    const word_wrap = Paragraph{ .text = \"T\", .wrap = .word };\n   196→\n   197→    try std.testing.expect(none_wrap.wrap == .none);\n   198→    try std.testing.expect(char_wrap.wrap == .char);\n   199→    try std.testing.expect(word_wrap.wrap == .word);\n   200→}\n   201→\n   202→test \"sanity: Paragraph with alignment\" {\n   203→    const left = Paragraph{ .text = \"L\", .alignment = .left };\n   204→    const center = Paragraph{ .text = \"C\", .alignment = .center };\n   205→    const right = Paragraph{ .text = \"R\", .alignment = .right };\n   206→\n   207→    try std.testing.expect(left.alignment == .left);\n   208→    try std.testing.expect(center.alignment == .center);\n   209→    try std.testing.expect(right.alignment == .right);\n   210→}\n   211→\n   212→// ============================================================\n   213→// BEHAVIOR TESTS - Rendering\n   214→// ============================================================\n   215→\n   216→test \"behavior: Paragraph renders single line\" {\n   217→    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   218→    defer buf.deinit();\n   219→\n   220→    const para = Paragraph{ .text = \"Hello\" };\n   221→    para.render(Rect.init(0, 0, 20, 5), &buf);\n   222→\n   223→    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n   224→    try std.testing.expectEqual(@as(u21, 'e'), buf.get(1, 0).char);\n   225→    try std.testing.expectEqual(@as(u21, 'l'), buf.get(2, 0).char);\n   226→    try std.testing.expectEqual(@as(u21, 'l'), buf.get(3, 0).char);\n   227→    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n   228→}\n   229→\n   230→test \"behavior: Paragraph renders multiple lines with newlines\" {\n   231→    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   232→    defer buf.deinit();\n   233→\n   234→    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\" };\n   235→    para.render(Rect.init(0, 0, 20, 5), &buf);\n   236→\n   237→    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n   238→    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n   239→    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n   240→    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n   241→    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 2).char);\n   242→    try std.testing.expectEqual(@as(u21, '3'), buf.get(4, 2).char);\n   243→}\n   244→\n   245→test \"behavior: Paragraph with char wrap\" {\n   246→    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n   247→    defer buf.deinit();\n   248→\n   249→    const para = Paragraph{\n   250→        .text = \"ABCDEFGHIJKLMNOP\",\n   251→        .wrap = .char,\n   252→    };\n   253→    para.render(Rect.init(0, 0, 10, 5), &buf);\n   254→\n   255→    // First 10 chars on row 0\n   256→    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n   257→    try std.testing.expectEqual(@as(u21, 'J'), buf.get(9, 0).char);\n   258→    // Next 6 chars on row 1\n   259→    try std.testing.expectEqual(@as(u21, 'K'), buf.get(0, 1).char);\n   260→    try std.testing.expectEqual(@as(u21, 'P'), buf.get(5, 1).char);\n   261→}\n   262→\n   263→test \"behavior: Paragraph with word wrap\" {\n   264→    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n   265→    defer buf.deinit();\n   266→\n   267→    const para = Paragraph{\n   268→        .text = \"Hello World Today\",\n   269→        .wrap = .word,\n   270→    };\n   271→    para.render(Rect.init(0, 0, 10, 5), &buf);\n   272→\n   273→    // \"Hello \" should be on row 0\n   274→    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n   275→    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n   276→    // \"World \" should be on row 1\n   277→    try std.testing.expectEqual(@as(u21, 'W'), buf.get(0, 1).char);\n   278→    try std.testing.expectEqual(@as(u21, 'd'), buf.get(4, 1).char);\n   279→    // \"Today\" should be on row 2\n   280→    try std.testing.expectEqual(@as(u21, 'T'), buf.get(0, 2).char);\n   281→}\n   282→\n   283→test \"behavior: Paragraph center alignment\" {\n   284→    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   285→    defer buf.deinit();\n   286→\n   287→    const para = Paragraph{\n   288→        .text = \"Hi\",\n   289→        .alignment = .center,\n   290→    };\n   291→    para.render(Rect.init(0, 0, 20, 5), &buf);\n   292→\n   293→    // \"Hi\" (2 chars) centered in 20 = offset 9\n   294→    try std.testing.expectEqual(@as(u21, 'H'), buf.get(9, 0).char);\n   295→    try std.testing.expectEqual(@as(u21, 'i'), buf.get(10, 0).char);\n   296→}\n   297→\n   298→test \"behavior: Paragraph right alignment\" {\n   299→    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   300→    defer buf.deinit();\n   301→\n   302→    const para = Paragraph{\n   303→        .text = \"End\",\n   304→        .alignment = .right,\n   305→    };\n   306→    para.render(Rect.init(0, 0, 20, 5), &buf);\n   307→\n   308→    // \"End\" (3 chars) right-aligned in 20 = starts at 17\n   309→    try std.testing.expectEqual(@as(u21, 'E'), buf.get(17, 0).char);\n   310→    try std.testing.expectEqual(@as(u21, 'd'), buf.get(19, 0).char);\n   311→}\n   312→\n   313→test \"behavior: Paragraph applies style\" {\n   314→    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   315→    defer buf.deinit();\n   316→\n   317→    const para = Paragraph{\n   318→        .text = \"Bold\",\n   319→        .style = Style.init().bold(),\n   320→    };\n   321→    para.render(Rect.init(0, 0, 20, 5), &buf);\n   322→\n   323→    try std.testing.expect(buf.get(0, 0).style.hasAttribute(.bold));\n   324→    try std.testing.expect(buf.get(1, 0).style.hasAttribute(.bold));\n   325→}\n   326→\n   327→test \"behavior: Paragraph renders at area offset\" {\n   328→    var buf = try Buffer.init(std.testing.allocator, 30, 10);\n   329→    defer buf.deinit();\n   330→\n   331→    const para = Paragraph{ .text = \"Offset\\nTest\" };\n   332→    para.render(Rect.init(5, 3, 10, 5), &buf);\n   333→\n   334→    try std.testing.expectEqual(@as(u21, 'O'), buf.get(5, 3).char);\n   335→    try std.testing.expectEqual(@as(u21, 'T'), buf.get(5, 4).char);\n   336→}\n   337→\n   338→// ============================================================\n   339→// REGRESSION TESTS - Edge cases\n   340→// ============================================================\n   341→\n   342→test \"regression: Paragraph handles empty area\" {\n   343→    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n   344→    defer buf.deinit();\n   345→\n   346→    const para = Paragraph{ .text = \"Test\" };\n   347→    para.render(Rect.init(0, 0, 0, 0), &buf);\n   348→\n   349→    // Buffer should be unchanged\n   350→    for (buf.cells) |cell| {\n   351→        try std.testing.expect(cell.isDefault());\n   352→    }\n   353→}\n   354→\n   355→test \"regression: Paragraph handles empty text\" {\n   356→    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n   357→    defer buf.deinit();\n   358→\n   359→    const para = Paragraph{ .text = \"\" };\n   360→    para.render(Rect.init(0, 0, 10, 5), &buf);\n   361→\n   362→    // Buffer should be unchanged\n   363→    for (buf.cells) |cell| {\n   364→        try std.testing.expect(cell.isDefault());\n   365→    }\n   366→}\n   367→\n   368→test \"regression: Paragraph clips lines beyond height\" {\n   369→    var buf = try Buffer.init(std.testing.allocator, 20, 2);\n   370→    defer buf.deinit();\n   371→\n   372→    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\\nLine4\" };\n   373→    para.render(Rect.init(0, 0, 20, 2), &buf);\n   374→\n   375→    // Only first 2 lines should be rendered\n   376→    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n   377→    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n   378→    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n   379→    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n   380→}\n   381→\n   382→test \"regression: Paragraph word wrap handles long words\" {\n   383→    var buf = try Buffer.init(std.testing.allocator, 5, 5);\n   384→    defer buf.deinit();\n   385→\n   386→    // Word longer than width - should hard wrap\n   387→    const para = Paragraph{\n   388→        .text = \"ABCDEFGH\",\n   389→        .wrap = .word,\n   390→    };\n   391→    para.render(Rect.init(0, 0, 5, 5), &buf);\n   392→\n   393→    // Should hard wrap at width since no spaces\n   394→    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n   395→    try std.testing.expectEqual(@as(u21, 'E'), buf.get(4, 0).char);\n   396→    try std.testing.expectEqual(@as(u21, 'F'), buf.get(0, 1).char);\n   397→}\n   398→\n   399→test \"regression: Paragraph handles trailing newline\" {\n   400→    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   401→    defer buf.deinit();\n   402→\n   403→    const para = Paragraph{ .text = \"Line1\\n\" };\n   404→    para.render(Rect.init(0, 0, 20, 5), &buf);\n   405→\n   406→    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n   407→    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n   408→}\n   409→\n   410→test \"regression: Paragraph handles consecutive newlines\" {\n   411→    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n   412→    defer buf.deinit();\n   413→\n   414→    const para = Paragraph{ .text = \"A\\n\\nB\" };\n   415→    para.render(Rect.init(0, 0, 20, 5), &buf);\n   416→\n   417→    // A on row 0, empty row 1, B on row 2\n   418→    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n   419→    try std.testing.expectEqual(@as(u21, 'B'), buf.get(0, 2).char);\n   420→}\n   421→\n   422→test \"regression: findWordWrapEnd handles empty text\" {\n   423→    const result = findWordWrapEnd(\"\", 10);\n   424→    try std.testing.expectEqual(@as(usize, 0), result);\n   425→}\n   426→\n   427→test \"regression: findWordWrapEnd handles short text\" {\n   428→    const result = findWordWrapEnd(\"Hi\", 10);\n   429→    try std.testing.expectEqual(@as(usize, 2), result);\n   430→}\n   431→\n   432→test \"regression: findWordWrapEnd breaks at space\" {\n   433→    const result = findWordWrapEnd(\"Hello World\", 7);\n   434→    // Should break after \"Hello \" (6 chars including space)\n   435→    try std.testing.expectEqual(@as(usize, 6), result);\n   436→}\n   437→\n   438→test \"regression: findWordWrapEnd hard breaks long word\" {\n   439→    const result = findWordWrapEnd(\"Supercalifragilistic\", 5);\n   440→    // No space found, hard break at width\n   441→    try std.testing.expectEqual(@as(usize, 5), result);\n   442→}\n   443→\n   444→test \"regression: textDisplayWidth handles ASCII\" {\n   445→    const w = textDisplayWidth(\"Hello\");\n   446→    try std.testing.expectEqual(@as(u16, 5), w);\n   447→}\n   448→\n   449→test \"regression: textDisplayWidth handles wide chars\" {\n   450→    const w = textDisplayWidth(\"\\u{4E2D}\");\n   451→    try std.testing.expectEqual(@as(u16, 2), w);\n   452→}\n   453→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "729b8667-0acb-47bb-8913-a49a8960232f"
tool_use_result:
  type: text
  file:
    filePath: /home/hotschmoe/zithril/src/widgets/paragraph.zig
    content: "// Paragraph widget for zithril TUI framework\n// Multi-line text with wrapping and alignment\n\nconst std = @import(\"std\");\nconst buffer_mod = @import(\"../buffer.zig\");\nconst geometry = @import(\"../geometry.zig\");\nconst style_mod = @import(\"../style.zig\");\n\npub const Buffer = buffer_mod.Buffer;\npub const Rect = geometry.Rect;\npub const Style = style_mod.Style;\n\n/// Text wrapping modes\npub const Wrap = enum {\n    /// No wrapping, clip at boundary\n    none,\n    /// Wrap at any character position\n    char,\n    /// Wrap at word boundaries (spaces)\n    word,\n};\n\n/// Text alignment options\npub const Alignment = enum {\n    left,\n    center,\n    right,\n};\n\n/// Multi-line text widget with optional wrapping.\n///\n/// Renders text content across multiple lines with configurable wrapping\n/// behavior and alignment. Lines beyond the area height are not rendered.\npub const Paragraph = struct {\n    /// The text content to display\n    text: []const u8,\n\n    /// Style applied to the text\n    style: Style = Style.empty,\n\n    /// Text wrapping mode\n    wrap: Wrap = .none,\n\n    /// Text alignment within each line\n    alignment: Alignment = .left,\n\n    /// Render the paragraph into the buffer at the given area.\n    /// Text is split into lines (either by newlines or wrapping) and rendered\n    /// until the area height is filled.\n    pub fn render(self: Paragraph, area: Rect, buf: *Buffer) void {\n        if (area.isEmpty()) return;\n        if (self.text.len == 0) return;\n\n        var y = area.y;\n        const max_y = area.bottom();\n\n        // Process text line by line (split by newlines first)\n        var line_iter = std.mem.splitScalar(u8, self.text, '\\n');\n        while (line_iter.next()) |logical_line| {\n            if (y >= max_y) break;\n\n            // Apply wrapping to this logical line\n            switch (self.wrap) {\n                .none => {\n                    self.renderLine(logical_line, area.x, y, area.width, buf);\n                    y += 1;\n                },\n                .char => {\n                    var remaining = logical_line;\n                    while (remaining.len > 0 and y < max_y) {\n                        const chunk_len = @min(remaining.len, area.width);\n                        const chunk = remaining[0..chunk_len];\n                        self.renderLine(chunk, area.x, y, area.width, buf);\n                        remaining = remaining[chunk_len..];\n                        y += 1;\n                    }\n                    // Empty line should still take a row\n                    if (logical_line.len == 0) {\n                        y += 1;\n                    }\n                },\n                .word => {\n                    if (logical_line.len == 0) {\n                        y += 1;\n                        continue;\n                    }\n                    var line_start: usize = 0;\n                    while (line_start < logical_line.len and y < max_y) {\n                        const wrap_end = findWordWrapEnd(logical_line[line_start..], area.width);\n                        const line = logical_line[line_start .. line_start + wrap_end];\n                        self.renderLine(line, area.x, y, area.width, buf);\n                        line_start += wrap_end;\n                        // Skip leading spaces on next line\n                        while (line_start < logical_line.len and logical_line[line_start] == ' ') {\n                            line_start += 1;\n                        }\n                        y += 1;\n                    }\n                },\n            }\n        }\n    }\n\n    /// Render a single line of text with alignment\n    fn renderLine(self: Paragraph, line: []const u8, x: u16, y: u16, width: u16, buf: *Buffer) void {\n        if (line.len == 0) return;\n\n        const text_len = textDisplayWidth(line);\n        const visible_len = @min(text_len, width);\n\n        if (visible_len == 0) return;\n\n        const x_offset: u16 = switch (self.alignment) {\n            .left => 0,\n            .center => (width -| visible_len) / 2,\n            .right => width -| visible_len,\n        };\n\n        buf.setString(x +| x_offset, y, line, self.style);\n    }\n};\n\n/// Find the end index for word wrapping within a max width.\n/// Returns the number of characters to include on this line.\nfn findWordWrapEnd(text: []const u8, max_width: u16) usize {\n    if (text.len == 0) return 0;\n\n    const width: usize = @intCast(max_width);\n    if (text.len <= width) return text.len;\n\n    // Find the last space within the width limit\n    var last_space: ?usize = null;\n    for (0..width) |i| {\n        if (text[i] == ' ') {\n            last_space = i;\n        }\n    }\n\n    // If we found a space, wrap there (include the space in this line)\n    if (last_space) |space_pos| {\n        // Return position including the space, so next line starts after it\n        return space_pos + 1;\n    }\n\n    // No space found - break at max width (hard wrap)\n    return width;\n}\n\n/// Calculate the display width of a string (counting grapheme columns).\n/// Simple implementation: counts codepoints, treating wide chars as width 2.\nfn textDisplayWidth(str: []const u8) u16 {\n    var width: u16 = 0;\n    var iter = std.unicode.Utf8View.initUnchecked(str).iterator();\n    while (iter.nextCodepoint()) |cp| {\n        width +|= if (isWideCodepoint(cp)) 2 else 1;\n    }\n    return width;\n}\n\n/// Check if a codepoint is a wide character (CJK, etc.)\nfn isWideCodepoint(cp: u21) bool {\n    return (cp >= 0x4E00 and cp <= 0x9FFF) or // CJK Unified Ideographs\n        (cp >= 0x3400 and cp <= 0x4DBF) or // CJK Extension A\n        (cp >= 0x20000 and cp <= 0x2A6DF) or // CJK Extension B\n        (cp >= 0xF900 and cp <= 0xFAFF) or // CJK Compatibility\n        (cp >= 0xFF00 and cp <= 0xFF60) or // Fullwidth forms\n        (cp >= 0xFFE0 and cp <= 0xFFE6) or // Fullwidth symbols\n        (cp >= 0x3000 and cp <= 0x303F) or // CJK Punctuation\n        (cp >= 0x1100 and cp <= 0x11FF); // Hangul Jamo\n}\n\n// ============================================================\n// SANITY TESTS - Basic Paragraph functionality\n// ============================================================\n\ntest \"sanity: Paragraph with default values\" {\n    const para = Paragraph{ .text = \"Hello\\nWorld\" };\n    try std.testing.expectEqualStrings(\"Hello\\nWorld\", para.text);\n    try std.testing.expect(para.style.isEmpty());\n    try std.testing.expect(para.wrap == .none);\n    try std.testing.expect(para.alignment == .left);\n}\n\ntest \"sanity: Paragraph with custom style\" {\n    const para = Paragraph{\n        .text = \"Styled\",\n        .style = Style.init().bold().fg(.red),\n    };\n    try std.testing.expect(para.style.hasAttribute(.bold));\n}\n\ntest \"sanity: Paragraph with wrap modes\" {\n    const none_wrap = Paragraph{ .text = \"T\", .wrap = .none };\n    const char_wrap = Paragraph{ .text = \"T\", .wrap = .char };\n    const word_wrap = Paragraph{ .text = \"T\", .wrap = .word };\n\n    try std.testing.expect(none_wrap.wrap == .none);\n    try std.testing.expect(char_wrap.wrap == .char);\n    try std.testing.expect(word_wrap.wrap == .word);\n}\n\ntest \"sanity: Paragraph with alignment\" {\n    const left = Paragraph{ .text = \"L\", .alignment = .left };\n    const center = Paragraph{ .text = \"C\", .alignment = .center };\n    const right = Paragraph{ .text = \"R\", .alignment = .right };\n\n    try std.testing.expect(left.alignment == .left);\n    try std.testing.expect(center.alignment == .center);\n    try std.testing.expect(right.alignment == .right);\n}\n\n// ============================================================\n// BEHAVIOR TESTS - Rendering\n// ============================================================\n\ntest \"behavior: Paragraph renders single line\" {\n    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{ .text = \"Hello\" };\n    para.render(Rect.init(0, 0, 20, 5), &buf);\n\n    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n    try std.testing.expectEqual(@as(u21, 'e'), buf.get(1, 0).char);\n    try std.testing.expectEqual(@as(u21, 'l'), buf.get(2, 0).char);\n    try std.testing.expectEqual(@as(u21, 'l'), buf.get(3, 0).char);\n    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n}\n\ntest \"behavior: Paragraph renders multiple lines with newlines\" {\n    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\" };\n    para.render(Rect.init(0, 0, 20, 5), &buf);\n\n    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 2).char);\n    try std.testing.expectEqual(@as(u21, '3'), buf.get(4, 2).char);\n}\n\ntest \"behavior: Paragraph with char wrap\" {\n    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{\n        .text = \"ABCDEFGHIJKLMNOP\",\n        .wrap = .char,\n    };\n    para.render(Rect.init(0, 0, 10, 5), &buf);\n\n    // First 10 chars on row 0\n    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n    try std.testing.expectEqual(@as(u21, 'J'), buf.get(9, 0).char);\n    // Next 6 chars on row 1\n    try std.testing.expectEqual(@as(u21, 'K'), buf.get(0, 1).char);\n    try std.testing.expectEqual(@as(u21, 'P'), buf.get(5, 1).char);\n}\n\ntest \"behavior: Paragraph with word wrap\" {\n    var buf = try Buffer.init(std.testing.allocator, 10, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{\n        .text = \"Hello World Today\",\n        .wrap = .word,\n    };\n    para.render(Rect.init(0, 0, 10, 5), &buf);\n\n    // \"Hello \" should be on row 0\n    try std.testing.expectEqual(@as(u21, 'H'), buf.get(0, 0).char);\n    try std.testing.expectEqual(@as(u21, 'o'), buf.get(4, 0).char);\n    // \"World \" should be on row 1\n    try std.testing.expectEqual(@as(u21, 'W'), buf.get(0, 1).char);\n    try std.testing.expectEqual(@as(u21, 'd'), buf.get(4, 1).char);\n    // \"Today\" should be on row 2\n    try std.testing.expectEqual(@as(u21, 'T'), buf.get(0, 2).char);\n}\n\ntest \"behavior: Paragraph center alignment\" {\n    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{\n        .text = \"Hi\",\n        .alignment = .center,\n    };\n    para.render(Rect.init(0, 0, 20, 5), &buf);\n\n    // \"Hi\" (2 chars) centered in 20 = offset 9\n    try std.testing.expectEqual(@as(u21, 'H'), buf.get(9, 0).char);\n    try std.testing.expectEqual(@as(u21, 'i'), buf.get(10, 0).char);\n}\n\ntest \"behavior: Paragraph right alignment\" {\n    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{\n        .text = \"End\",\n        .alignment = .right,\n    };\n    para.render(Rect.init(0, 0, 20, 5), &buf);\n\n    // \"End\" (3 chars) right-aligned in 20 = starts at 17\n    try std.testing.expectEqual(@as(u21, 'E'), buf.get(17, 0).char);\n    try std.testing.expectEqual(@as(u21, 'd'), buf.get(19, 0).char);\n}\n\ntest \"behavior: Paragraph applies style\" {\n    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{\n        .text = \"Bold\",\n        .style = Style.init().bold(),\n    };\n    para.render(Rect.init(0, 0, 20, 5), &buf);\n\n    try std.testing.expect(buf.get(0, 0).style.hasAttribute(.bold));\n    try std.testing.expect(buf.get(1, 0).style.hasAttribute(.bold));\n}\n\ntest \"behavior: Paragraph renders at area offset\" {\n    var buf = try Buffer.init(std.testing.allocator, 30, 10);\n    defer buf.deinit();\n\n    const para = Paragraph{ .text = \"Offset\\nTest\" };\n    para.render(Rect.init(5, 3, 10, 5), &buf);\n\n    try std.testing.expectEqual(@as(u21, 'O'), buf.get(5, 3).char);\n    try std.testing.expectEqual(@as(u21, 'T'), buf.get(5, 4).char);\n}\n\n// ============================================================\n// REGRESSION TESTS - Edge cases\n// ============================================================\n\ntest \"regression: Paragraph handles empty area\" {\n    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n    defer buf.deinit();\n\n    const para = Paragraph{ .text = \"Test\" };\n    para.render(Rect.init(0, 0, 0, 0), &buf);\n\n    // Buffer should be unchanged\n    for (buf.cells) |cell| {\n        try std.testing.expect(cell.isDefault());\n    }\n}\n\ntest \"regression: Paragraph handles empty text\" {\n    var buf = try Buffer.init(std.testing.allocator, 10, 10);\n    defer buf.deinit();\n\n    const para = Paragraph{ .text = \"\" };\n    para.render(Rect.init(0, 0, 10, 5), &buf);\n\n    // Buffer should be unchanged\n    for (buf.cells) |cell| {\n        try std.testing.expect(cell.isDefault());\n    }\n}\n\ntest \"regression: Paragraph clips lines beyond height\" {\n    var buf = try Buffer.init(std.testing.allocator, 20, 2);\n    defer buf.deinit();\n\n    const para = Paragraph{ .text = \"Line1\\nLine2\\nLine3\\nLine4\" };\n    para.render(Rect.init(0, 0, 20, 2), &buf);\n\n    // Only first 2 lines should be rendered\n    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 1).char);\n    try std.testing.expectEqual(@as(u21, '2'), buf.get(4, 1).char);\n}\n\ntest \"regression: Paragraph word wrap handles long words\" {\n    var buf = try Buffer.init(std.testing.allocator, 5, 5);\n    defer buf.deinit();\n\n    // Word longer than width - should hard wrap\n    const para = Paragraph{\n        .text = \"ABCDEFGH\",\n        .wrap = .word,\n    };\n    para.render(Rect.init(0, 0, 5, 5), &buf);\n\n    // Should hard wrap at width since no spaces\n    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n    try std.testing.expectEqual(@as(u21, 'E'), buf.get(4, 0).char);\n    try std.testing.expectEqual(@as(u21, 'F'), buf.get(0, 1).char);\n}\n\ntest \"regression: Paragraph handles trailing newline\" {\n    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{ .text = \"Line1\\n\" };\n    para.render(Rect.init(0, 0, 20, 5), &buf);\n\n    try std.testing.expectEqual(@as(u21, 'L'), buf.get(0, 0).char);\n    try std.testing.expectEqual(@as(u21, '1'), buf.get(4, 0).char);\n}\n\ntest \"regression: Paragraph handles consecutive newlines\" {\n    var buf = try Buffer.init(std.testing.allocator, 20, 5);\n    defer buf.deinit();\n\n    const para = Paragraph{ .text = \"A\\n\\nB\" };\n    para.render(Rect.init(0, 0, 20, 5), &buf);\n\n    // A on row 0, empty row 1, B on row 2\n    try std.testing.expectEqual(@as(u21, 'A'), buf.get(0, 0).char);\n    try std.testing.expectEqual(@as(u21, 'B'), buf.get(0, 2).char);\n}\n\ntest \"regression: findWordWrapEnd handles empty text\" {\n    const result = findWordWrapEnd(\"\", 10);\n    try std.testing.expectEqual(@as(usize, 0), result);\n}\n\ntest \"regression: findWordWrapEnd handles short text\" {\n    const result = findWordWrapEnd(\"Hi\", 10);\n    try std.testing.expectEqual(@as(usize, 2), result);\n}\n\ntest \"regression: findWordWrapEnd breaks at space\" {\n    const result = findWordWrapEnd(\"Hello World\", 7);\n    // Should break after \"Hello \" (6 chars including space)\n    try std.testing.expectEqual(@as(usize, 6), result);\n}\n\ntest \"regression: findWordWrapEnd hard breaks long word\" {\n    const result = findWordWrapEnd(\"Supercalifragilistic\", 5);\n    // No space found, hard break at width\n    try std.testing.expectEqual(@as(usize, 5), result);\n}\n\ntest \"regression: textDisplayWidth handles ASCII\" {\n    const w = textDisplayWidth(\"Hello\");\n    try std.testing.expectEqual(@as(u16, 5), w);\n}\n\ntest \"regression: textDisplayWidth handles wide chars\" {\n    const w = textDisplayWidth(\"\\u{4E2D}\");\n    try std.testing.expectEqual(@as(u16, 2), w);\n}\n"
    numLines: 453
    startLine: 1
    totalLines: 453
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01TeEYC8GJmNR8Dp2Dw6m6Ww
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01TCvvQVW5vmT43JSRvrkf4k
      name: TodoWrite
      input:
        todos[4]{content,status,activeForm}:
          Review recent code changes for simplification opportunities,completed,Reviewing recent code changes for simplification opportunities
          Identify simplification opportunities in examples and widgets,in_progress,Identifying simplification opportunities in examples and widgets
          Run tests to verify changes,pending,Running tests to verify changes
          Commit simplification changes if any,pending,Committing simplification changes if any
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 25441
    cache_read_input_tokens: 39102
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 25441
    output_tokens: 25
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "6b4bc012-1b98-4ef3-a248-bb5bf4562e16"
type: user
message:
  role: user
  content[1]{tool_use_id,type,content}:
    toolu_01TCvvQVW5vmT43JSRvrkf4k,tool_result,Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: cd246694-3773-4e4f-b5d1-775dc0df7a96
tool_use_result:
  oldTodos[0]:
  newTodos[4]{content,status,activeForm}:
    Review recent code changes for simplification opportunities,completed,Reviewing recent code changes for simplification opportunities
    Identify simplification opportunities in examples and widgets,in_progress,Identifying simplification opportunities in examples and widgets
    Run tests to verify changes,pending,Running tests to verify changes
    Commit simplification changes if any,pending,Committing simplification changes if any
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01E8LhBTyhV5VpqcQpQ7fUJV
  type: message
  role: assistant
  content[1]{type,text}:
    text,"After reviewing the code changes, here's my analysis:\n\n**Files reviewed:**\n1. `examples/counter.zig` - Clean, well-structured example\n2. `examples/list.zig` - Clean, well-structured example  \n3. `src/backend.zig` - Panic handler updated for Zig 0.15\n4. `src/widgets/paragraph.zig` - New widget with comprehensive tests\n\n**Simplification opportunities identified:**\n\n1. **paragraph.zig:24-28** - The `Alignment` enum is duplicated (also exists in `widgets/text.zig`). However, this is a conscious design choice for module independence, so I'll leave it.\n\n2. **No significant simplifications needed** - The code is already clean and follows good patterns:\n   - Examples are minimal and focused\n   - The panic handler functions use `_` for unused parameters consistently\n   - The paragraph widget is well-structured with clear separation between public API and private helpers\n   - Tests are organized into sanity/behavior/regression categories\n\nLet me run the tests to verify everything works correctly:"
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 228
    cache_read_input_tokens: 64543
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 228
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "5b99b3e5-cc51-4277-ba0f-3cd04d8323d3"
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01E8LhBTyhV5VpqcQpQ7fUJV
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01WieJKxtwjcXRsxSDkDmB73
      name: TodoWrite
      input:
        todos[4]{content,status,activeForm}:
          Review recent code changes for simplification opportunities,completed,Reviewing recent code changes for simplification opportunities
          Identify simplification opportunities in examples and widgets,completed,Identifying simplification opportunities in examples and widgets
          Run tests to verify changes,in_progress,Running tests to verify changes
          Commit simplification changes if any,pending,Committing simplification changes if any
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 228
    cache_read_input_tokens: 64543
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 228
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: f8bd1e21-a2c9-472a-b72c-dcc89a4859cf
type: user
message:
  role: user
  content[1]{tool_use_id,type,content}:
    toolu_01WieJKxtwjcXRsxSDkDmB73,tool_result,Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "0a780f35-82ac-40f9-84b6-3666d7ee8d9c"
tool_use_result:
  oldTodos[4]{content,status,activeForm}:
    Review recent code changes for simplification opportunities,completed,Reviewing recent code changes for simplification opportunities
    Identify simplification opportunities in examples and widgets,in_progress,Identifying simplification opportunities in examples and widgets
    Run tests to verify changes,pending,Running tests to verify changes
    Commit simplification changes if any,pending,Committing simplification changes if any
  newTodos[4]{content,status,activeForm}:
    Review recent code changes for simplification opportunities,completed,Reviewing recent code changes for simplification opportunities
    Identify simplification opportunities in examples and widgets,completed,Identifying simplification opportunities in examples and widgets
    Run tests to verify changes,in_progress,Running tests to verify changes
    Commit simplification changes if any,pending,Committing simplification changes if any
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01E8LhBTyhV5VpqcQpQ7fUJV
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01B5wttsN1to7XwiYheAWmii
      name: Bash
      input:
        command: zig build test 2>&1
        description: Run all tests
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 228
    cache_read_input_tokens: 64543
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 228
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: f4ca51b9-9f03-493c-8f4a-e7957895358c
type: user
message:
  role: user
  content[1]{tool_use_id,type,content,is_error}:
    toolu_01B5wttsN1to7XwiYheAWmii,tool_result,"",false
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: d50845ac-3a46-4b64-a383-4e51ac29f882
tool_use_result:
  stdout: ""
  stderr: ""
  interrupted: false
  isImage: false
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01LWhowWMf2HuBHLbRcD4wc6
  type: message
  role: assistant
  content[1]{type,text}:
    text,"All tests pass. Let me also verify the build and run the examples to make sure they compile:"
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 592
    cache_read_input_tokens: 64771
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 592
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: aa7d919e-a6eb-4a02-9c45-26e0f08e847d
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01LWhowWMf2HuBHLbRcD4wc6
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01Pv8MyxskEXtK4kFzhTQLhc
      name: Bash
      input:
        command: zig build 2>&1
        description: Build the library
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 592
    cache_read_input_tokens: 64771
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 592
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "7884fc0d-be3f-4f06-9736-3e3615845ba0"
type: user
message:
  role: user
  content[1]{tool_use_id,type,content,is_error}:
    toolu_01Pv8MyxskEXtK4kFzhTQLhc,tool_result,"",false
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: c692f5ce-fc75-4f88-8cab-cabc00b39b71
tool_use_result:
  stdout: ""
  stderr: ""
  interrupted: false
  isImage: false
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_017apoxwdrmRz7L6RgQD4xgf
  type: message
  role: assistant
  content[1]:
    - type: tool_use
      id: toolu_01YV5ZyPm6uwVqs1bTBDY9Yb
      name: TodoWrite
      input:
        todos[4]{content,status,activeForm}:
          Review recent code changes for simplification opportunities,completed,Reviewing recent code changes for simplification opportunities
          Identify simplification opportunities in examples and widgets,completed,Identifying simplification opportunities in examples and widgets
          Run tests to verify changes,completed,Running tests to verify changes
          Commit simplification changes if any,completed,Committing simplification changes if any
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 124
    cache_read_input_tokens: 65363
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 124
    output_tokens: 25
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: faf8a1bf-2199-48c8-a3c9-06ee4d53dee1
type: user
message:
  role: user
  content[1]{tool_use_id,type,content}:
    toolu_01YV5ZyPm6uwVqs1bTBDY9Yb,tool_result,Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "06117a65-aabe-482d-bd15-cf5577d6f4ee"
tool_use_result:
  oldTodos[4]{content,status,activeForm}:
    Review recent code changes for simplification opportunities,completed,Reviewing recent code changes for simplification opportunities
    Identify simplification opportunities in examples and widgets,completed,Identifying simplification opportunities in examples and widgets
    Run tests to verify changes,in_progress,Running tests to verify changes
    Commit simplification changes if any,pending,Committing simplification changes if any
  newTodos[4]{content,status,activeForm}:
    Review recent code changes for simplification opportunities,completed,Reviewing recent code changes for simplification opportunities
    Identify simplification opportunities in examples and widgets,completed,Identifying simplification opportunities in examples and widgets
    Run tests to verify changes,completed,Running tests to verify changes
    Commit simplification changes if any,completed,Committing simplification changes if any
type: assistant
message:
  model: claude-opus-4-5-20251101
  id: msg_01Umv1LQENCHSGyTLoBdu1vQ
  type: message
  role: assistant
  content[1]{type,text}:
    text,"**Summary:**\n\nThe recent code changes are already well-written and don't require simplification. The changes include:\n\n1. **counter.zig & list.zig** - Transformed from placeholder examples into working TUI applications with proper state management, event handling, and rendering\n2. **backend.zig** - Updated panic handler to match Zig 0.15's expected interface with cleaner parameter handling (unused params use `_`)\n3. **paragraph.zig** - New widget with proper multi-line text wrapping and alignment support\n\nAll tests pass and the build succeeds. The code follows project conventions:\n- Clear separation of concerns\n- Minimal comments (code is self-documenting)\n- Comprehensive test coverage organized by category\n- No over-engineering\n\nNo simplification changes were needed - the code is already clean and maintainable."
  stop_reason: null
  stop_sequence: null
  usage:
    input_tokens: 0
    cache_creation_input_tokens: 226
    cache_read_input_tokens: 65487
    cache_creation:
      ephemeral_5m_input_tokens: 0
      ephemeral_1h_input_tokens: 226
    output_tokens: 1
    service_tier: standard
  context_management: null
parent_tool_use_id: null
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
uuid: "7b980d7a-2a8c-407a-9a83-ef2bbf077393"
type: result
subtype: success
is_error: false
duration_ms: 48979
duration_api_ms: 52830
num_turns: 14
result: "**Summary:**\n\nThe recent code changes are already well-written and don't require simplification. The changes include:\n\n1. **counter.zig & list.zig** - Transformed from placeholder examples into working TUI applications with proper state management, event handling, and rendering\n2. **backend.zig** - Updated panic handler to match Zig 0.15's expected interface with cleaner parameter handling (unused params use `_`)\n3. **paragraph.zig** - New widget with proper multi-line text wrapping and alignment support\n\nAll tests pass and the build succeeds. The code follows project conventions:\n- Clear separation of concerns\n- Minimal comments (code is self-documenting)\n- Comprehensive test coverage organized by category\n- No over-engineering\n\nNo simplification changes were needed - the code is already clean and maintainable."
session_id: "1bb8dd36-e928-4d38-bca6-6793125c3cb1"
total_cost_usd: 0.55660675
usage:
  input_tokens: 2
  cache_creation_input_tokens: 47709
  cache_read_input_tokens: 390454
  output_tokens: 1862
  server_tool_use:
    web_search_requests: 0
    web_fetch_requests: 0
  service_tier: standard
  cache_creation:
    ephemeral_1h_input_tokens: 47709
    ephemeral_5m_input_tokens: 0
modelUsage:
  "claude-opus-4-5-20251101":
    inputTokens: 2
    outputTokens: 1862
    cacheReadInputTokens: 390454
    cacheCreationInputTokens: 47709
    webSearchRequests: 0
    costUSD: 0.53996825
    contextWindow: 200000
    maxOutputTokens: 64000
  "claude-haiku-4-5-20251001":
    inputTokens: 1596
    outputTokens: 204
    cacheReadInputTokens: 0
    cacheCreationInputTokens: 11218
    webSearchRequests: 0
    costUSD: 0.0166385
    contextWindow: 200000
    maxOutputTokens: 64000
permission_denials[0]:
uuid: a85c99e6-5f87-4cb8-b346-56e06e0fb52b
