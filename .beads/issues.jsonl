{"id":"bd-128","title":"Chart: Axis rendering","description":"## Summary\nImplement axis rendering for the Chart widget including axis lines, tick marks, labels, and titles.\n\n## Parent Epic\nChart widget (bd-24d)\n\n## Requirements\n\n### Axis Components\n1. **Axis line**: Vertical line for Y-axis, horizontal line for X-axis\n2. **Tick marks**: Small perpendicular marks at label positions\n3. **Tick labels**: Numeric or text labels at tick positions\n4. **Axis title**: Optional title for the axis\n\n### Axis Struct\n```zig\npub const Axis = struct {\n    title: []const u8 = \"\",\n    bounds: [2]f64,           // [min, max]\n    labels: ?[]const Label = null,  // Auto-generate if null\n    style: Style = .{},\n    title_style: Style = .{},\n    labels_style: Style = .{},\n    \n    pub const Label = struct {\n        value: f64,\n        text: []const u8,\n    };\n};\n```\n\n### Auto-labeling\nWhen labels are null, auto-generate nice round numbers:\n- Determine step size based on range and available space\n- Use \"nice\" numbers: 1, 2, 5, 10, 20, 50, etc.\n- Example: range [0, 97] with 5 labels -> 0, 25, 50, 75, 100\n\n### Rendering\n```\n100 ┤\n 75 ┤\n 50 ┤\n 25 ┤\n  0 └────────────────\n    0   25   50   75  100\n```\n\nY-axis: labels right-aligned, ticks to the right\nX-axis: labels centered below ticks, ticks pointing up\n\n### Box-drawing Characters\n- Y-axis: '│', '┤'\n- X-axis: '─', '┴', '└'\n- Corner: '└'\n\n## Implementation Hints\n- Calculate label width to reserve space\n- Right-align Y-axis labels\n- Center X-axis labels under tick marks\n- Handle label overflow (skip labels if too dense)\n\n## Acceptance Criteria\n- [ ] Render Y-axis line with tick marks\n- [ ] Render X-axis line with tick marks\n- [ ] Display tick labels at correct positions\n- [ ] Auto-generate labels when not specified\n- [ ] Display axis titles\n- [ ] Handle label overflow gracefully\n\n## Files to Create/Modify\n- Create: src/widgets/chart/axis.zig (or inline in chart.zig)","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-02T07:15:56.361006390Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:15:56.361006390Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-197","title":"Tree widget","description":"## Summary\nImplement a Tree widget for displaying hierarchical data with expandable/collapsible nodes.\n\n## Background\nTree widgets are essential for:\n- File system browsers\n- Configuration hierarchies\n- Outline views\n- Organizational structures\n- JSON/XML structure display\n\n## Requirements\n\n### Data Model\n```zig\npub fn TreeItem(comptime T: type) type {\n    return struct {\n        data: T,\n        children: []const TreeItem(T) = &.{},\n        expanded: bool = true,\n    };\n}\n\npub fn Tree(comptime T: type) type {\n    return struct {\n        items: []const TreeItem(T),\n        selected: ?usize = null,\n        style: Style = .{},\n        highlight_style: Style = .{},\n        indent: u16 = 2,\n        \n        /// Function to render item data as text\n        renderFn: *const fn (data: T) []const u8,\n    };\n}\n```\n\n### Visual Structure\n```\n▼ Root\n  ▼ Child 1\n      Grandchild 1\n      Grandchild 2\n  ▶ Child 2 (collapsed)\n    Leaf 1\n    Leaf 2\n```\n\n### Symbols\n```zig\npub const TreeSymbols = struct {\n    expanded: []const u8 = \"▼ \",\n    collapsed: []const u8 = \"▶ \",\n    leaf: []const u8 = \"  \",  // or \"• \"\n    \n    // Optional tree lines\n    branch: []const u8 = \"├─\",\n    last_branch: []const u8 = \"└─\",\n    vertical: []const u8 = \"│ \",\n    space: []const u8 = \"  \",\n};\n```\n\n### Flattening for Rendering\nConvert tree to flat list with depth info:\n```zig\nconst FlatNode = struct {\n    depth: u16,\n    index: usize,  // index in original tree\n    is_expanded: bool,\n    is_last_child: bool,\n    data: T,\n};\n\nfn flatten(items: []const TreeItem(T), depth: u16, result: *ArrayList(FlatNode)) void {\n    for (items, 0..) |item, i| {\n        result.append(.{\n            .depth = depth,\n            .is_expanded = item.expanded,\n            .is_last_child = i == items.len - 1,\n            .data = item.data,\n        });\n        if (item.expanded) {\n            flatten(item.children, depth + 1, result);\n        }\n    }\n}\n```\n\n### Navigation\n- Up/Down: Move selection\n- Left: Collapse current node (or go to parent)\n- Right: Expand current node (or go to first child)\n- Enter: Toggle expand/collapse\n\n### State Management\n```zig\npub const TreeState = struct {\n    selected: usize = 0,\n    offset: usize = 0,  // for scrolling\n    \n    pub fn toggle(self: *TreeState, tree: *Tree) void { ... }\n    pub fn select_next(self: *TreeState, tree: *Tree) void { ... }\n    pub fn select_prev(self: *TreeState, tree: *Tree) void { ... }\n};\n```\n\n## Acceptance Criteria\n- [ ] Renders hierarchical data with indentation\n- [ ] Expand/collapse indicators\n- [ ] Selection highlighting\n- [ ] Navigation (up/down/left/right)\n- [ ] Toggle expand/collapse\n- [ ] Scrolling for large trees\n- [ ] Custom item rendering\n\n## Files to Create/Modify\n- Create: src/widgets/tree.zig\n- Modify: src/widgets.zig (add export)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-02T07:18:15.366025280Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:18:15.366025280Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-1jl","title":"Canvas: Points shape","description":"## Summary\nImplement a Points shape for the Canvas widget to render scatter plot data.\n\n## Parent Epic\nCanvas widget (bd-2us)\n\n## Requirements\n\n### Shape Structure\n```zig\npub const Points = struct {\n    coords: []const [2]f64,  // [[x, y], [x, y], ...]\n    color: Color = .white,\n    \n    pub fn shape(self: *const Points) Shape {\n        return Shape.init(self, draw);\n    }\n    \n    fn draw(self: *const Points, painter: *Painter) void {\n        for (self.coords) |coord| {\n            painter.paint(coord[0], coord[1], self.color);\n        }\n    }\n};\n```\n\n### Rendering\nSimply iterate over all coordinates and paint each point:\n- Transform each (x, y) to screen coordinates\n- Set the pixel/Braille dot at that position\n- Skip points outside canvas bounds\n\n### Use Cases\n- Scatter plots\n- Star fields\n- Particle effects\n- Data point visualization\n\n## Acceptance Criteria\n- [ ] Renders multiple points from coordinate array\n- [ ] Skips out-of-bounds points\n- [ ] Custom color support\n- [ ] Works with all Canvas marker modes\n\n## Files to Create/Modify\n- Add to: src/widgets/canvas/shapes.zig","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-02T07:17:46.102127758Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:17:46.102127758Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-1qm","title":"Chart: Line dataset rendering","description":"## Summary\nImplement line dataset rendering for the Chart widget, connecting data points with lines.\n\n## Parent Epic\nChart widget (bd-24d)\n\n## Requirements\n\n### Line Rendering\nConnect sequential data points with line segments:\n- Use line-drawing characters for cardinal directions: '─', '│'\n- Use diagonal characters for slopes: '/', '\\', '╱', '╲'\n- Optionally use Braille patterns for higher resolution\n\n### Data Point Handling\n```zig\npub const LineDataset = struct {\n    name: []const u8 = \"\",\n    data: []const [2]f64,  // [[x, y], ...]\n    style: Style = .{},\n    marker: ?u21 = null,  // Optional point marker\n};\n```\n\n### Coordinate Transformation\n```zig\nfn dataToScreen(data_x: f64, data_y: f64, bounds: Bounds, area: Rect) struct { x: u16, y: u16 } {\n    const x_ratio = (data_x - bounds.x_min) / (bounds.x_max - bounds.x_min);\n    const y_ratio = (data_y - bounds.y_min) / (bounds.y_max - bounds.y_min);\n    return .{\n        .x = area.x + @intFromFloat(x_ratio * @as(f64, @floatFromInt(area.width))),\n        .y = area.y + area.height - 1 - @intFromFloat(y_ratio * @as(f64, @floatFromInt(area.height))),\n    };\n}\n```\n\n### Line Drawing Algorithm\nFor each pair of consecutive points:\n1. Transform to screen coordinates\n2. Use Bresenham or DDA to get intermediate cells\n3. Choose appropriate line character based on direction\n\n### Character Selection\n- Horizontal: '─' (0x2500)\n- Vertical: '│' (0x2502)\n- Diagonal up-right: '/' or '╱' (0x2571)\n- Diagonal down-right: '\\' or '╲' (0x2572)\n- Cross: '╳' (0x2573) for intersections\n\n### Optional Markers\nIf marker is set, render it at each data point position:\n- Common markers: '●', '○', '■', '□', '◆', '◇', '*'\n\n## Implementation Hints\n- Sort data by X coordinate before rendering\n- Handle points outside bounds (clip or skip)\n- For steep lines, iterate over Y; for shallow, iterate over X\n- Consider using Braille (⠁⠂⠄⡀⠈⠐⠠⢀) for 2x4 sub-cell resolution\n\n## Acceptance Criteria\n- [ ] Connect points with line characters\n- [ ] Correct character selection based on slope\n- [ ] Optional markers at data points\n- [ ] Handle points outside chart bounds\n- [ ] Support multiple line datasets with different styles\n\n## Files to Create/Modify\n- Create: src/widgets/chart/line.zig (or inline in chart.zig)","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-02T07:16:08.044963513Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:16:08.044963513Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-1zo","title":"Canvas: Rectangle shape","description":"## Summary\nImplement a Rectangle shape for the Canvas widget with outline and fill modes.\n\n## Parent Epic\nCanvas widget (bd-2us)\n\n## Requirements\n\n### Shape Structure\n```zig\npub const Rectangle = struct {\n    x: f64,           // left x in virtual coords\n    y: f64,           // bottom y in virtual coords (or top, depending on coord system)\n    width: f64,       // width in virtual coords\n    height: f64,      // height in virtual coords\n    color: Color = .white,\n    fill: bool = false,\n    \n    pub fn shape(self: *const Rectangle) Shape {\n        return Shape.init(self, draw);\n    }\n    \n    fn draw(self: *const Rectangle, painter: *Painter) void { ... }\n};\n```\n\n### Outline Rendering\nDraw 4 lines connecting the corners:\n```\n(x, y+h) ─────────── (x+w, y+h)\n    │                    │\n    │                    │\n    │                    │\n(x, y) ─────────────── (x+w, y)\n```\n\n### Fill Rendering\nFor filled rectangles, iterate over all interior points:\n```zig\nfn drawFilledRect(painter: *Painter, x: i32, y: i32, w: i32, h: i32, color: Color) void {\n    var py = y;\n    while (py < y + h) : (py += 1) {\n        var px = x;\n        while (px < x + w) : (px += 1) {\n            painter.setPixel(px, py, color);\n        }\n    }\n}\n```\n\n### Coordinate Handling\n1. Transform corner points from virtual to screen coordinates\n2. Calculate screen-space width and height\n3. Draw outline using 4 Line shapes, or fill pixel by pixel\n\n## Acceptance Criteria\n- [ ] Draws rectangle outline\n- [ ] Supports filled rectangles\n- [ ] Correct coordinate transformation\n- [ ] Clips at canvas bounds\n- [ ] Custom color support\n\n## Files to Create/Modify\n- Add to: src/widgets/canvas/shapes.zig","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-02T07:17:41.710079090Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:17:41.710079090Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-207","title":"Hidden text attribute","description":"## Summary\nAdd Style.hidden() text attribute support for rendering invisible text.\n\n## Background\nThe hidden/invisible text attribute (ANSI SGR code 8) renders text that takes up space but is not visible. Use cases:\n- Password input fields (show cursor position without revealing content)\n- Placeholder text that affects layout but isn't shown\n- Security-sensitive data masking\n\n## Requirements\n\n### API Addition\nAdd to Style:\n```zig\npub const Style = struct {\n    // ... existing fields\n    hidden: ?bool = null,\n    \n    pub fn hidden(self: Style) Style {\n        var s = self;\n        s.hidden = true;\n        return s;\n    }\n    \n    pub fn notHidden(self: Style) Style {\n        var s = self;\n        s.hidden = false;\n        return s;\n    }\n};\n```\n\n### ANSI Codes\n- Enable hidden: ESC[8m\n- Disable hidden: ESC[28m\n\n### Integration with rich_zig\nCheck if rich_zig.Style already supports hidden:\n- If yes: expose through zithril wrapper\n- If no: file upstream issue for rich_zig\n\n### Terminal Support\nHidden text support varies by terminal:\n- Most modern terminals: Supported\n- Some terminals: Render as visible or blank\n- Consider: Document terminal compatibility\n\n## Acceptance Criteria\n- [ ] Style.hidden() method available\n- [ ] Renders correct ANSI escape code\n- [ ] Style.patch() merges hidden attribute\n- [ ] Works with other style attributes\n\n## Files to Modify\n- src/style.zig (add hidden attribute)\n- May require rich_zig upstream change","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-02T07:18:51.597886377Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:18:51.597886377Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-24d","title":"Chart widget","description":"## Summary\nImplement a Chart widget for rendering line graphs and scatter plots with configurable axes, multiple datasets, and legends.\n\n## Background\nratatui's Chart widget is the most complex data visualization widget, supporting:\n- Line graphs with connected points\n- Scatter plots with individual markers\n- Multiple datasets with different styles\n- X and Y axes with labels and bounds\n- Legends for dataset identification\n\nThis is an epic with subtasks for: Axis rendering, Line dataset, Scatter dataset.\n\n## Requirements\n\n### Data Model\n```zig\npub const Dataset = struct {\n    name: []const u8 = \"\",\n    data: []const [2]f64,  // [[x, y], [x, y], ...]\n    graph_type: enum { line, scatter } = .line,\n    marker: ?u21 = null,  // e.g., '●', '■', '◆'\n    style: Style = .{},\n};\n\npub const Axis = struct {\n    title: []const u8 = \"\",\n    bounds: [2]f64,  // [min, max]\n    labels: []const []const u8 = &.{},\n    style: Style = .{},\n};\n\npub const Chart = struct {\n    datasets: []const Dataset,\n    x_axis: Axis,\n    y_axis: Axis,\n    style: Style = .{},\n    // ... render method\n};\n```\n\n### Coordinate Mapping\n- Transform data coordinates to screen coordinates\n- screen_x = area.x + ((data_x - x_min) / (x_max - x_min)) * area.width\n- screen_y = area.y + area.height - ((data_y - y_min) / (y_max - y_min)) * area.height\n\n### Layout\n```\nY Title\n│\n│     ●───●\n│   ●/     \\●\n│  /         \\\n│ ●           ●\n└──────────────────\n  0  1  2  3  4  5\n      X Title\n```\n\n## Subtasks\n1. **Axis rendering** - X/Y axes with ticks, labels, titles\n2. **Line dataset** - Connect points with lines using line-drawing chars\n3. **Scatter dataset** - Render individual point markers\n\n## Implementation Hints\n- Reserve space for axes before plotting data\n- Use Braille characters for higher resolution (optional)\n- Line drawing: '─', '│', '┌', '┐', '└', '┘', '/', '\\'\n- Consider anti-aliased line rendering with Unicode blocks\n\n## Acceptance Criteria\n- [ ] Render X and Y axes with labels\n- [ ] Plot line datasets with connected points\n- [ ] Plot scatter datasets with markers\n- [ ] Support multiple datasets\n- [ ] Auto-scale axes to data bounds\n- [ ] Custom styling per dataset\n\n## Files to Create/Modify\n- Create: src/widgets/chart.zig\n- Create: src/widgets/chart/axis.zig\n- Create: src/widgets/chart/dataset.zig\n- Modify: src/widgets.zig","status":"open","priority":1,"issue_type":"epic","created_at":"2026-02-02T07:15:41.149220269Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:16:22.132566291Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-24d","depends_on_id":"bd-128","type":"blocks","created_at":"2026-02-02T07:16:22.022209620Z","created_by":"hotschmoe","metadata":"{}","thread_id":""},{"issue_id":"bd-24d","depends_on_id":"bd-1qm","type":"blocks","created_at":"2026-02-02T07:16:22.077533626Z","created_by":"hotschmoe","metadata":"{}","thread_id":""},{"issue_id":"bd-24d","depends_on_id":"bd-ad4","type":"blocks","created_at":"2026-02-02T07:16:22.132522189Z","created_by":"hotschmoe","metadata":"{}","thread_id":""}]}
{"id":"bd-2it","title":"LineGauge widget","description":"## Summary\nImplement a LineGauge widget that renders progress as a thin horizontal line, providing a more compact alternative to the full Gauge widget.\n\n## Background\nratatui's LineGauge uses a single line to show progress, ideal for:\n- Compact status bars\n- Inline progress indicators\n- Multiple gauges in limited vertical space\n\n## Requirements\n\n### Widget Structure\n```zig\npub const LineGauge = struct {\n    ratio: f32 = 0.0,  // 0.0 to 1.0\n    label: ?[]const u8 = null,\n    style: Style = .{},           // unfilled portion\n    gauge_style: Style = .{},     // filled portion\n    line_set: LineSet = .normal,\n    \n    pub const LineSet = enum {\n        normal,   // ━ (box drawing)\n        thick,    // █ (full block)\n        thin,     // ─ (light horizontal)\n    };\n};\n```\n\n### Rendering\n```\n[━━━━━━━━━━━━━━━━━━━━────────────────────] 50%\n^                    ^                    ^  ^\nfilled portion       unfilled portion     ]  label\n```\n\nSingle-line height, full width utilization.\n\n### Line Characters\n- Normal: '━' (0x2501, box drawings heavy horizontal)\n- Thick: '█' (0x2588, full block) for filled, ' ' for unfilled\n- Thin: '─' (0x2500, box drawings light horizontal)\n\n### Label Positioning\n- If label provided, display at right end or center\n- Label should show over the gauge (use reverse style or contrasting color)\n- Auto-format ratio as percentage if no label: \"50%\"\n\n### Sub-character Resolution\nFor partial cells, use fractional blocks:\n- '▏' (0x258F) - 1/8 block\n- '▎' (0x258E) - 1/4 block\n- '▍' (0x258D) - 3/8 block\n- '▌' (0x258C) - 1/2 block\n- '▋' (0x258B) - 5/8 block\n- '▊' (0x258A) - 3/4 block\n- '▉' (0x2589) - 7/8 block\n\n## Implementation Hints\n- filled_width = @intFromFloat(ratio * @floatFromInt(area.width))\n- Use fractional block for the transition cell\n- Simpler than Gauge (no multi-row layout)\n\n## Acceptance Criteria\n- [ ] Renders single-line progress bar\n- [ ] Supports 0.0 to 1.0 ratio\n- [ ] Configurable line characters\n- [ ] Optional label (default: percentage)\n- [ ] Separate styles for filled/unfilled\n- [ ] Sub-character resolution for smooth progress\n\n## Files to Create/Modify\n- Create: src/widgets/line_gauge.zig\n- Modify: src/widgets.zig (add export)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-02T07:16:59.004297725Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:16:59.004297725Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2ke","title":"Sparkline widget","description":"## Summary\nImplement a Sparkline widget for compact inline data visualization, rendering a series of numeric values as vertical bars within a single line of text.\n\n## Background\nratatui provides a Sparkline widget that displays data trends in minimal space. This is commonly used for:\n- CPU/memory usage history\n- Stock price trends\n- Network throughput graphs\n- Any time-series data in dashboards\n\n## Requirements\n\n### Core Functionality\n- Accept a slice of numeric values (f64 or u64)\n- Auto-scale values to fit available height (typically 1-2 rows)\n- Use Unicode block characters for sub-cell resolution: ' ', '▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'\n- Handle empty data gracefully (render nothing or placeholder)\n- Clip data to available width (show most recent N values)\n\n### Configuration Options\n- `data: []const f64` - Values to display\n- `max: ?f64` - Optional explicit maximum (auto-detect if null)\n- `style: Style` - Style for the bars\n- `direction: enum { left_to_right, right_to_left }` - Data flow direction\n\n### Rendering\n- Map each value to a bar height (0-8 levels using block chars)\n- Each bar occupies exactly 1 cell width\n- Values exceeding max should clamp to full bar\n\n## Implementation Hints\n- Block characters: const BARS = [_]u21{ ' ', 0x2581, 0x2582, 0x2583, 0x2584, 0x2585, 0x2586, 0x2587, 0x2588 };\n- Height index = @intFromFloat(@round(normalized_value * 8))\n- See ratatui sparkline.rs for reference\n\n## Acceptance Criteria\n- [ ] Renders data as vertical bars using Unicode blocks\n- [ ] Auto-scales to data range when max not specified\n- [ ] Clips to available width\n- [ ] Supports custom styling\n- [ ] Handles edge cases (empty data, single value, all zeros)\n\n## Files to Create/Modify\n- Create: src/widgets/sparkline.zig\n- Modify: src/widgets.zig (add export)","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-02-02T07:14:43.660952683Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:34:57.027610968Z","closed_at":"2026-02-02T07:34:57.027596126Z","close_reason":"Completed via hot_ralph plan mode","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2nk","title":"Canvas: Line shape","description":"## Summary\nImplement a Line shape for the Canvas widget using Bresenham's line algorithm.\n\n## Parent Epic\nCanvas widget (bd-2us)\n\n## Requirements\n\n### Shape Structure\n```zig\npub const Line = struct {\n    x1: f64,          // start x in virtual coords\n    y1: f64,          // start y in virtual coords\n    x2: f64,          // end x in virtual coords\n    y2: f64,          // end y in virtual coords\n    color: Color = .white,\n    \n    pub fn shape(self: *const Line) Shape {\n        return Shape.init(self, draw);\n    }\n    \n    fn draw(self: *const Line, painter: *Painter) void { ... }\n};\n```\n\n### Bresenham's Line Algorithm\n```zig\nfn drawLine(painter: *Painter, x0: i32, y0: i32, x1: i32, y1: i32, color: Color) void {\n    var x = x0;\n    var y = y0;\n    const dx = @abs(x1 - x0);\n    const dy = @abs(y1 - y0);\n    const sx: i32 = if (x0 < x1) 1 else -1;\n    const sy: i32 = if (y0 < y1) 1 else -1;\n    var err = dx - dy;\n    \n    while (true) {\n        painter.setPixel(x, y, color);\n        if (x == x1 and y == y1) break;\n        \n        const e2 = 2 * err;\n        if (e2 > -dy) {\n            err -= dy;\n            x += sx;\n        }\n        if (e2 < dx) {\n            err += dx;\n            y += sy;\n        }\n    }\n}\n```\n\n### Coordinate Handling\n1. Transform endpoints from virtual to screen coordinates\n2. Apply line algorithm in screen space\n3. Handle lines that extend outside canvas bounds\n\n### Line Clipping (Cohen-Sutherland)\nFor lines partially outside bounds:\n```zig\nconst INSIDE: u4 = 0;\nconst LEFT: u4 = 1;\nconst RIGHT: u4 = 2;\nconst BOTTOM: u4 = 4;\nconst TOP: u4 = 8;\n\nfn computeOutCode(x: f64, y: f64, bounds: Bounds) u4 { ... }\nfn clipLine(x0: *f64, y0: *f64, x1: *f64, y1: *f64, bounds: Bounds) bool { ... }\n```\n\n## Acceptance Criteria\n- [ ] Draws line between two points\n- [ ] Uses Bresenham algorithm\n- [ ] Clips lines at canvas bounds\n- [ ] Custom color support\n- [ ] Handles all line orientations (horizontal, vertical, diagonal)\n\n## Files to Create/Modify\n- Add to: src/widgets/canvas/shapes.zig","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-02T07:17:35.844850629Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:17:35.844850629Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2os","title":"Canvas: Circle shape","description":"## Summary\nImplement a Circle shape for the Canvas widget using Bresenham's circle algorithm.\n\n## Parent Epic\nCanvas widget (bd-2us)\n\n## Requirements\n\n### Shape Structure\n```zig\npub const Circle = struct {\n    x: f64,           // center x in virtual coords\n    y: f64,           // center y in virtual coords\n    radius: f64,      // radius in virtual coords\n    color: Color = .white,\n    \n    pub fn shape(self: *const Circle) Shape {\n        return Shape.init(self, draw);\n    }\n    \n    fn draw(self: *const Circle, painter: *Painter) void { ... }\n};\n```\n\n### Bresenham's Circle Algorithm\nEfficient integer-based circle drawing:\n```zig\nfn drawCircle(painter: *Painter, cx: i32, cy: i32, r: i32, color: Color) void {\n    var x: i32 = 0;\n    var y: i32 = r;\n    var d: i32 = 3 - 2 * r;\n    \n    while (x <= y) {\n        // Draw 8 symmetric points\n        painter.setPixel(cx + x, cy + y, color);\n        painter.setPixel(cx - x, cy + y, color);\n        painter.setPixel(cx + x, cy - y, color);\n        painter.setPixel(cx - x, cy - y, color);\n        painter.setPixel(cx + y, cy + x, color);\n        painter.setPixel(cx - y, cy + x, color);\n        painter.setPixel(cx + y, cy - x, color);\n        painter.setPixel(cx - y, cy - x, color);\n        \n        if (d < 0) {\n            d = d + 4 * x + 6;\n        } else {\n            d = d + 4 * (x - y) + 10;\n            y -= 1;\n        }\n        x += 1;\n    }\n}\n```\n\n### Coordinate Handling\n1. Transform center (x, y) from virtual to screen coordinates\n2. Scale radius based on coordinate system aspect ratio\n3. Draw circle in screen space\n\n### Edge Cases\n- Circle partially outside canvas bounds (clip)\n- Very small radius (single point)\n- Very large radius (only arc visible)\n\n## Acceptance Criteria\n- [ ] Draws circle outline at specified center and radius\n- [ ] Uses Bresenham algorithm for efficiency\n- [ ] Handles partial visibility (clipping)\n- [ ] Custom color support\n- [ ] Integrates with Canvas Shape interface\n\n## Files to Create/Modify\n- Add to: src/widgets/canvas/shapes.zig","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-02T07:17:28.847288445Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:17:28.847288445Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-2us","title":"Canvas widget","description":"## Summary\nImplement a Canvas widget providing a coordinate-based drawing surface for arbitrary shapes using terminal characters.\n\n## Background\nratatui's Canvas widget enables:\n- Custom data visualizations\n- Games and graphics demos\n- World maps and geographic displays\n- Diagrams and flowcharts\n\nThis is an epic with subtasks for individual shapes: Circle, Line, Rectangle, Points, Shape trait.\n\n## Requirements\n\n### Core Architecture\n```zig\npub const Canvas = struct {\n    x_bounds: [2]f64,  // [min, max]\n    y_bounds: [2]f64,  // [min, max]\n    marker: Marker = .braille,\n    background_color: Color = .default,\n    \n    pub const Marker = enum {\n        dot,      // '•'\n        block,    // '█' and fractional blocks\n        braille,  // 2x4 Braille patterns for high resolution\n        half_block, // '▄', '▀' for 1x2 resolution\n    };\n};\n```\n\n### Coordinate System\n- Canvas has virtual coordinates (x_bounds, y_bounds)\n- Shapes specify positions in virtual coordinates\n- Canvas maps virtual -> screen coordinates during render\n\n```zig\nfn virtualToScreen(self: Canvas, x: f64, y: f64, area: Rect) ?struct { x: u16, y: u16 } {\n    if (x < self.x_bounds[0] or x > self.x_bounds[1]) return null;\n    if (y < self.y_bounds[0] or y > self.y_bounds[1]) return null;\n    \n    const x_ratio = (x - self.x_bounds[0]) / (self.x_bounds[1] - self.x_bounds[0]);\n    const y_ratio = (y - self.y_bounds[0]) / (self.y_bounds[1] - self.y_bounds[0]);\n    \n    return .{\n        .x = area.x + @intFromFloat(x_ratio * @floatFromInt(area.width)),\n        .y = area.y + area.height - 1 - @intFromFloat(y_ratio * @floatFromInt(area.height)),\n    };\n}\n```\n\n### Braille Rendering\nEach cell contains a 2x4 dot grid using Unicode Braille patterns (0x2800-0x28FF):\n```\n⡀ ⠄   Dot positions:\n⠂ ⠐   0 3\n⠁ ⠈   1 4\n      2 5\n      6 7\n```\n\nPattern = 0x2800 + (sum of 2^position for each set dot)\n\n### Painter Context\n```zig\npub const Painter = struct {\n    canvas: *Canvas,\n    buffer: *Buffer,\n    area: Rect,\n    \n    /// Set a point in virtual coordinates\n    pub fn paint(self: *Painter, x: f64, y: f64, color: Color) void { ... }\n    \n    /// Draw a line between two points\n    pub fn line(self: *Painter, x1: f64, y1: f64, x2: f64, y2: f64, color: Color) void { ... }\n};\n```\n\n### Shape Interface\n```zig\npub const Shape = struct {\n    drawFn: *const fn (shape: *const anyopaque, painter: *Painter) void,\n    ptr: *const anyopaque,\n    \n    pub fn draw(self: Shape, painter: *Painter) void {\n        self.drawFn(self.ptr, painter);\n    }\n};\n```\n\n## Subtasks\n1. **Circle shape** - Circle with center and radius\n2. **Line shape** - Line between two points\n3. **Rectangle shape** - Rectangle outline or filled\n4. **Points shape** - Scatter of individual points\n5. **Shape trait** - Interface for custom shapes\n\n## Acceptance Criteria\n- [ ] Canvas with virtual coordinate system\n- [ ] Multiple marker modes (dot, block, braille)\n- [ ] Coordinate transformation virtual -> screen\n- [ ] Painter context for drawing operations\n- [ ] Shape interface for extensibility\n- [ ] All built-in shapes render correctly\n\n## Files to Create/Modify\n- Create: src/widgets/canvas.zig\n- Create: src/widgets/canvas/painter.zig\n- Create: src/widgets/canvas/shapes.zig\n- Modify: src/widgets.zig (add exports)","status":"open","priority":2,"issue_type":"epic","created_at":"2026-02-02T07:17:15.064906285Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:18:02.287002824Z","source_repo":".","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"bd-2us","depends_on_id":"bd-1jl","type":"blocks","created_at":"2026-02-02T07:18:02.239584125Z","created_by":"hotschmoe","metadata":"{}","thread_id":""},{"issue_id":"bd-2us","depends_on_id":"bd-1zo","type":"blocks","created_at":"2026-02-02T07:18:02.188567107Z","created_by":"hotschmoe","metadata":"{}","thread_id":""},{"issue_id":"bd-2us","depends_on_id":"bd-2nk","type":"blocks","created_at":"2026-02-02T07:18:02.134237506Z","created_by":"hotschmoe","metadata":"{}","thread_id":""},{"issue_id":"bd-2us","depends_on_id":"bd-2os","type":"blocks","created_at":"2026-02-02T07:18:02.079693067Z","created_by":"hotschmoe","metadata":"{}","thread_id":""},{"issue_id":"bd-2us","depends_on_id":"bd-lsj","type":"blocks","created_at":"2026-02-02T07:18:02.286973715Z","created_by":"hotschmoe","metadata":"{}","thread_id":""}]}
{"id":"bd-2zv","title":"BarChart widget","description":"## Summary\nImplement a BarChart widget for displaying datasets as grouped vertical or horizontal bars with labels, values, and optional grouping.\n\n## Background\nratatui's BarChart widget is essential for dashboards displaying comparative data like:\n- System resource usage across processes\n- Sales figures by category\n- Performance metrics comparison\n- Survey results visualization\n\n## Requirements\n\n### Data Model\n```zig\npub const Bar = struct {\n    value: f64,\n    label: []const u8 = \"\",\n    style: Style = .{},\n    value_style: Style = .{},\n};\n\npub const BarGroup = struct {\n    label: []const u8 = \"\",\n    bars: []const Bar,\n};\n\npub const BarChart = struct {\n    groups: []const BarGroup,\n    direction: enum { vertical, horizontal } = .vertical,\n    bar_width: u16 = 1,\n    bar_gap: u16 = 1,\n    group_gap: u16 = 2,\n    max_value: ?f64 = null,  // auto-detect if null\n    show_values: bool = true,\n    label_style: Style = .{},\n    // ... render method\n};\n```\n\n### Vertical Bar Rendering\n```\n   ██      \n   ██  ██  \n   ██  ██  ▄▄\n   ██  ██  ██\n  foo bar baz\n```\n- Bars grow upward from baseline\n- Labels below bars\n- Optional value display above bars\n- Use block characters for sub-cell resolution\n\n### Horizontal Bar Rendering\n```\nfoo ████████████ 75\nbar ██████ 45\nbaz ████████████████ 100\n```\n- Bars grow rightward from labels\n- Values optionally shown at end\n\n### Grouping\nMultiple bars per group with group labels:\n```\n      Q1        Q2\n   ██     ██ ██    \n   ██ ▄▄  ██ ██ ▄▄\n  2024   2025\n```\n\n## Implementation Hints\n- Calculate max value across all groups if not specified\n- Bar height = (value / max) * available_height\n- Use same block chars as Sparkline: '▁▂▃▄▅▆▇█'\n- Handle bar_width > 1 by repeating characters\n- Clip bars that exceed area bounds\n\n## Acceptance Criteria\n- [ ] Single bar rendering with label\n- [ ] Multiple ungrouped bars\n- [ ] Grouped bars with group labels\n- [ ] Vertical and horizontal orientations\n- [ ] Configurable bar width and gaps\n- [ ] Auto-scaling to max value\n- [ ] Value labels (optional)\n- [ ] Custom styling per bar\n\n## Files to Create/Modify\n- Create: src/widgets/bar_chart.zig\n- Modify: src/widgets.zig (add export)","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-02-02T07:15:30.283669690Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:41:40.839060315Z","closed_at":"2026-02-02T07:41:40.839027543Z","close_reason":"Completed via hot_ralph plan mode","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-446","title":"CodeEditor widget","description":"## Summary\nImplement a CodeEditor widget with syntax highlighting, line numbers, and editing capabilities.\n\n## Background\nCode editor widgets enable:\n- Source code viewing with highlighting\n- In-TUI code editing\n- Log file viewing with syntax awareness\n- Configuration file editing\n\nThis is a complex widget requiring syntax highlighting integration.\n\n## Requirements\n\n### Widget Structure\n```zig\npub const CodeEditor = struct {\n    content: []const u8,\n    language: ?Language = null,\n    show_line_numbers: bool = true,\n    highlight_current_line: bool = true,\n    tab_width: u8 = 4,\n    style: Style = .{},\n    line_number_style: Style = .{},\n    current_line_style: Style = .{},\n    \n    pub const Language = enum {\n        zig,\n        rust,\n        python,\n        javascript,\n        json,\n        yaml,\n        markdown,\n        // ...\n    };\n};\n```\n\n### Syntax Highlighting Approaches\n1. **Simple keyword-based**: Built-in rules for common patterns\n2. **Tree-sitter integration**: Full parsing (complex, external dependency)\n3. **Regex-based**: Pattern matching for tokens\n\n### Simple Highlighting (Recommended Start)\n```zig\npub const TokenType = enum {\n    keyword,\n    string,\n    number,\n    comment,\n    operator,\n    function,\n    type,\n    normal,\n};\n\npub const Theme = struct {\n    keyword: Style,\n    string: Style,\n    number: Style,\n    comment: Style,\n    operator: Style,\n    function: Style,\n    type: Style,\n};\n```\n\n### Zig-specific Keywords\n```zig\nconst zig_keywords = [_][]const u8{\n    \"const\", \"var\", \"fn\", \"pub\", \"return\", \"if\", \"else\",\n    \"while\", \"for\", \"switch\", \"break\", \"continue\", \"struct\",\n    \"enum\", \"union\", \"error\", \"try\", \"catch\", \"defer\",\n    \"comptime\", \"inline\", \"unreachable\", \"undefined\", \"null\",\n    // ...\n};\n```\n\n### Line Numbers\n```\n  1 │ const std = @import(\"std\");\n  2 │ \n  3 │ pub fn main() void {\n  4 │     // ...\n  5 │ }\n```\n\n### Editing State (Optional)\n```zig\npub const EditorState = struct {\n    cursor_line: usize = 0,\n    cursor_col: usize = 0,\n    scroll_offset: usize = 0,\n    selection: ?Selection = null,\n    \n    pub const Selection = struct {\n        start_line: usize,\n        start_col: usize,\n        end_line: usize,\n        end_col: usize,\n    };\n};\n```\n\n## Implementation Phases\n1. Basic line display with line numbers\n2. Simple keyword highlighting (no parsing)\n3. String and comment detection\n4. Cursor and editing (optional, complex)\n\n## Acceptance Criteria\n- [ ] Renders code with line numbers\n- [ ] Basic syntax highlighting (keywords, strings, comments)\n- [ ] Horizontal scrolling for long lines\n- [ ] Vertical scrolling\n- [ ] Current line highlighting\n- [ ] At least Zig language support\n\n## Complexity Warning\nThis is a high-effort feature. Consider:\n- Starting with view-only (no editing)\n- Simple pattern-based highlighting\n- Deferring tree-sitter integration\n\n## Files to Create/Modify\n- Create: src/widgets/code_editor.zig\n- Create: src/widgets/code_editor/highlighter.zig\n- Create: src/widgets/code_editor/languages.zig\n- Modify: src/widgets.zig (add export)","status":"open","priority":4,"issue_type":"feature","created_at":"2026-02-02T07:19:17.578576640Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:19:17.578576640Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-5s1","title":"Calendar widget","description":"## Summary\nImplement a Calendar widget for monthly calendar display with date selection and event markers.\n\n## Background\nCalendar widgets are useful for:\n- Date pickers\n- Event scheduling displays\n- Deadline tracking\n- Activity heatmaps\n\n## Requirements\n\n### Widget Structure\n```zig\npub const Calendar = struct {\n    year: i32,\n    month: u8,  // 1-12\n    selected_day: ?u8 = null,\n    show_adjacent_months: bool = true,\n    show_week_numbers: bool = false,\n    style: Style = .{},\n    today_style: Style = .{},\n    selected_style: Style = .{},\n    adjacent_style: Style = .{},  // for days from prev/next month\n    header_style: Style = .{},\n    \n    /// Optional: days with events/markers\n    marked_days: []const u8 = &.{},\n    marked_style: Style = .{},\n};\n```\n\n### Visual Layout\n```\n     January 2026\nSu Mo Tu We Th Fr Sa\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29 30 31\n```\n\nWith adjacent months:\n```\n     January 2026\nSu Mo Tu We Th Fr Sa\n28 29 30 31  1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29 30 31\n 1  2  3  4  5  6  7\n```\n\n### Date Calculations\n```zig\nfn daysInMonth(year: i32, month: u8) u8 {\n    const days = [_]u8{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    if (month == 2 and isLeapYear(year)) return 29;\n    return days[month - 1];\n}\n\nfn isLeapYear(year: i32) bool {\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0);\n}\n\nfn dayOfWeek(year: i32, month: u8, day: u8) u8 {\n    // Zeller's congruence or similar\n    // Returns 0=Sunday, 1=Monday, ..., 6=Saturday\n}\n```\n\n### Dimensions\n- Width: 7 days * 3 chars = 21 chars (minimum)\n- Height: header + weekdays + 6 rows = 8 rows (minimum)\n\n### Navigation\n- Left/Right: Previous/next day\n- Up/Down: Previous/next week\n- PageUp/PageDown: Previous/next month\n- Home: First day of month\n- End: Last day of month\n\n## Acceptance Criteria\n- [ ] Renders monthly calendar grid\n- [ ] Correct day-of-week alignment\n- [ ] Month/year header\n- [ ] Day selection highlighting\n- [ ] Today highlighting\n- [ ] Adjacent month days (optional)\n- [ ] Week numbers (optional)\n- [ ] Event markers\n\n## Files to Create/Modify\n- Create: src/widgets/calendar.zig\n- Modify: src/widgets.zig (add export)","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-02T07:18:44.772173953Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:18:44.772173953Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-ad4","title":"Chart: Scatter dataset rendering","description":"## Summary\nImplement scatter plot dataset rendering for the Chart widget, displaying individual point markers without connecting lines.\n\n## Parent Epic\nChart widget (bd-24d)\n\n## Requirements\n\n### Scatter Rendering\nDisplay each data point as an individual marker at its screen position.\n\n### Data Structure\n```zig\npub const ScatterDataset = struct {\n    name: []const u8 = \"\",\n    data: []const [2]f64,  // [[x, y], ...]\n    marker: u21 = '●',\n    style: Style = .{},\n};\n```\n\n### Available Markers\n```zig\npub const Markers = struct {\n    pub const dot = '●';        // U+25CF\n    pub const circle = '○';     // U+25CB\n    pub const square = '■';     // U+25A0\n    pub const square_empty = '□'; // U+25A1\n    pub const diamond = '◆';    // U+25C6\n    pub const diamond_empty = '◇'; // U+25C7\n    pub const triangle_up = '▲'; // U+25B2\n    pub const triangle_down = '▼'; // U+25BC\n    pub const star = '★';       // U+2605\n    pub const cross = '✕';      // U+2715\n    pub const plus = '+';\n    pub const x = '×';          // U+00D7\n};\n```\n\n### Rendering Logic\nFor each data point:\n1. Transform (x, y) to screen coordinates\n2. Check if within chart area bounds\n3. Place marker character at position with dataset style\n\n### Handling Overlapping Points\nWhen multiple points map to the same cell:\n- Option 1: Last point wins (simple)\n- Option 2: Use different character to indicate density\n- Option 3: Blend styles if supported\n\n## Implementation Hints\n- Simpler than line rendering (no interpolation needed)\n- Share coordinate transformation with line dataset\n- Handle points exactly on boundaries\n- Consider density indication for overlapping points\n\n## Acceptance Criteria\n- [ ] Render markers at data point positions\n- [ ] Support configurable marker characters\n- [ ] Handle points outside chart bounds (clip)\n- [ ] Support multiple scatter datasets\n- [ ] Custom styling per dataset\n\n## Files to Create/Modify\n- Create: src/widgets/chart/scatter.zig (or inline in chart.zig)","status":"open","priority":1,"issue_type":"task","created_at":"2026-02-02T07:16:15.720709989Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:16:15.720709989Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-d42","title":"Percentage layout constraint","description":"## Summary\nAdd a Constraint.percentage(n) variant for percentage-based layout allocation, providing a more intuitive API for common layout patterns.\n\n## Background\nratatui supports Constraint::Percentage(n) which allocates n% of available space. zithril can approximate this with ratio(n, 100) but a dedicated percentage constraint is more readable and commonly expected.\n\n## Requirements\n\n### API Design\nAdd to the Constraint union in layout.zig:\n```zig\npub const Constraint = union(enum) {\n    // ... existing variants\n    percentage: u8,  // 0-100, values >100 treated as 100\n    \n    pub fn percentage(n: u8) Constraint {\n        return .{ .percentage = @min(n, 100) };\n    }\n};\n```\n\n### Solver Integration\nIn the layout solver, percentage constraints should:\n1. Be resolved after fixed constraints (length, min) \n2. Calculate: allocated = (available_space * percentage) / 100\n3. Use integer math to avoid floating point\n4. Handle rounding (prefer floor, distribute remainder to flex)\n\n### Edge Cases\n- percentage(0) = 0 cells\n- percentage(100) = all remaining space\n- percentage(50) + percentage(50) = exact split\n- Percentages exceeding 100% total should proportionally scale down\n\n## Implementation Hints\n- Add variant to Constraint union\n- Update layout() solver phases to handle percentage\n- Percentage is like ratio(n, 100) but clearer intent\n- Test with: 25%, 50%, 75%, 100%, mixed with other constraints\n\n## Acceptance Criteria\n- [ ] Constraint.percentage(n) API available\n- [ ] Correctly calculates percentage of available space\n- [ ] Values >100 clamped to 100\n- [ ] Works correctly with other constraint types\n- [ ] Rounding behavior is consistent\n\n## Files to Modify\n- src/layout.zig (add variant, update solver)\n- src/root.zig (export if needed)","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-02-02T07:14:58.934243287Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:34:57.099262117Z","closed_at":"2026-02-02T07:34:57.099248604Z","close_reason":"Completed via hot_ralph plan mode","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-lsj","title":"Canvas: Shape trait interface","description":"## Summary\nImplement the Shape trait interface for Canvas extensibility, allowing users to define custom shapes.\n\n## Parent Epic\nCanvas widget (bd-2us)\n\n## Requirements\n\n### Shape Interface\n```zig\npub const Shape = struct {\n    ptr: *const anyopaque,\n    drawFn: *const fn (ptr: *const anyopaque, painter: *Painter) void,\n    \n    pub fn init(pointer: anytype, drawFn: fn (ptr: @TypeOf(pointer), painter: *Painter) void) Shape {\n        const Ptr = @TypeOf(pointer);\n        const wrapper = struct {\n            fn draw(ptr: *const anyopaque, painter: *Painter) void {\n                const self = @ptrCast(Ptr, @alignCast(ptr));\n                drawFn(self, painter);\n            }\n        };\n        return .{\n            .ptr = pointer,\n            .drawFn = wrapper.draw,\n        };\n    }\n    \n    pub fn draw(self: Shape, painter: *Painter) void {\n        self.drawFn(self.ptr, painter);\n    }\n};\n```\n\n### Canvas Integration\n```zig\npub const Canvas = struct {\n    // ... other fields\n    \n    pub fn render(self: Canvas, area: Rect, buf: *Buffer) void {\n        // ... setup\n    }\n    \n    pub fn draw(self: *Canvas, area: Rect, buf: *Buffer, shapes: []const Shape) void {\n        var painter = Painter.init(self, buf, area);\n        for (shapes) |shape| {\n            shape.draw(&painter);\n        }\n    }\n};\n```\n\n### Usage Example\n```zig\nconst MyCustomShape = struct {\n    data: []const f64,\n    \n    pub fn shape(self: *const MyCustomShape) Shape {\n        return Shape.init(self, draw);\n    }\n    \n    fn draw(self: *const MyCustomShape, painter: *Painter) void {\n        // Custom drawing logic\n        for (self.data, 0..) |value, i| {\n            painter.paint(@floatFromInt(i), value, .green);\n        }\n    }\n};\n\n// Usage\nconst my_shape = MyCustomShape{ .data = &[_]f64{ 1, 2, 3, 4 } };\ncanvas.draw(area, buf, &[_]Shape{ my_shape.shape() });\n```\n\n### Type Erasure\nThe Shape interface uses type erasure to allow heterogeneous shape collections:\n- Store pointer to concrete shape\n- Store function pointer for draw\n- At runtime, dispatch to concrete implementation\n\n## Acceptance Criteria\n- [ ] Shape interface defined\n- [ ] Type-erased function dispatch\n- [ ] Works with built-in shapes (Circle, Line, Rectangle, Points)\n- [ ] Users can implement custom shapes\n- [ ] Canvas.draw accepts slice of Shapes\n\n## Files to Create/Modify\n- Create: src/widgets/canvas/shape.zig\n- Integrate in: src/widgets/canvas.zig","status":"open","priority":2,"issue_type":"task","created_at":"2026-02-02T07:17:56.159646863Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:17:56.159646863Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-mlx","title":"Flex alignment modes for layout","description":"## Summary\nAdd a Flex enum to control how excess space is distributed in layouts, enabling CSS Flexbox-like alignment patterns.\n\n## Background\nratatui's Flex enum provides 7 alignment modes for distributing excess space when constraints don't fill the available area. zithril currently only supports \"Legacy\" mode (excess goes to final element).\n\n## Requirements\n\n### Flex Enum\n```zig\npub const Flex = enum {\n    /// Content at start, all excess space at end (default)\n    start,\n    /// Content at end, all excess space at start  \n    end,\n    /// Content centered, excess space split evenly on sides\n    center,\n    /// Space distributed between items, none at edges\n    space_between,\n    /// Equal space around each item (half-space at edges)\n    space_around,\n    /// Equal gaps everywhere including edges\n    space_evenly,\n    /// Legacy: excess space goes to last flex element\n    legacy,\n};\n```\n\n### API Changes\nUpdate layout() signature:\n```zig\npub fn layout(\n    area: Rect,\n    direction: Direction,\n    constraints: []const Constraint,\n    flex: Flex,  // NEW parameter\n) BoundedRects\n```\n\nOr add a Layout struct for builder pattern:\n```zig\nconst Layout = struct {\n    direction: Direction = .vertical,\n    flex: Flex = .start,\n    margin: u16 = 0,\n    \n    pub fn split(self: Layout, area: Rect, constraints: []const Constraint) BoundedRects\n};\n```\n\n### Space Distribution Algorithms\nGiven N items and E excess pixels:\n\n- **start**: items at positions [0..], excess after last item\n- **end**: items at positions [E..], excess before first item  \n- **center**: items at positions [E/2..], excess split on sides\n- **space_between**: gaps = E / (N-1) between items, none at edges\n- **space_around**: gaps = E / N around items, half at edges\n- **space_evenly**: gaps = E / (N+1) everywhere including edges\n\n### Edge Cases\n- Single item: start/end/center all work, space_* = center\n- No excess space: all modes behave identically\n- Fractional gaps: distribute remainder left-to-right\n\n## Implementation Hints\n- Calculate total constraint allocation first\n- excess = available - total_allocated\n- Apply Flex distribution to starting positions\n- Consider making Flex optional with default .start\n\n## Acceptance Criteria\n- [ ] Flex enum with all 7 modes\n- [ ] layout() accepts Flex parameter\n- [ ] Each mode distributes space correctly\n- [ ] Works with both horizontal and vertical directions\n- [ ] Edge cases handled (single item, no excess, overflow)\n\n## Files to Modify\n- src/layout.zig (add Flex enum, update solver)\n- src/frame.zig (update layout method signature)","status":"closed","priority":0,"issue_type":"feature","created_at":"2026-02-02T07:15:12.664654543Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:41:40.774707510Z","closed_at":"2026-02-02T07:41:40.774691382Z","close_reason":"Completed via hot_ralph plan mode","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-ms6","title":"Padding and Margin types","description":"## Summary\nAdd Padding, Margin, and Spacing struct types for convenient layout spacing configuration.\n\n## Background\nratatui provides dedicated types for spacing that make layout code more readable and maintainable. zithril currently requires manual Rect calculations for spacing.\n\n## Requirements\n\n### Padding Type\nFor interior spacing within a widget (e.g., Block content inset):\n```zig\npub const Padding = struct {\n    top: u16 = 0,\n    right: u16 = 0,\n    bottom: u16 = 0,\n    left: u16 = 0,\n    \n    /// All sides equal\n    pub fn all(value: u16) Padding {\n        return .{ .top = value, .right = value, .bottom = value, .left = value };\n    }\n    \n    /// Horizontal (left/right) and vertical (top/bottom)\n    pub fn symmetric(horizontal: u16, vertical: u16) Padding {\n        return .{ .top = vertical, .right = horizontal, .bottom = vertical, .left = horizontal };\n    }\n    \n    /// Horizontal only (left and right)\n    pub fn horizontal(value: u16) Padding {\n        return .{ .left = value, .right = value };\n    }\n    \n    /// Vertical only (top and bottom)\n    pub fn vertical(value: u16) Padding {\n        return .{ .top = value, .bottom = value };\n    }\n    \n    /// Apply padding to shrink a Rect\n    pub fn apply(self: Padding, rect: Rect) Rect {\n        const new_x = rect.x +| self.left;\n        const new_y = rect.y +| self.top;\n        const new_w = rect.width -| (self.left +| self.right);\n        const new_h = rect.height -| (self.top +| self.bottom);\n        return Rect.init(new_x, new_y, new_w, new_h);\n    }\n};\n```\n\n### Margin Type\nFor exterior spacing around a widget (layout-level):\n```zig\npub const Margin = struct {\n    // Same structure as Padding\n    top: u16 = 0,\n    right: u16 = 0,\n    bottom: u16 = 0,\n    left: u16 = 0,\n    \n    // Same helper constructors as Padding\n    pub fn all(value: u16) Margin { ... }\n    pub fn symmetric(h: u16, v: u16) Margin { ... }\n    \n    /// Apply margin to shrink a Rect (same as padding.apply)\n    pub fn apply(self: Margin, rect: Rect) Rect { ... }\n};\n```\n\n### Spacing Type\nFor gaps between layout elements:\n```zig\npub const Spacing = struct {\n    value: u16,\n    \n    pub fn init(value: u16) Spacing {\n        return .{ .value = value };\n    }\n};\n```\n\n### Integration with Block\nUpdate Block widget to accept Padding:\n```zig\npub const Block = struct {\n    // ... existing fields\n    padding: Padding = .{},\n    \n    pub fn inner(self: Block, area: Rect) Rect {\n        var inner_area = // existing border calculation\n        return self.padding.apply(inner_area);\n    }\n};\n```\n\n### Integration with Layout\nUpdate layout() to optionally accept margin/spacing:\n```zig\npub fn layout(\n    area: Rect,\n    direction: Direction,\n    constraints: []const Constraint,\n    options: LayoutOptions,\n) BoundedRects {\n    // Apply margin first\n    const inner = options.margin.apply(area);\n    // ... rest of layout with spacing between elements\n}\n\npub const LayoutOptions = struct {\n    margin: Margin = .{},\n    spacing: Spacing = .{ .value = 0 },\n    flex: Flex = .start,\n};\n```\n\n## Acceptance Criteria\n- [ ] Padding struct with all/symmetric/horizontal/vertical constructors\n- [ ] Margin struct with same API\n- [ ] Spacing struct for inter-element gaps\n- [ ] apply() method to shrink Rects\n- [ ] Block widget supports padding\n- [ ] Layout optionally accepts margin and spacing\n\n## Files to Modify\n- Create: src/spacing.zig (or add to geometry.zig)\n- Modify: src/widgets/block.zig (add padding)\n- Modify: src/layout.zig (add margin/spacing support)\n- Modify: src/root.zig (exports)","status":"open","priority":1,"issue_type":"feature","created_at":"2026-02-02T07:16:41.941590796Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:16:41.941590796Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-oaf","title":"Menu widget","description":"## Summary\nImplement a Menu widget for nested menu navigation with keyboard support.\n\n## Background\nMenu widgets provide:\n- Application command access\n- Nested navigation structures  \n- Context menus\n- Dropdown selections\n\n## Requirements\n\n### Data Model\n```zig\npub const MenuItem = struct {\n    label: []const u8,\n    shortcut: ?[]const u8 = null,  // e.g., \"Ctrl+S\"\n    children: []const MenuItem = &.{},\n    enabled: bool = true,\n    separator: bool = false,  // true = this is a separator line\n    \n    pub fn isSeparator(self: MenuItem) bool {\n        return self.separator;\n    }\n    \n    pub fn hasChildren(self: MenuItem) bool {\n        return self.children.len > 0;\n    }\n};\n\npub const Menu = struct {\n    items: []const MenuItem,\n    selected: usize = 0,\n    style: Style = .{},\n    highlight_style: Style = .{},\n    disabled_style: Style = .{},\n    width: ?u16 = null,  // auto-calculate if null\n};\n```\n\n### Visual Structure\nVertical menu:\n```\n┌─────────────────────┐\n│ New             Ctrl+N │\n│ Open            Ctrl+O │\n│ Save            Ctrl+S │\n│─────────────────────│\n│ Exit            Ctrl+Q │\n└─────────────────────┘\n```\n\nNested submenu:\n```\n┌─────────────┐\n│ File       ►│──┌─────────────┐\n│ Edit        │  │ New         │\n│ View        │  │ Open        │\n└─────────────┘  │ Save        │\n                 └─────────────┘\n```\n\n### Symbols\n```zig\npub const MenuSymbols = struct {\n    submenu_indicator: []const u8 = \"►\",\n    separator: []const u8 = \"─\",\n    checkbox_checked: []const u8 = \"☑\",\n    checkbox_unchecked: []const u8 = \"☐\",\n    radio_selected: []const u8 = \"◉\",\n    radio_unselected: []const u8 = \"○\",\n};\n```\n\n### Navigation\n- Up/Down: Move selection within current menu\n- Right/Enter: Open submenu (if has children)\n- Left/Escape: Close submenu (go to parent)\n- Enter: Select item (if no children)\n\n### State Management\n```zig\npub const MenuState = struct {\n    /// Stack of selected indices (for nested menus)\n    path: [8]usize = [_]usize{0} ** 8,\n    depth: usize = 0,\n    \n    pub fn current(self: MenuState) usize {\n        return self.path[self.depth];\n    }\n    \n    pub fn enter(self: *MenuState, index: usize) void {\n        self.depth += 1;\n        self.path[self.depth] = index;\n    }\n    \n    pub fn leave(self: *MenuState) void {\n        if (self.depth > 0) self.depth -= 1;\n    }\n};\n```\n\n### Width Calculation\nAuto-calculate width based on:\n- Longest label + shortcut\n- Padding (1-2 chars each side)\n- Submenu indicator width\n\n## Acceptance Criteria\n- [ ] Renders menu items with borders\n- [ ] Selection highlighting\n- [ ] Separator support\n- [ ] Shortcut display (right-aligned)\n- [ ] Submenu indicator (►)\n- [ ] Nested menu navigation\n- [ ] Disabled item styling\n- [ ] Keyboard navigation\n\n## Files to Create/Modify\n- Create: src/widgets/menu.zig\n- Modify: src/widgets.zig (add export)","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-02T07:18:27.142248666Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:18:27.142248666Z","source_repo":".","compaction_level":0,"original_size":0}
{"id":"bd-tbm","title":"BigText widget","description":"## Summary\nImplement a BigText widget for rendering large decorative text using bitmap font glyphs.\n\n## Background\nBigText widgets create visually prominent text for:\n- Application splash screens\n- Section headers\n- ASCII art banners\n- Game titles\n\nSimilar to tui-big-text which uses font8x8 bitmap fonts.\n\n## Requirements\n\n### Widget Structure\n```zig\npub const BigText = struct {\n    text: []const u8,\n    style: Style = .{},\n    pixel_size: PixelSize = .full,\n    \n    pub const PixelSize = enum {\n        full,       // █ (full block)\n        half,       // ▀ ▄ (half blocks for 2x vertical resolution)\n        quarter,    // ▖ ▗ ▘ ▝ (quarter blocks for 2x2 resolution)\n    };\n};\n```\n\n### Font Data\nEmbed 8x8 bitmap font data:\n```zig\nconst font8x8 = struct {\n    // Each character is 8 bytes, one per row\n    // Each byte is 8 bits, one per column\n    const A = [8]u8{\n        0b00011000,  //    ██\n        0b00111100,  //   ████\n        0b01100110,  //  ██  ██\n        0b01111110,  //  ██████\n        0b01100110,  //  ██  ██\n        0b01100110,  //  ██  ██\n        0b01100110,  //  ██  ██\n        0b00000000,  //\n    };\n    // ... more characters\n};\n```\n\n### Rendering\nFor each character:\n1. Look up 8x8 bitmap\n2. For each set bit, render block character\n3. Space characters between letters\n\n### Pixel Size Modes\n- **full**: Each bit = 1 cell with '█'\n- **half**: Each 2 vertical bits = 1 cell with '▀', '▄', '█', or ' '\n- **quarter**: Each 2x2 bits = 1 cell with quarter blocks\n\n### Character Support\nMinimum: A-Z, a-z, 0-9, space, basic punctuation\nExtended: Full ASCII printable range\n\n### Dimensions\n- Full mode: 8 rows × (8 × text_len) columns\n- Half mode: 4 rows × (8 × text_len) columns\n- Quarter mode: 4 rows × (4 × text_len) columns\n\n## Implementation Hints\n- Embed font data at comptime\n- Use lookup table for character -> bitmap\n- Handle missing characters (show placeholder or skip)\n\n## Acceptance Criteria\n- [ ] Renders text in large bitmap font\n- [ ] Full block mode\n- [ ] Half block mode (2x vertical resolution)\n- [ ] Quarter block mode (2x2 resolution)\n- [ ] Custom styling\n- [ ] Handles unknown characters gracefully\n\n## Files to Create/Modify\n- Create: src/widgets/big_text.zig\n- Create: src/widgets/font8x8.zig (font data)\n- Modify: src/widgets.zig (add export)","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-02T07:19:07.663719947Z","created_by":"hotschmoe","updated_at":"2026-02-02T07:19:07.663719947Z","source_repo":".","compaction_level":0,"original_size":0}
